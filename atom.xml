<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GuoDong の Blog</title>
  
  
  <link href="https://guodongblog.com/atom.xml" rel="self"/>
  
  <link href="https://guodongblog.com/"/>
  <updated>2022-08-30T17:18:11.638Z</updated>
  <id>https://guodongblog.com/</id>
  
  <author>
    <name>Jelly</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GVIM学习笔记</title>
    <link href="https://guodongblog.com/posts/59c32301a699/"/>
    <id>https://guodongblog.com/posts/59c32301a699/</id>
    <published>2022-08-28T16:11:01.000Z</published>
    <updated>2022-08-30T17:18:11.638Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Vim 是 UNIX 文本编辑器 Vi 的加强版本,加入了更多特性来帮助编辑源代码。Vim 的部分增强功能包括文件比较（vimdiff），语法高亮，全面的帮助系统，本地脚本（Vimscript），和便于选择的可视化模式。 <strong>Vim 专注于键盘操作</strong>，这意味着带来丝滑操作的同，你需要花时间来学习，并值得花上更多的时间来掌握。在一般工作中更多的使用gvim，它是vim添加图形化界面后的版本，在linux与windows环境使用都很便捷。<br>获取GVIM很容易，输入vim.org，下载你喜欢的vim版本即可，或者从任何你喜欢的途径获取。接下来为了使得演示同步进行，也会在本机安装系统（WIN11）下最新版本的GVIM。同时请确保你的PC已经安装了GVIM。</p></blockquote><h1 id="GVIM的安装（windows版本）"><a href="#GVIM的安装（windows版本）" class="headerlink" title="GVIM的安装（windows版本）"></a>GVIM的安装（windows版本）</h1><p>你也可以点击这里<a href="https://ftp.nluug.nl/pub/vim/pc/gvim90.exe">直接下载</a>，或者进入vim官网，打开下载栏目，选择你要下载的文件下载。如下图所示，下载成功，你将会得到一个gvim.exe的可执行文件在你的下载目录。<br><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220828172854931-16617030863301.png" alt="GVIM下载地址与文件选择"></p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220828173241285-16617030863303.png" alt="安装步骤1"><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220828173213693-16617030863305.png" alt="安装步骤2"></p><p>最后选择一个安装地址即可完成安装。安装完成后会在桌面创建三个快捷方式，点击桌面快捷方式gVim 9.0即可打开gvim，其余删除即可。如下图所示。请不要进行其他操作，直接关闭该页面即可。接下来的章节会有更详细的介绍。<br><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220828173446377-16617030863317.png" alt="初始界面"></p><p>首先为了使得你的GVIM打开变得更加美丽，请将如下代码粘贴到你的_vimrc文件中。选中快捷方式，左键，选择打开文件所在位置，接下来向后退出一级即可找到该文件。该文件的作用以及下述代码的作用将会在后文进行介绍。更详细的GVIM配置将会在后文给出。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;---------User define set option-----------</span><br><span class="line">&quot;设置快速编辑.vimrc的快捷键</span><br><span class="line">:nnoremap ,ev :vsplit $MYVIMRC&lt;cr&gt;</span><br><span class="line">:nnoremap ,sv :source $MYVIMRC&lt;cr&gt;</span><br><span class="line"></span><br><span class="line">&quot;高亮配色设置</span><br><span class="line">syntax on  &quot;语法高亮度显示</span><br><span class="line">set t_Co=256  &quot;开启256色支持</span><br><span class="line">set hlsearch  &quot;搜索设置高亮</span><br><span class="line">colorscheme desert &quot;配色方案</span><br><span class="line">set background=dark &quot;配置主题整体的色调，只有两个选择：dark和light（暗色调和亮色调）</span><br><span class="line">highlight Function cterm=bold,underline ctermbg=red ctermfg=green &quot;color set</span><br><span class="line"></span><br><span class="line">&quot;set guifont=Monospace\ 16 &quot;gui style for linux</span><br><span class="line">set guifont=Courier_new:h16&quot;for windows</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="VIM的基本介绍"><a href="#VIM的基本介绍" class="headerlink" title="VIM的基本介绍"></a>VIM的基本介绍</h1><h2 id="VIM的三种模式"><a href="#VIM的三种模式" class="headerlink" title="VIM的三种模式"></a>VIM的三种模式</h2><p>VIM有三种模式，分别是<strong>命令模式（Command mode&#x2F;normal mode）</strong>，<strong>输入模式（Insert mode）</strong>和<strong>底线命令模式（Last line mode）</strong>。如下图所示，输入模式是用来编辑文本的，底线命令模式与命令模式分别用来处理用户命令。下图也分别展示了进入与退出各个模式的按键。<br><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/vim-vi-workmodel-16617030863319.png" alt="VIM的三种模式"></p><h2 id="VIM命令大全"><a href="#VIM命令大全" class="headerlink" title="VIM命令大全"></a>VIM命令大全</h2><p>这两种命令模式下有很多命令，一般在不需要过多的关注，在使用中慢慢学习，下面给出两个地址，为VIM命令大全，有关命令不在这里进行展示。<br><a href="https://www.runoob.com/linux/linux-vim.html">菜鸟教程 vim教程</a>以及<a href="https://www.w3cschool.cn/vim/cjtr1pu3.html">W3Cschool VIM教程</a>重点推荐后者。</p><h2 id="获取帮助的方式"><a href="#获取帮助的方式" class="headerlink" title="获取帮助的方式"></a>获取帮助的方式</h2><p>VIM本身提供了详细的帮助手册。打开你的VIM，输入<code>:h</code>即可打开帮助界面，可以用<code>:h _subject_</code>命令来访问。_subject_主题可以是命令，配置选项，热键绑定，插件等。使用<code>:h</code>命令（不带任何<em>subject</em>）来获取帮助系统的相关信息以及在不同的主题之间切换。<br><a href="https://guodongm.blog.csdn.net/article/details/115866450">VIM Tutor学习——基本的VIM操作</a>经过简单的学习，练习就应该可以操作vim了。</p><h2 id="VIM配置"><a href="#VIM配置" class="headerlink" title="VIM配置"></a>VIM配置</h2><p>我们前面打开的<code>_vimrc</code>文件就是VIM的配置。个人理解VIM受欢迎的原因，就是因为精简，其将大量的功能交给用户自定义。因此刚刚开始使用VIM的新手可能不是很习惯，甚至使用了很久的老鸟，使用别人的VIM也会不习惯。这其中除去基本的操作，VIM的配置是一个定义用户个人使用方案的文件。<br>在Linux环境下，该文件为位于<code>~/.vimrc</code>，在windows环境下，该文件位于你的你的VIM安装目录的后一级目录。名称为<code>_vimrc</code>在_任意_系统中，在Vim中执行<code>:echo $MYVIMRC</code>命令可以快速得知这个文件的位置和名称。 文件的路径会在屏幕的底部显示。</p><h2 id="VIM插件"><a href="#VIM插件" class="headerlink" title="VIM插件"></a>VIM插件</h2><p>使用插件来提高效率，它能改变Vim的界面，添加新命令，代码自动补全，整合其他程序和工具，添加其他编程语言等功能。VIM提供了很多有用户分享的插件，可以理解为自定义的功能，这将是一个及其强大的功能，在vim官网首页也有对应的栏目，可以用户上传分享自己的插件。在后续将会更详细的介绍vim插件。</p><div class="note simple"><p>小贴士: 参阅<a href="http://vimawesome.com/">Vim Awesome</a>获取一些热门插件</p></div><p>同时vim8.0以上的版本提供了自身的插件管理器，对于入门以及不是很复杂的插件管理已经足够了，这里简单介绍使用方式，后续插件的安装就直接使用插件管理器进行管理即可。使用如下命令可以进行查看<code>:help packages</code></p><h3 id="插件管理器"><a href="#插件管理器" class="headerlink" title="插件管理器"></a>插件管理器</h3><p>插件管理器使安装和管理插件有相似的方法，而与在何种平台上运行Vim无关。它是一个像包管理器一样的用来管理其它Vim插件的插件。这里使用vim自带的插件管理器package。首先确保你的vim版本是在8.0以上。<br>然后在你的<code>.vim</code>文件夹下新建一个文件夹，<code>pack</code>，进入后执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p package/start</span><br><span class="line">mkdir -p package/opt</span><br></pre></td></tr></table></figure><p>这里其实是新建两个文件夹，作为以后插件安装更方便的使用。可以理解为，package可以是任何名称，主要用于表明你的插件是做什么的，可以是一个大的类，然后可以将你需要执行的插件解压缩放在对应插件的start目录下同样是一个文件夹，是一个小的类型，该文件夹中就是下载的插件，将暂时不需要执行的插件放置在opt目录下。使用可以调用<code>:packadd package</code>目录下opt中的插件。这样一个插件新建一个文件夹，就可以不用担心插件管理的问题了。可以随时删除更新而不会影响其他的插件。同样还有一个好处是不需要联网，可以直接使用安装包进行插件的安装。更详细的使用将在后续的插件使用部分进行展示。</p><div class="note simple"><p>小贴士: windows环境下，将<code>.vim</code>文件夹换成<code>vimfiles</code>即可，问价的位置与<code>_vimrc</code>在同级目录下哦</p></div><h1 id="GVIM进阶"><a href="#GVIM进阶" class="headerlink" title="GVIM进阶"></a>GVIM进阶</h1><p>前面经过简单的介绍，同时经过一段时间的学习，GVIM的相关命令的进一步熟练，接下来的部分将会帮助你更好的使用GVIM，不仅炫酷且简洁，强大且灵活！！！！！！</p><p>本文参考<a href="https://learnvimscriptthehardway.stevelosh.com/">艰难地学习 Vimscript</a>本书大致分为三个部分：</p><ul><li>第一部分讲述了一些Vim的基本命令，通过这些命令修改你的<code>~/.vimrc</code>可以快速、 方便地定制你的Vim环境。</li><li>第二部分将Vimscript作为一门编程语言做深入了解，包括变量、比较还有函数。</li><li>第三部分实例创建一个插件。</li></ul><p>我也会将其概括性的总结，将其进一步总结精炼。按自己的理解进行重新划分，完成下面的部分。</p><h2 id="Vimscript-设置选项"><a href="#Vimscript-设置选项" class="headerlink" title="Vimscript 设置选项"></a>Vimscript 设置选项</h2><p>Vim拥有很多选项可以设置以改变其展现方式。主要有两种选项：布尔选项（值为”on”或”off”）和键值选项。</p><h3 id="布尔选项"><a href="#布尔选项" class="headerlink" title="布尔选项"></a>布尔选项</h3><p>执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set number</span><br></pre></td></tr></table></figure><p>如果之前屏幕左侧没有显示行号，那么现在你就会看见行号。执行命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set nonumber</span><br></pre></td></tr></table></figure><p>行号应该消失。<code>number</code>是一个布尔选项：可以off、可以on。通过<code>:set number</code>命令打开、 <code>:set nonumber</code>命令关闭。所有的布尔选项都是这种配置方法。<code>:set &lt;name&gt;</code>打开选项、<code>:set no&lt;name&gt;</code>关闭选项。</p><h3 id="切换布尔选项"><a href="#切换布尔选项" class="headerlink" title="切换布尔选项"></a>切换布尔选项</h3><p>你可以”切换”布尔选项的值，即从开启切为关闭或从关闭切为开启。执行命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set number!</span><br></pre></td></tr></table></figure><p>行号会再次显示出来。再次执行命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set number!</span><br></pre></td></tr></table></figure><p>行号应该会再次消失。添加一个<code>!</code>（感叹号）至布尔选项后面就会切换对于选项的值。</p><h3 id="查看选项当前值"><a href="#查看选项当前值" class="headerlink" title="查看选项当前值"></a>查看选项当前值</h3><p>你可以使用一个<code>?</code>符号向Vim获取一个选项的当前值。执行如下命令并查看每个命令的 返回结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set number</span><br><span class="line">:set number?</span><br><span class="line">:set nonumber</span><br><span class="line">:set number?</span><br></pre></td></tr></table></figure><p>注意第一次<code>:set number?</code>命令返回的是<code>number</code>而第二次返回的是<code>nonumber</code>。</p><h3 id="键值选项"><a href="#键值选项" class="headerlink" title="键值选项"></a>键值选项</h3><p>有些选项并不只有off或on两种状态，它们需要一个值。执行如下命令，查看返回结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set number</span><br><span class="line">:set numberwidth=10</span><br><span class="line">:set numberwidth=4</span><br><span class="line">:set numberwidth?</span><br></pre></td></tr></table></figure><p><code>numberwidth</code>选项改变行号的列宽。你可以通过<code>:set &lt;name&gt;=&lt;value&gt;</code>命令改变 非布尔选项的选项值，并使用<code>:set &lt;name&gt;?</code>命令查看选项的当前值。来看看一些常用选项的值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set wrap?</span><br><span class="line">:set shiftround?</span><br><span class="line">:set matchtime?</span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>阅读<code>:help &#39;number&#39;</code>（注意有单引号）帮助文档。<br>阅读<code>:help relativenumber</code>帮助文档。<br>阅读<code>:help numberwidth</code>帮助文档。<br>阅读<code>:help wrap</code>帮助文档。<br>阅读<code>:help shiftround</code>帮助文档。<br>阅读<code>:help matchtime</code>帮助文档。<br>按你自己的喜好在你的<code>~/.vimrc</code>文件中添加几个设置选项。</p><h2 id="VIM基本映射"><a href="#VIM基本映射" class="headerlink" title="VIM基本映射"></a>VIM基本映射</h2><p>简单来说就是，<strong>当我按下这个键时，我需要你放弃默认操作，按我的想法做。</strong><br>我们先从normal模式，就是命令模式的键盘映射开始。随意在文本中敲写几行文字，然后运行命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:map - x</span><br></pre></td></tr></table></figure><p>将光标置于文本中的某处，按下<code>-</code>。注意Vim删除了当前光标下的字符，就好像你按了<code>x</code>一样。我们本来就有个按键用于 “删除当前光标下的字符” ，所以我们将<code>-</code>重新映射到稍微有用的 功能。执行命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:map - dd</span><br></pre></td></tr></table></figure><p>现在移动光标到任意一行，再按下<code>-</code>，这次Vim删除了整行的文本，因为<code>dd</code>的功能就是删除整行。同时注意可以映射特殊字符，但是注释是不被允许的。如下举例<code>:map &lt;space&gt; viw &quot; Select word</code>。可以自行尝试。我们了解到，vim有三种模式，命令模式，输入模式与命令行模式，可以使用<code>nmap</code>、<code>vmap</code>和<code>imap</code>命令分别指定映射仅在normal、visual、insert模式有效。同时还有这里还需要考虑递归。<br>尝试添加如下命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:nmap x dd</span><br><span class="line">:nmap \ x</span><br><span class="line">”:nnoremap \ x</span><br></pre></td></tr></table></figure><p>尝试将第二第三行分别使用<code>&quot;</code>来进行注释，查看在normal模式下的x的行为以及<code>\</code>的行为。在使用非递归模式的时候，使用<code>\</code>删除的是光标所在的字符，不加nore时，删除的是整个行。需要清楚，每一个<code>*map</code>系列的命令都有个对应的<code>*noremap</code>命令，包括：<code>noremap</code>&#x2F;<code>nnoremap</code>、 <code>vnoremap</code>和<code>inoremap</code>。这些命令将不递归解释映射的内容。该何时使用这些非递归的映射命令呢？答案是： <strong>任何时候</strong> 。<strong>是的，没开玩笑， *任何时候* 。</strong></p><h2 id="Vimscript-Leaders"><a href="#Vimscript-Leaders" class="headerlink" title="Vimscript Leaders"></a>Vimscript Leaders</h2><p>键盘映射方法可以使得我们使用一个按键具有一个新的功能，但是他会将按键原有的功能覆盖掉。vim提供了leader来解决这个问题。我们称这个“前缀”为“leader”。你可以按你的喜好设置你的leader键。运行命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:let mapleader = &quot;,&quot;</span><br></pre></td></tr></table></figure><p>你可以替换<code>,</code>为你喜欢的按键。推荐使用<code>,</code>，因为这个键比较 比较容易按到。当你创建新的映射时，你可以使用<code>&lt;leader&gt;</code>表示“我设置的leader按键”。运行命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:nnoremap &lt;leader&gt;d dd</span><br></pre></td></tr></table></figure><p>现在试试按下你的leader按键和<code>d</code>，也就是<code>,d</code>。Vim会删除当前行。Vim有另外一个“leader”成为“local leader“。这个leader用于那些只对某类文件 （如Python文件、HTML文件）而设置的映射。阅读<code>:help mapleader</code>，help maplocalleader&#96;获取相关信息</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Vim 是 UNIX 文本编辑器 Vi 的加强版本,加入了更多特性来帮助编辑源代码。Vim 的部分增强功能包括文件比较（vimdiff），语法高亮，全面的帮助系统，本地脚本（Vimscript），和便于选择的可视化模式。 &lt;strong&gt;Vim 专</summary>
      
    
    
    
    <category term="文本编辑器" scheme="https://guodongblog.com/categories/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
    
    <category term="GVIM" scheme="https://guodongblog.com/tags/GVIM/"/>
    
  </entry>
  
  <entry>
    <title>mathtype7.x破解与基本使用</title>
    <link href="https://guodongblog.com/posts/3d6907a6ce7c/"/>
    <id>https://guodongblog.com/posts/3d6907a6ce7c/</id>
    <published>2022-06-10T03:47:40.000Z</published>
    <updated>2022-06-10T03:53:08.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MathType与Office公式编辑器区别"><a href="#MathType与Office公式编辑器区别" class="headerlink" title="MathType与Office公式编辑器区别"></a>MathType与Office公式编辑器区别</h1><p>许多论文或文献中含有大量较复杂的公式或者符号，为了使文章中的公式符号更加规范、美观，现在很多人选用MathType软件来编辑公式。MathType具有非常强大的公式编辑能力，和我们常用的Office软件结合非常紧密，能非常便捷的嵌入word和ppt文档。<br>MathType与Office中自带的公式编辑器相比，具有以下的特点：<br><strong>1.MathType对每一项符号都有简单说明<br>2.MathType分类更明细，说明更清楚，输入更方便<br>3.MathType输入公式时可在常用公式类型下整体输入<br>4.具有一些Office没有的符号</strong><br>详见<a href="https://www.mathtype.cn/news/gongshi-bianjiqi.html">MathType与Office公式编辑器区别</a></p><h1 id="MathType的安装"><a href="#MathType的安装" class="headerlink" title="MathType的安装"></a>MathType的安装</h1><p> 1.首先打开MathType中文网的下载链接（<a href="https://www.mathtype.cn/xiazai.html%EF%BC%89%EF%BC%8C%E7%82%B9%E5%87%BB%E2%80%9C%E5%85%8D%E8%B4%B9%E4%B8%8B%E8%BD%BD%E2%80%9D%EF%BC%8C%E7%9B%AE%E5%89%8D%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E6%98%AFMathType7%E3%80%82">https://www.mathtype.cn/xiazai.html），点击“免费下载”，目前最新版本是MathType7。</a><br>详见<a href="https://www.mathtype.cn/jiqiao/mathtype-ujazg.html">如何正确地安装MathType 7？</a></p><h1 id="MathType7-x的破解使用"><a href="#MathType7-x的破解使用" class="headerlink" title="MathType7.x的破解使用"></a>MathType7.x的破解使用</h1><p>安装完成后，创建一个<code>Mathtype7.reg</code>文件，将其移动到你的安装目录。文本内容如下。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[-HKEY_CURRENT_USER\Software\JavaSoft\Prefs\com\wiris\editor\license\]</span><br><span class="line">[HKEY_CURRENT_USER\Software\JavaSoft\Prefs\com\wiris\editor\license\]</span><br><span class="line"><span class="string">&quot;/Cv/E/C81+j/Rw/U/E6ws/Znt/Os/K/Q==&quot;</span>=<span class="string">&quot;11/M/P/Ir/Y/B/S/P/Pr/Q/L/Ny/T9s4/Iw==&quot;</span></span><br><span class="line"><span class="string">&quot;/Mz/Bhef/D/Q/Hs30/U6/F/Pdl/R/Xsg==&quot;</span>=<span class="string">&quot;/S/Zd8c/Ai/Z/A83028s6/Kn/Gf/M/Q==&quot;</span></span><br><span class="line"><span class="string">&quot;vi/L/M7/K/Hb/C/O/A/K/X9uuis/O1/J/A==&quot;</span>=<span class="string">&quot;/S/Zd8c/Ai/Z/A80\\/O/S/C/Vgp\\0/P/Q==&quot;</span></span><br><span class="line"><span class="string">&quot;wm/U/C/Y/T/Nz5/Tw=&quot;</span>=<span class="string">&quot;/Wna/F/W3q/I/Yp/V\\lj/Dedai56/Ur/Wpf/P/Kpl/Soh/A/Z/Qe\\6hit3ym\\6m5sp/B/B/Q==&quot;</span></span><br><span class="line"><span class="string">&quot;x/W/Yrj/M/Db/Bds=&quot;</span>=<span class="string">&quot;104z/W8rbqpw5\\/Qz0/C/Q/Opu/Dj/B5b/Dwsy77&quot;</span></span><br></pre></td></tr></table></figure><p>然后放到你的安装目录下，运行即可，出现的警告点击确认。就可以完成修改，然后查看mathtype即可看到。帮助&#x2F;关于MathType。<br><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/a9a03e127ac84af0a62c0ae9753e01c3.png"><br>恭喜你哦！！！实现了MathType自由！！！<br>参考这里<a href="https://kiemtieu.com/key-mathtype-7/">MathType7.x的破解使用</a><br>这里大致解释下，大致原理就是通过修改注册表来延长试用时间。你可以在对于对应目录下看到对应添加的内容。如下所示。<br><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/eafcfd96f28b4a53888c08992880c953.png"></p><h1 id="基本的使用"><a href="#基本的使用" class="headerlink" title="基本的使用"></a>基本的使用</h1><p>打开word。打开MathType。选择内联<br><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/a0c6716255ec43018afa4bf7607c46aa.png"><br>然后在输入框输入你的公式，使用<code>Ctrl+S</code>即可将输入框内的公式放到你的word鼠标所在位置。<br><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/b0340f56d365489c91319b209ed49fe8.gif"><br>参考这里 <a href="https://zhidao.baidu.com/question/527811815072549485.html">MathType的基本使用</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MathType与Office公式编辑器区别&quot;&gt;&lt;a href=&quot;#MathType与Office公式编辑器区别&quot; class=&quot;headerlink&quot; title=&quot;MathType与Office公式编辑器区别&quot;&gt;&lt;/a&gt;MathType与Office公式编辑器</summary>
      
    
    
    
    <category term="软件破解" scheme="https://guodongblog.com/categories/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/"/>
    
    
    <category term="MathType" scheme="https://guodongblog.com/tags/MathType/"/>
    
    <category term="软件破解" scheme="https://guodongblog.com/tags/%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>dc_labs--lab1的学习与总结</title>
    <link href="https://guodongblog.com/posts/152222de7076/"/>
    <id>https://guodongblog.com/posts/152222de7076/</id>
    <published>2022-06-05T10:27:01.000Z</published>
    <updated>2022-06-06T01:02:18.851Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本节为dc_labs系列的第一篇，主要根据自己对于lab的理解，简述实验的过程，同时对于笔者自己觉得需要进一步理解的进行总结学习。本节重点在于理解启动文件与DC的综合流程。建议与对应博文(<a href="https://guodongblog.com/posts/80912d01b675/">DC学习笔记正式篇之零——综述与基本流程介绍</a>)进行结合起来进行学习。该文为对应部分的实践篇的内容。本系列博文不会只是带着进行实验内容，个人觉得单纯跑一遍实验意义不大。会结合自己学习的理解进行部分展开。有问题欢迎留言一起学习。同时会对lab的内容进行一定的简化，完整的lab_guide(笔者已经进行了简单的翻译)请加入QQ群获取。</p></blockquote><h1 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h1><p>1，通过该实验可以学会<strong>配置DC的启动文件</strong>，同时对其中的配置部分进行理解学习<br>2，理解DC做综合的流程，在topo拓扑模式下<strong>完成综合</strong>，<strong>体验synthesis flow</strong><br>3，学会自己获取DC的帮助界面进行相关命令的查询</p><h1 id="实验流程"><a href="#实验流程" class="headerlink" title="实验流程"></a>实验流程</h1><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220605184157403.png" alt="实验流程"><br>该实验流程简单的对DC综合进行了一个概述，简单来说就是<strong>设置dc的启动文件，然后读入设计，读入约束，综合，生成报告，写入编译好的文件并保存，退出</strong>。这只是一个很top层的一个理解，重点在于清楚这些步骤，以及简单了解这些步骤是做什么就可以了，后续对于每一步，都有相关的实验。了解一个完整的过程，后续在一点点的深入。<br>对于该部分的重点这里再赘述一遍，理解启动文件的内容是什么，尽可能的学习自己进行相关文件的配置，其次是学习体验整个综合流程，最后是学会自己使用帮助命令查询自己需要理解的指令</p><h1 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h1><h2 id="任务1，查看浏览启动文件"><a href="#任务1，查看浏览启动文件" class="headerlink" title="任务1，查看浏览启动文件"></a>任务1，查看浏览启动文件</h2><p>进入lab1的目录，然后查看启动文件<code>.synopsys_dc.setup</code>文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd lab1</span><br><span class="line">gvim .synopsys_dc.setup</span><br></pre></td></tr></table></figure><p>我们可以看到对应的内容如下，其中重点在于source的两个文件，其余设置并不是必须的。<code>aliases</code>相当于别名的设置，<code>history</code>设置保存历史命令的条数，<code>suppress_message</code>用来屏蔽相关的警告信息<br>第一个是<code>common_setup.tcl</code>。另一个是<code>dc_setup.tcl</code>文件，我们分别打开两个文件来看其中的内容。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220605192109266.png" alt=".synopsys_dc.setup dc启动文件"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220605192714167.png" alt="相关库的设置"></p><p>更详细的库的设置说明在<a href="https://guodongblog.com/posts/80912d01b675/">DC学习笔记正式篇之零——综述与基本流程介绍</a>已经进行了解释，这里进行概述性的解释，其中左边的common文件就是对于一些变量进行定义，然后再dc_setup中调用进行设置，因此source的顺序也是有先后的。对其中的解释如下：</p><ul><li>search_path 搜索路径。顾名思义就是用来查找相关需要使用的工艺库呀，设计文件，脚本等</li><li>target_library 目标库&#x2F;工艺库 指定工艺库的名称，是综合后电路网表要最终映射到的库</li><li>link_library 链接库 link_library 设置模块或者单元电路的引用，对于所有 DC 可能用到的库，我们都需要在link_library 中指定，一般与target_library相同</li><li>symbol_library 符号库  symbol_library 是定义了单元电路显示的 Schematic 的库。用户如果想启动design_analyzer 或 design_vision 来查看、 分析电路时需要设置 symbol_library。</li><li>create_mw_lib 创建一个mw库文件，这里的库名称是<code>$mw_design_library</code>（实际上是变量设置的TOP_LIB）<ul><li>create_mw_lib的直接参数是设计库名称<br> -technology 指定的参数是工艺库名称<br> -mw_reference_library 指定的参数是参考库名称。</li><li>其中，Synopsys使用一个统一的Milkyway database可以在Synopsys Galaxy™Design Platform中所有的EDA工具之间进行数据交换，避免了工具之间文件格式转换的大量时间花费，文件之间语义不匹配造成的信息丢失等问题。Design Compiler可以write_milkyway一个mapped之后的Milkyway database IC Compiler从Milkyway database中读取设计信息和库信息，然后执行placement, clock tree synthesis和 routing。也可以将不同阶段的设计信息再保存为Milkyway database。若tluplus文件没有时，可由foundry给的.itf转成tluplus。使用的是Synopsys公司的star_RC.</li></ul></li><li>set_tlu_plus_files 设置寄生参数库。寄生RC查找表，ICC使用网络几何形状以及该文件来计算互联电阻电容。若tluplus文件没有时，可由foundry给的.itf转成tluplus。使用的是Synopsys公司的star_RC.</li></ul><p>这里解释一些为什么还需要这些Milkyway相关的设置，这里使用的综合是dc在topo模式下的综合，已经有了相对严格真实的延时，而不需要使用线负载模型中的延时参数，会使得综合时序更接近真实情况。一般在自己实验阶段compile就已经可以了，这里我们需要使用的编译命令是compile_ultra。</p><h2 id="任务2，启动DC，检查启动文件加载情况"><a href="#任务2，启动DC，检查启动文件加载情况" class="headerlink" title="任务2，启动DC，检查启动文件加载情况"></a>任务2，启动DC，检查启动文件加载情况</h2><p>我们前面介绍dc在启动时候会加载启动文件，这里启动DC以后进一步检查DC是否已经正确设置了我们启动文件中指定的路径以及相关库的信息。输入 <code>dc_shell -topo</code>，看到如下打印信息，由于我并不是第一次打开，会出现 <code>Error: Library &#39;TOP_LIB&#39; already exists. (MWUI-004)</code>可以忽略。可以看到已经进入了topo模式，然后输入<code>gui_start</code>就可以看到弹出来的GUI界面了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[icer@ICer lab1]$ dc_shell -topo</span><br><span class="line">...</span><br><span class="line">Initializing...</span><br><span class="line">Starting shell in Topographical mode...</span><br><span class="line">Error: Library &#x27;TOP_LIB&#x27; already exists. (MWUI-004)</span><br><span class="line"></span><br><span class="line">==================================================================</span><br><span class="line"></span><br><span class="line">Library Settings:</span><br><span class="line">search_path:             . /opt/Synopsys/syn2018/syn/O-2018.06-SP1/libraries/syn /opt/Synopsys/syn2018/syn/O-2018.06-SP1/minpower/syn /opt/Synopsys/syn2018/syn/O-2018.06-SP1/dw/syn_ver /opt/Synopsys/syn2018/syn/O-2018.06-SP1/dw/sim_ver ../ref/libs/mw_lib/sc/LM  ./rtl ./scripts</span><br><span class="line">link_library:            * sc_max.db</span><br><span class="line">target_library:          sc_max.db</span><br><span class="line">symbol_library:          sc.sdb</span><br><span class="line">mw_reference_library:    ../ref/libs/mw_lib/sc</span><br><span class="line">mw_design_library:       TOP_LIB</span><br><span class="line"></span><br><span class="line">==================================================================</span><br><span class="line">I am ready...</span><br><span class="line">Initializing gui preferences from file  /home/icer/.synopsys_dv_prefs.tcl</span><br><span class="line">dc_shell-topo&gt;gui_start</span><br></pre></td></tr></table></figure><h3 id="1，检查set-up项的内容"><a href="#1，检查set-up项的内容" class="headerlink" title="1，检查set_up项的内容"></a>1，检查set_up项的内容</h3><p>查看是否与设置的启动文件中的内容一致</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220605200301306.png" alt="GUI界面检查相关库的设置"></p><h3 id="2，在命令行进行对应的检查"><a href="#2，在命令行进行对应的检查" class="headerlink" title="2，在命令行进行对应的检查"></a>2，在命令行进行对应的检查</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printvar target_library</span><br><span class="line">printvar link_library</span><br><span class="line">printvar search_path</span><br><span class="line">alias</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dc_shell-topo&gt; printvar target_library</span><br><span class="line">target_library       = &quot;sc_max.db&quot;</span><br><span class="line">dc_shell-topo&gt; printvar link_library</span><br><span class="line">link_library         = &quot;* sc_max.db&quot;</span><br><span class="line">dc_shell-topo&gt; printvar search_path</span><br><span class="line">search_path          = &quot;. /opt/Synopsys/syn2018/syn/O-2018.06-SP1/libraries/syn /opt/Synopsys/syn2018/syn/O-2018.06-SP1/minpower/syn /opt/Synopsys/syn2018/syn/O-2018.06-SP1/dw/syn_ver /opt/Synopsys/syn2018/syn/O-2018.06-SP1/dw/sim_ver ../ref/libs/mw_lib/sc/LM  ./rtl ./scripts&quot;</span><br><span class="line">aliasell-topo&gt; </span><br></pre></td></tr></table></figure><h3 id="3，检查逻辑库和物理库之间的一致性"><a href="#3，检查逻辑库和物理库之间的一致性" class="headerlink" title="3，检查逻辑库和物理库之间的一致性"></a>3，检查逻辑库和物理库之间的一致性</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">check_library  </span><br></pre></td></tr></table></figure><p>请注意，检查报告逻辑库中缺少 4 个单元格。有一个表格列出了缺少的单元格。它们是“馈通”和“分接单元”，在物理布局中是必需的，但在逻辑设计中不需要（也称为“仅物理”单元）。因此可以忽略警告。输出如下</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220605200937713.png" alt="警告信息，这里不用关心"></p><h3 id="4，检查-TLUPus-和技术文件之间的一致性"><a href="#4，检查-TLUPus-和技术文件之间的一致性" class="headerlink" title="4，检查 TLUPus 和技术文件之间的一致性"></a>4，检查 TLUPus 和技术文件之间的一致性</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">check_tlu_plus_files</span><br></pre></td></tr></table></figure><p>看到三个pass信息。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220605201056647.png" alt="check_tlu_plus_files检查输出打印信息"></p><h2 id="任务3，读入设计文件，写入unmapped文件"><a href="#任务3，读入设计文件，写入unmapped文件" class="headerlink" title="任务3，读入设计文件，写入unmapped文件"></a>任务3，读入设计文件，写入unmapped文件</h2><h4 id="1，读入设计"><a href="#1，读入设计" class="headerlink" title="1，读入设计"></a>1，读入设计</h4><p>在GUI界面读入设计文件。成功以后<code>link</code>设计。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220605201321665.png" alt="读入设计文件"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220605201716143.png" alt="link design"></p><p>命令行与log栏打印的成功信息如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dc_shell-topo&gt; link</span><br><span class="line"></span><br><span class="line">  Linking design &#x27;TOP&#x27;</span><br><span class="line">  Using the following designs and libraries:</span><br><span class="line">  --------------------------------------------------------------------------</span><br><span class="line">  * (4 designs)               /home/icer/Desktop/lab/dc_lab/DC_2013.12/lab1/rtl/TOP.db, etc</span><br><span class="line">  cb13fs120_tsmc_max (library) /home/icer/Desktop/lab/dc_lab/DC_2013.12/ref/libs/mw_lib/sc/LM/sc_max.db</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>可以打开原理图，进行相关的探索。这里不进行详述，可以查看lab_guide相关内容，鼠标点开查看其标准单元为GRTCH的形式。同时是有逻辑层次的，注意可以和综合后进行对比。<br><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220605201419743.png" alt="TOP的原理图"></p><h4 id="2，写入unmapped文件"><a href="#2，写入unmapped文件" class="headerlink" title="2，写入unmapped文件"></a>2，写入unmapped文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">write -hier -f ddc -out unmapped/TOP.ddc  </span><br></pre></td></tr></table></figure><p>打印信息如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dc_shell-topo&gt; write -hier -f ddc -out unmapped/TOP.ddc</span><br><span class="line">Writing ddc file &#x27;unmapped/TOP.ddc&#x27;.</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>查看dc内存中的设计与库文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list_designs</span><br><span class="line">list_libs</span><br></pre></td></tr></table></figure><p>打印结果如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dc_shell-topo&gt; list_designs</span><br><span class="line">COUNT   DECODE  FSM     TOP (*)</span><br><span class="line">1</span><br><span class="line">dc_shell-topo&gt; list_libs</span><br><span class="line"></span><br><span class="line">Logical Libraries:</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">LibraryFilePath</span><br><span class="line"></span><br><span class="line">---------------</span><br><span class="line"></span><br><span class="line">  cb13fs120_tsmc_max sc_max.db/home/icer/Desktop/lab/dc_lab/DC_2013.12/ref/libs/mw_lib/sc/LM</span><br><span class="line">  gtechgtech.db/opt/Synopsys/syn2018/syn/O-2018.06-SP1/libraries/syn</span><br><span class="line">  standard.sldbstandard.sldb/opt/Synopsys/syn2018/syn/O-2018.06-SP1/libraries/syn</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="任务4，约束设计-amp-编译"><a href="#任务4，约束设计-amp-编译" class="headerlink" title="任务4，约束设计&amp;编译"></a>任务4，约束设计&amp;编译</h2><h3 id="1，约束设计"><a href="#1，约束设计" class="headerlink" title="1，约束设计"></a>1，约束设计</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source scripts/TOP.con</span><br></pre></td></tr></table></figure><p>打印信息如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dc_shell-topo&gt; source scripts/TOP.con </span><br><span class="line">Current design is &#x27;TOP&#x27;.</span><br><span class="line">Information: No preferred routing direction is found for design layer METAL. Automatically deriving direction H. (DCT-035)</span><br><span class="line">Information: No preferred routing direction is found for design layer METAL2. Automatically deriving direction V. (DCT-035)</span><br><span class="line">Information: No preferred routing direction is found for design layer METAL3. Automatically deriving direction H. (DCT-035)</span><br><span class="line">Information: No preferred routing direction is found for design layer METAL4. Automatically deriving direction V. (DCT-035)</span><br><span class="line">Information: No preferred routing direction is found for design layer METAL5. Automatically deriving direction H. (DCT-035)</span><br><span class="line">Information: No preferred routing direction is found for design layer METAL6. Automatically deriving direction V. (DCT-035)</span><br><span class="line">1</span><br><span class="line">Current design is &#x27;TOP&#x27;.</span><br></pre></td></tr></table></figure><p>这里对于其中的约束内容不进行介绍，后续会有更详细的分析。</p><h3 id="2，编译"><a href="#2，编译" class="headerlink" title="2，编译"></a>2，编译</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compile_ultra</span><br></pre></td></tr></table></figure><p>等待编译完成。在编译过程中监控日志。您将看到编译的不同优化阶段的各种表格。 “AREA”栏表示设计尺寸。 “WORST NEG SLACK”列指示设计中的关键或最差路径违反了多少，相对于其约束（实际延迟 - 预期延迟）。 “TOTAL NEG SLACK”是所有违反路径松弛的总和。当优化达到“收益递减”点，或者松弛数达到零时，这意味着设计中没有违反时序路径，compile_ultra结束。compile ultra 已自动展平或“取消分组”子设计 DECODE、FSM 和 COUNT，以生成最佳时序和面积结果。这里的原理图中的标准单元就已经不是GETCH的形式了。<br>这里笔者综合以后，原本的界面就会消失，需要重新打开。<br><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220605204048574.png"><br>注意如下是TOP层，已经没有层次划分了。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220605203649530.png" alt="TOP层"><br>使用滚轮将其放大，看到，其中的标准单元已经不是GETCH的形式了。而是目标库里的。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220605203820084.png" alt="标准单元"></p><h2 id="任务5，查看报告并写入保存综合后的文件。"><a href="#任务5，查看报告并写入保存综合后的文件。" class="headerlink" title="任务5，查看报告并写入保存综合后的文件。"></a>任务5，查看报告并写入保存综合后的文件。</h2><h3 id="1，写入编译好的文件"><a href="#1，写入编译好的文件" class="headerlink" title="1，写入编译好的文件"></a>1，写入编译好的文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">write -hierarchy -format ddc -output /home/icer/Desktop/lab/dc_lab/DC_2013.12/lab1/unmapped/TOP.ddc</span><br></pre></td></tr></table></figure><p>也可以使用图形化的界面进行保存，选择TOP，选择file-&gt;save as，选择保存的目录即可。</p><h3 id="2，查看报告"><a href="#2，查看报告" class="headerlink" title="2，查看报告"></a>2，查看报告</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rc </span><br><span class="line">rt</span><br></pre></td></tr></table></figure><p>其对应的意义在alias中已经进行定义，可以自行查看。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias rc &quot;report_constraint -all_violators&quot;</span><br><span class="line">alias rt report_timing</span><br></pre></td></tr></table></figure><p>键入exit退出dc。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><h2 id="任务6，执行脚本与获取帮助"><a href="#任务6，执行脚本与获取帮助" class="headerlink" title="任务6，执行脚本与获取帮助"></a>任务6，执行脚本与获取帮助</h2><h3 id="1，执行脚本"><a href="#1，执行脚本" class="headerlink" title="1，执行脚本"></a>1，执行脚本</h3><p>我们前面就是将命令一步一步输入的，也可以直接执行脚本来一步操作以上所有步骤，这里我们直接使用solution里提供的脚本即可。<code>.solution</code>相当于答案，里边有对应的脚本，查看脚本，如下图所示，这里需要对source TOP.con的位置进行修改。<br><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220605233856898.png" alt="solution目录下的dc.tcl"><br>然后执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dc_shell -topo -f .solutions/dc.tcl | tee dc.log</span><br></pre></td></tr></table></figure><p>等待编译结束即可。</p><h3 id="2，获取帮助"><a href="#2，获取帮助" class="headerlink" title="2，获取帮助"></a>2，获取帮助</h3><p>假设我们需要查找带有clock的命令。先使用如下命令进行查找：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">help *clock*</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dc_shell-topo&gt; help *clock*</span><br><span class="line"> all_clock_gates      # create a collection of clock gating cells or pins</span><br><span class="line"> all_clocks           # return all clocks in the current design</span><br><span class="line"> apply_clock_gate_latency # Spread and annotate clock latencies on the existing clock gates</span><br><span class="line"> create_clock         # create clock</span><br><span class="line"> create_generated_clock # create generated clock</span><br><span class="line"> create_qtm_clock     # Create a quick timing model clock</span><br><span class="line"> create_qtm_generated_clock # Create a generated clock in quick timing model</span><br><span class="line"> get_clocks           # create a collection of design clocks</span><br><span class="line"> get_generated_clocks # create a collection of generated clocks</span><br><span class="line"> identify_clock_gating # identify_clock_gating</span><br><span class="line"> insert_clock_gating  # insert_clock_gating</span><br><span class="line"> remove_clock         # remove clock</span><br><span class="line"> remove_clock_gating  # remove_clock_gating</span><br><span class="line"> remove_clock_gating_check # remove clock_gating_check</span><br><span class="line"> remove_clock_gating_style # remove_clock_gating_style</span><br><span class="line"> remove_clock_groups  # remove clock_groups</span><br><span class="line"> remove_clock_latency # remove clock_latency</span><br><span class="line"> remove_clock_sense   # remove_clock_sense</span><br><span class="line"> remove_clock_transition # remove clock_transition</span><br><span class="line"> remove_clock_uncertainty # remove clock_uncertainty</span><br><span class="line"> remove_dft_clock_gating_pin # Remove DFT clock gating pin specification</span><br><span class="line"> remove_disable_clock_gating_check # remove_disable_clock_gating_check</span><br><span class="line"> remove_generated_clock # remove generated clock</span><br><span class="line"> remove_propagated_clock # remove_propagated_clock</span><br><span class="line"> replace_clock_gates  # replace_clock_gates</span><br><span class="line"> report_clock         # report clock</span><br><span class="line"> report_clock_gating  # report clock gating</span><br></pre></td></tr></table></figure><p>假设我们需要查看all_clock这条命令，输入如下命令即可：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">man all_clocks</span><br></pre></td></tr></table></figure><p>这里的man就是manual，手册的意思。就可以查看相关命令的解释举例等相关信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本节为dc_labs系列的第一篇，主要根据自己对于lab的理解，简述实验的过程，同时对于笔者自己觉得需要进一步理解的进行总结学习。本节重点在于理解启动文件与DC的综合流程。建议与对应博文(&lt;a href=&quot;https://guodongblog.c</summary>
      
    
    
    
    <category term="DC" scheme="https://guodongblog.com/categories/DC/"/>
    
    <category term="dc_labs" scheme="https://guodongblog.com/categories/DC/dc-labs/"/>
    
    
    <category term="DC学习笔记" scheme="https://guodongblog.com/tags/DC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="dc_labs" scheme="https://guodongblog.com/tags/dc-labs/"/>
    
  </entry>
  
  <entry>
    <title>Win11安装ise14.7（最终解决方案）——Ubuntu18.04安装ISE与modelsim</title>
    <link href="https://guodongblog.com/posts/cd9705ae4bd1/"/>
    <id>https://guodongblog.com/posts/cd9705ae4bd1/</id>
    <published>2022-06-02T14:50:17.000Z</published>
    <updated>2022-06-02T15:05:29.852Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文标题：How to install Xilinx ISE Design Suite 14.7 on Ubuntu 18.04 (with drivers)<br>如何在lunux下安装ISE14.7！！升级了win11，发现ise彻底用不了了，然后在网上找相关的博文，基本上是明确了用不了了。只能使用替代方案，然后发现有两个方式linux或者是使用Xilinx提供的方案（个人感觉很蠢）。两种方式都会在后续给出，本文采取的是第一种，在linux下安装。你要是你不想自己安装，也可以直接使用博主提供的虚拟机直接使用。会在文末给出。亲测方法可行，不建议小白自行安装</p></blockquote><p><strong>首先说明，Ubuntu18.04是博主经过很多测试，redhat6.6&#x2F;7.8.Ubuntu20多种环境测试安装后选择的可以实现功能的系统，建议使用该系统版本进行安装！！！折腾了两三天的时间……其中Ubuntu20版本太高，更多问题，redhat6.6等资料太少，而且驱动没有办法安装，换源，挂载本地源都试过了，ISE与modelsim都是可以的，就是没有办法安装驱动……</strong></p><h1 id="Win11下ISE的两种安装方式"><a href="#Win11下ISE的两种安装方式" class="headerlink" title="Win11下ISE的两种安装方式"></a>Win11下ISE的两种安装方式</h1><p>第一是自行搭建一个linux下的环境，第二是使用xilinx的方案。</p><h2 id="搭建一个linux环境下的ISE-Modelsim（含驱动）"><a href="#搭建一个linux环境下的ISE-Modelsim（含驱动）" class="headerlink" title="搭建一个linux环境下的ISE+Modelsim（含驱动）"></a>搭建一个linux环境下的ISE+Modelsim（含驱动）</h2><h3 id="对于ISE的安装"><a href="#对于ISE的安装" class="headerlink" title="对于ISE的安装:"></a>对于ISE的安装:</h3><p>下载安装文件。解压缩: <code>sudo tar -xvf Xilinx_ISE_DS_Lin_14.7_1015_1.tar</code><br>打开终端，进入解压好的文件夹执行: <code>sudo ./xsetup</code><br>注意！！！！不要改变文件夹的安装位置，默认就可以了，否则后续的安装配置将会与教程中的不一致。<br>source环境（就是配置ISE的执行环境）通过修改.bashrc来实现ise环境的配置。<br>添加下面的语句。执行<code>vi ~/.bashrc</code>，添加<code>source /opt/Xilinx/14.7/ISE_DS/settings64.sh</code> 同时重新打开或者<code>source ~/.bashrc</code>使得配置生效。最后打开ISE安装license即可。</p><h3 id="对于驱动的安装"><a href="#对于驱动的安装" class="headerlink" title="对于驱动的安装"></a>对于驱动的安装</h3><p>执行下面的命令 </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /opt/Xilinx/14.7/ISE_DS/ISE/bin/lin64/install_script/install_drivers/./install_drivers</span><br></pre></td></tr></table></figure><p>(This will give error code 1. Don’t worry about it.)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/Xilinx/14.7/ISE_DS/ISE/bin/lin64/digilent/ </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ./install_digilent.sh</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gitk git-gui libusb-dev build-essential libc6-dev-i386 fxload libftdi-dev</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/Xilinx/14.7</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo git <span class="built_in">clone</span> git://git.zerfleddert.de/usb-driver</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> usb-driver</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo make</span><br></pre></td></tr></table></figure><p>(Use make for both 32-bit and 64-bit)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./setup_pcusb /opt/Xilinx/14.7/ISE_DS/ISE/</span><br></pre></td></tr></table></figure><p>最后提一句，自行测试的时候需要重新生成一个bit来进行测试，之前的环境的bit不知道怎么，好像是不能直接用的。<br>参考这里：</p><blockquote><p><a href="https://www.youtube.com/watch?v=meO-b6Ib17Y">https://www.youtube.com/watch?v=meO-b6Ib17Y</a></p></blockquote><h2 id="使用ISE-Design-Suite-for-Windows-10-14-7-进行安装"><a href="#使用ISE-Design-Suite-for-Windows-10-14-7-进行安装" class="headerlink" title="使用ISE Design Suite for Windows 10 - 14.7 进行安装"></a>使用ISE Design Suite for Windows 10 - 14.7 进行安装</h2><p>参考油管视频：<a href="https://www.youtube.com/watch?v=R-JE19thgi8">https://www.youtube.com/watch?v=R-JE19thgi8</a><br>听声音像是一个印度的妹子……咖喱味,hhh</p><h2 id="modelsim-的安装"><a href="#modelsim-的安装" class="headerlink" title="modelsim 的安装"></a>modelsim 的安装</h2><p>参考这里。<br>先看第一个老哥的，安装配置，这里提一句，不使用wine也是可以的，安装一个在你的windows环境下，然后生成一个，然后修改hostname以及ipconfig下对应的地址就可以了。地址进行批量替换，hostname只有一个。<img src="E:\git_prj\blog.img\4352080f77a94a459453015cac20f176.png" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure><p>然后ether后面的就是需要替换的地址，输入hostname就可以查看自己的用户名，替换了就可以了，不需要再自己生成了。<img src="E:\git_prj\blog.img\07d30a6840884dc29e0aacf72d24de51.png" alt="在这里插入图片描述">详细教程见：<br><a href="https://blog.csdn.net/Among12345/article/details/120058209">Ubuntu 16.04 64位 安装 modelsim</a><br><a href="https://blog.csdn.net/wow0237/article/details/54693294?spm=1001.2101.3001.6650.8&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-8-54693294-blog-106865819.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-8-54693294-blog-106865819.pc_relevant_antiscanv2&utm_relevant_index=9">ubuntu16.04 64位下ISE+modelsim的联合安装</a><br>然后关联使用就可以了。后续使用的问题会更新在本文中。</p><h1 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h1><p>所有需要的文件我都放在下面的链接了。<br>包括 </p><ul><li><p>Xilinx_ISE_DS_Lin_14.7_1015_1  Linux下的ISE14.7及其安装教程  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1KYKkWp4l_qn8v7ydW0Iarg?pwd=4kyo </span><br><span class="line">提取码：4kyo </span><br></pre></td></tr></table></figure></li><li><p>moselsim10.2所有组件，win以及linux下的，将其破解文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1FtSNgaWf-8SDPazZwAmlwg?pwd=t5p2 </span><br><span class="line">提取码：t5p2 </span><br></pre></td></tr></table></figure></li><li><p>lic。博主将自己生成的放进去，后续使用只需要进行修改即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1TB8ahm1oMQU98WAyE_PMRQ?pwd=isck </span><br><span class="line">提取码：isck </span><br></pre></td></tr></table></figure></li></ul><p>下面是自己的虚拟机</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/138Ic5v0X3gPxo_Vil82KrA?pwd=hvqa </span><br><span class="line">提取码：hvqa </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文标题：How to install Xilinx ISE Design Suite 14.7 on Ubuntu 18.04 (with drivers)&lt;br&gt;如何在lunux下安装ISE14.7！！升级了win11，发现ise彻底用不了了，</summary>
      
    
    
    
    <category term="数字IC设计" scheme="https://guodongblog.com/categories/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="EDA环境搭建" scheme="https://guodongblog.com/categories/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1/EDA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="数字IC环境配置" scheme="https://guodongblog.com/tags/%E6%95%B0%E5%AD%97IC%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    <category term="ISE14.7" scheme="https://guodongblog.com/tags/ISE14-7/"/>
    
  </entry>
  
  <entry>
    <title>DC系列博客写作背景——闲聊篇</title>
    <link href="https://guodongblog.com/posts/33c374544746/"/>
    <id>https://guodongblog.com/posts/33c374544746/</id>
    <published>2022-05-21T16:44:06.000Z</published>
    <updated>2022-05-22T06:24:01.420Z</updated>
    
    <content type="html"><![CDATA[<p>有一个概括性的大纲，对于初学者的接收信息有一个类似于能力地图一样的东西，可以点亮一个个知识点，同时可以知道自己是在学习什么以及那些还没有学习。同时应该去学那些。<br>很多资料都是DC_SG(Student Guide)，或者其他内容的翻译，对应DC_labs的教程就是不能是单纯的跑脚本，对于本质的讲解以及自己本身进一步的理解需要添加进去。尽可能的对于复制粘贴的东西多一些自己的理解。<br>对应的DC思维导图将会分享出来。<br>同时对应的资料也会进行分享。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有一个概括性的大纲，对于初学者的接收信息有一个类似于能力地图一样的东西，可以点亮一个个知识点，同时可以知道自己是在学习什么以及那些还没有学习。同时应该去学那些。&lt;br&gt;很多资料都是DC_SG(Student Guide)，或者其他内容的翻译，对应DC_labs的教程就是不能</summary>
      
    
    
    
    <category term="DC" scheme="https://guodongblog.com/categories/DC/"/>
    
    
    <category term="DC学习笔记" scheme="https://guodongblog.com/tags/DC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="观点" scheme="https://guodongblog.com/tags/%E8%A7%82%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>DC学习笔记正式篇之零——综述与基本流程介绍</title>
    <link href="https://guodongblog.com/posts/80912d01b675/"/>
    <id>https://guodongblog.com/posts/80912d01b675/</id>
    <published>2022-05-21T08:19:35.000Z</published>
    <updated>2022-08-03T14:31:38.924Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前面介绍了STA部分，综合库的内容结束了基础部分，接下来是DC的使用篇。该部分首先会介绍DC的流程，然后对时序部分进行介绍，接下来是环境属性与较为复杂的时序约束的介绍。期间会有与之对应的dc_labs来帮助进行理解。dc_labs将会同步更新在对应的专栏下。需要结合起来进行学习！<br>本文将会首先回顾DC在IC flow中的位置与作用，然后介绍相关DC的理论，最后是实践部分，该实践部分使用的是lab 1中的内容。</p></blockquote><h1 id="DC-Synthesis-综述部分"><a href="#DC-Synthesis-综述部分" class="headerlink" title="DC Synthesis 综述部分"></a>DC Synthesis 综述部分</h1><p>DC Synthesis是IC设计前端与后端的分界线，或者说是桥梁，将RTL代码转化为门级网表的形式。需要使用SDC约束来体现PAP。更具体的可以参见博主的另一篇博文：数字IC设计流程总结</p><h2 id="DC综合的三个阶段"><a href="#DC综合的三个阶段" class="headerlink" title="DC综合的三个阶段"></a>DC综合的三个阶段</h2><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521211541073.png" alt="综合示意图1"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220522000427038.png" alt="综合示意图2"></p><p>综合是使用软件的方法来设计硬件， 然后将门级电路实现与优化的工作留给综合工具的一种设计方法。 它是根据一个系统逻辑功能与性能的要求， 在一个包含众多结构、 功能、 性能均已知的逻辑元件的单元库的支持下， 寻找出一个逻辑网络结构的最佳实现方案。 即实现在满足设计电路的功能、 速度及面积等限制条件下， 将行为级描述转化为指定的技术库中单元电路的连接。  如图所示，一般综合分为三个阶段，转换，映射与优化。<br>先通过将RTL代码转化为通用的布尔（Boolean）等式，即GTECH（Generic Technology）格式；然后执行compile命令，该命令按照设计的约束对电路进行逻辑综合和优化，使电路能满足设计的目标或约束，并且使用目标工艺库中的逻辑单元映射成门级网表。</p><h2 id="DC的启动方式"><a href="#DC的启动方式" class="headerlink" title="DC的启动方式"></a>DC的启动方式</h2><p>对于 2000.11 版的 Design Compiler， 用户可以通过四种方式启动 Design Compiler，他们是——dc_shell 命令行方式、 dc_shell -t 命令行方式、 design_analyzer 图形方式和<code>design_vision</code>图形方式。 其中后面两种图形方式是分别建立在前面两种命令行方式的基础上的。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521191032327.png" alt="DC的四种启动方式"></p><h3 id="dc-shell-命令行方式"><a href="#dc-shell-命令行方式" class="headerlink" title="dc_shell 命令行方式"></a>dc_shell 命令行方式</h3><p>该方式以文本界面运行 Design Compiler。在 shell 提示符下直接输入”dc_shell”就可以进入这种方式。 也可以在启动 dc_shell 的时候直接调用 dcsh 的脚本来执行(dc_shell –f script)。目前这种方式用的已经不是很普遍。  </p><h3 id="dc-shell-t-命令行方式"><a href="#dc-shell-t-命令行方式" class="headerlink" title="dc_shell-t 命令行方式"></a>dc_shell-t 命令行方式</h3><p>该方式是以 TCL（Tool Command Language 相关专栏已经进行总结） 为基础的，在该脚本语言上扩展了实现 Design Compiler 的命令。用户可以在 shell 提示符下输入”<code>dc_shell-t</code>”来运行该方式。 该方式的运行环境也是文本界面。 也可以在启动 dc_shell -t 的时候直接调用 tcl 的脚本来执行(<code>dc_shell-t – f script</code>)。 TCL 命令行方式是现在推荐使用的命令行方式， 相对 shell 方式功能更强大， 并且在 Synopsys 的其他工具中也得到普遍使用。  注意这里shell与-t之间没有空格。</p><h3 id="design-analyzer-图形界面方式"><a href="#design-analyzer-图形界面方式" class="headerlink" title="design_analyzer 图形界面方式"></a>design_analyzer 图形界面方式</h3><p>Design Analyzer 使用图形界面， 如菜单、 对话框等来实现 Design Compiler 的功能，并提供图形方式的显示电路。 用户可以在 shell 提示符下打“design_analyzer” 来运行该方式。 Design_analyzer 图形方式是今后要经常用到的图形界面方式。 由于它所对应的是dc_shell 的命令行方式， 所以我们不能在 design_analyzer 里运行 tcl 命令。 另外需要注意的是： Design analyzer 的工作模式不是用于编辑电路图的， 它只能用于显示 HDL 语言描述电路的电路图。 </p><h3 id="design-vision-图形界面方式"><a href="#design-vision-图形界面方式" class="headerlink" title="design_vision 图形界面方式"></a>design_vision 图形界面方式</h3><p>Design_vision 是与 tcl 对应的图形方式， 用户可以在 shell 提示符下打”design_vision”来运行该方式。由于它是在 Windows NT 下开发的，在工作站环境下不太普及。</p><h2 id="启动文件"><a href="#启动文件" class="headerlink" title="启动文件"></a>启动文件</h2><p>Synopsys产品很类似，他们都有启动文件<code>.synopsys_dc.setup</code>。其中PT需要单独的启动文件 <code>.synopsys_pt.setup</code>。在后面ICC的学习中，我们也会看到启动文件。这是一个隐藏文件，需要使用<code>ls -a</code>来查看。<br><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521192853282.png" alt=".synopsys_pt.setup"></p><p>启动文件顾名思义， 就是 DC 在启动的时候首先读入的文件， DC 在启动的时候， 会自动在三个目录下搜索该文件（如上图所示），对 DC 的工作环境进行初始化：<br>1，$SYNOPSYS&#x2F;admin&#x2F;setup 目录下， DC 安装的标准初始化文件<br>2，当前用户的$HOME 目录下， 一般用于设置一些用户本人使用的变量以及一些个性化设置。<br>3，DC 启动所在的目录下，一般用于与所在设计相关的设置。<br>其中后面的 setup 文件可以覆盖前面文件中的设置。 该文件主要包括库的设置、 工作路径的设置以及一些常用命令别名的设置等等。<br>由于 dcshell 的启动脚本和 tcl 的脚本语法不一致， 所以如果只有一种方式的启动脚本，那么运行另一种方式的时候会报错。 因此， DC 的启动脚本有一种兼容两种方式的格式。 下面是这种脚本的举例 。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521193348395.png" alt="举例"></p><p>它区别与其他启动脚本的特征是第一行有一个”#”， 说明它是 dc_shell 的一个子集， 同时兼容两种方式。 文件的第一段设置工艺库和链接库， 第二段设置符号库和搜索路径， 第三段设置 DC 命令的别名， 这一点与 Shell 相似。  </p><p>这里不是很理解，大致就是加了#以后，就是可以运行两种模式的脚本了。这里一般保持启动方式与你的脚本语法一致就可以了，一般使用tcl形式启动dc，就是<code>dc_shell-t</code>，语法也是tcl，同我们后面学习的保持一致就可以了。<br>要把DCSH脚本my_script.scr转化为DC-Tcl脚本my_script.tcl，可执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unix% dc-transcript my_scripts.scr my_script.tcl</span><br></pre></td></tr></table></figure><h2 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h2><p>有了启动文件，我们需要在启动文件中定义一些变量。对应DC最少的信息为search_path、target_library、和link_library，下面对一般常用的系统变量进一步的解释。</p><h3 id="search-path-搜索路径"><a href="#search-path-搜索路径" class="headerlink" title="search_path 搜索路径"></a>search_path 搜索路径</h3><p>顾名思义就是用来查找相关需要使用的工艺库呀，设计文件，脚本呀等</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set search_path &quot;./source/rtl ./scripts ./unmapped&quot;</span><br></pre></td></tr></table></figure><h3 id="target-library-目标库-x2F-工艺库"><a href="#target-library-目标库-x2F-工艺库" class="headerlink" title="target_library 目标库&#x2F;工艺库"></a>target_library 目标库&#x2F;工艺库</h3><p>指定工艺库的名称，是综合后电路网表要最终映射到的库， 读入的 HDL 代码首先由 synopsys 自带的 GTECH 库转换成 Design Compiler 内部交换的格式， 然后经过映射到工艺库和优化生成门级网表。 工艺库他是由 Foundary 提供的，一般是.db 的格式。 这种格式是 DC 认识的一种内部文件格式， 不能由文本方式打开。 <code>.db</code> 格式可以由文本格式的<code>.lib</code> 转化过来，他们包含的信息是一致的。  在基础篇中已经进行过介绍，这里不多赘述。命令示例如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set target_library my_tech.db</span><br></pre></td></tr></table></figure><h3 id="link-library-链接库"><a href="#link-library-链接库" class="headerlink" title="link_library 链接库"></a>link_library 链接库</h3><p>link_library 设置模块或者单元电路的引用，对于所有 DC 可能用到的库，我们都需要在link_library 中指定， 其中也包括要用到的 IP。<br>值得注意的一点是： 在 link_library 的设置中必须包含’<em>’, 表示 DC 在引用实例化模块或者单元电路时首先搜索已经调进 DC memory 的模块和单元电路， 如果在 link library中不包含’</em>’，DC 就不会使用 DC memory 中已有的模块， 因此，会出现无法匹配的模块或单元电路的警告信息(unresolved design reference)。<br>图中设置了 link_library， 但是 DC 在 link 的时候却报错， 找不到 TOP 中引用的 DECODE<br>模块， 这说明 link_library 默认是在运行 DC 的目录下寻找相关引用。要使上例的 DECODE<br>能被找到， 需要设置 search_path。  </p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521225806263.png" alt="link_library的使用"></p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set link_library &quot; * my_tech.db&quot;</span><br></pre></td></tr></table></figure><h3 id="synthetic-library-综合库"><a href="#synthetic-library-综合库" class="headerlink" title="synthetic_library 综合库"></a>synthetic_library 综合库</h3><p>在初始化 DC 的时候，不需要设置标准的 DesignWare 库 standard.sldb 用于实现Verilog 描述的运算符，对于扩展的 DesignWare，需要在 synthetic_library 中设置，同时需要在 link_library中设置相应的库以使得在链接的时候 DC 可以搜索到相应运算符的实现。  </p><h3 id="symbol-library-符号库"><a href="#symbol-library-符号库" class="headerlink" title="symbol_library 符号库"></a>symbol_library 符号库</h3><p>symbol_library 是定义了单元电路显示的 Schematic 的库。用户如果想启动design_analyzer 或 design_vision 来查看、 分析电路时需要设置 symbol_library。 符号库的后缀是.sdb，加入没有设置，DC会用默认的符号库取代。 </p><h2 id="设计对象"><a href="#设计对象" class="headerlink" title="设计对象"></a>设计对象</h2><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521232936133.png" alt="设计对象代码示意图"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521231232841.png" alt="设计对象电路示意图"></p><p>设计（Design) :一种能完成一定逻辑功能的电路，可以是独立的，也可以是层次化的设计。（当前设计）<br>单元（Cell）:设计中包含的子设计的实例，也称为instance。<br>参考（Reference) :所指向的设计原型，即单元是参考的实例。<br>端口（Port）:设计的基本输入、输出和双向的输入输出。<br>引脚（Pin）：单元的输入输出和双向的输入输出。<br>线网（Net）：端口和引脚间及引脚和引脚间的连线。<br>时钟（Clock）：作为时钟信号源的引脚或端口。<br>库（Library）：直接与工艺相关的一组单元的集合，是生成门级网表的基本单元或设计中被实例化的单元。</p><p>可以使用相关命令来搜索对象，后续我们将学习对对象进行约束，从而建立时序模型用来做时序仿真。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get_cells \*U*     get_nets *    get_ports CLK     </span><br><span class="line">get_clocks CLK  all_inputs  all_outputs</span><br></pre></td></tr></table></figure><h1 id="基本流程概述"><a href="#基本流程概述" class="headerlink" title="基本流程概述"></a>基本流程概述</h1><blockquote><p>该部分分为理论与实践部分，理论部分根据DC User Guide 的The Synthesis Flow部分进行总结，会有一些自己的理解，实践部分根据dc_labs的lab1内容总结完成。这边介绍的会比较简单，因为是概述性的，有一个大体的印象，后续使用的时候会进一步说明。</p></blockquote><h2 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h2><p>图中列出了流程各步骤常用的基本 DC Expert 和 DC Ultra 命令。图中显示的所有命令都可以接受选项。但图中没有显示任何选项。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220522120511482.png" alt="Synthesis Flow"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220522120637237.png" alt="DC的输入输出"></p><p>以下步骤概述了综合流程：</p><h3 id="1，准备HDL文件"><a href="#1，准备HDL文件" class="headerlink" title="1，准备HDL文件"></a>1，准备HDL文件</h3><p>Design Compiler 的输入设计文件使用诸如 Verilog 或 VHDL 之类的硬件描述语言 (HDL) 编写。</p><h3 id="2，指定库"><a href="#2，指定库" class="headerlink" title="2，指定库"></a>2，指定库</h3><p>指定链接、目标、符号、合成和物理库。可以在启动文件中指定。相关的作用在前文中已有介绍。</p><h3 id="3，读入设计"><a href="#3，读入设计" class="headerlink" title="3，读入设计"></a>3，读入设计</h3><p>Design Compiler 可以读取 RTL 设计和门级网表。Design Compiler 使用 HDL Compiler 读取 Verilog 和 VHDL RTL 设计以及 Verilog 和 VHDL 门级网表。您还可以读取 .ddc 格式的门级网表。这里读入的方式一般有<strong>read</strong>或者是<strong>analyze&amp;elaborate</strong></p><h4 id="read命令"><a href="#read命令" class="headerlink" title="read命令"></a>read命令</h4><p>read命令可以一步完成analyze&amp;elaborate的工作，并且read命令还可以用来读取db、EDIF等格式的设计(analyze+elaborate仅能用于VHDL和verilog)。但是，read命令无法支持参数传递以及VHDL中的构造体选择等功能。语法格式为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read_file [-format format_name] file_list</span><br></pre></td></tr></table></figure><p>•-format：指定设计读入的格式，可以ddc、db、verilog、vhdl、sverilog、edif、equation、pla、st等，对应不同格式命令可以替换为read_db、read_edif、read_verilog、read_vhdl、read_sverilog等。<br>•file_list：源代码文件名列表，文件名的指定可以通过TCL的链表命令{}、“”、[list file_name]等三种方法之一完成。</p><h4 id="analyze-amp-elaborate命令"><a href="#analyze-amp-elaborate命令" class="headerlink" title="analyze&amp;elaborate命令"></a>analyze&amp;elaborate命令</h4><h5 id="analyze"><a href="#analyze" class="headerlink" title="analyze"></a>analyze</h5><p>analyze命令用以分析HDL代码，在为设计建立通用库上的逻辑结构前检查设计的错误，并将中间结果存入指定的库中。语法格式为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">analyze [-library library_name] [-format verilog | vhdl | sverilog] file_list </span><br></pre></td></tr></table></figure><p>•-library：指定中间结果存放的库，即Linux系统下的一个目录，默认为当前目录，也可以用define_design_lib命令指定。<br>•-format：HDL源文件的类型，即verilog或vhdl或sverilog。<br>•file_list：源代码文件名列表，文件名的指定可以通过TCL的链表命令{}、“”、[list file_name]等三种方法之一完成。<br>举例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dc_shell-t&gt;analyze -f verilog [list ctrl_0723.v、datapath_0723.v、ram16s.v、ram16x1s.v、regfile.v、xram16.v、xr16.v、memctrl.v、vga.v、xsoc.v]</span><br></pre></td></tr></table></figure><h5 id="elaborate"><a href="#elaborate" class="headerlink" title="elaborate"></a>elaborate</h5><p>elaborate命令用于建立设计的与工艺无关、即GTECH库上的结构级描述，为后续的优化和映射做好准备，支持参数传递；对设计进行描述，需要对各个设计单独进行。语法格式为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">elaborate design_name [-library library_name] [-parameters param_list]</span><br></pre></td></tr></table></figure><p>•deisgn_name：指需要进行描述的设计。<br>•-library：用于保存设计的结构级描述。<br>•-parameters：指定给设计传递的参数，若省略则参数使用缺省值；参数用“”括起来。</p><h3 id="4，定义设计环境"><a href="#4，定义设计环境" class="headerlink" title="4，定义设计环境"></a>4，定义设计环境</h3><p>Design Compiler 要求您对要综合的设计环境进行建模。该模型包括外部操作条件（制造过程、温度和电压）。负载、驱动器、扇出等。它直接影响设计综合和优化结果。如果您不使用地形模式，则需要指定电线负载模型来估计电线长度对设计性能的影响。<br><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220522123423902.png" alt="设计环境"></p><h3 id="5，设置设计约束"><a href="#5，设置设计约束" class="headerlink" title="5，设置设计约束"></a>5，设置设计约束</h3><p>注意：设计约束设置受您选择的编译策略的影响。流程步骤 5 和 6 是相互依赖的。编译策略在步骤 6 中讨论。<br>设计约束描述了设计目标，它们可包括时序或面积约束。依据设计是如何约束的，DC试图满足目标集。因为不实际的规范会导致面积增大、功耗增加和&#x2F;或时序恶化，所以设计人员必须指定实际的约束。约束设计的基本命令如图所示。<br><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220522134531453.png" alt="综合的设计约束"></p><h3 id="6，选择编译策略"><a href="#6，选择编译策略" class="headerlink" title="6，选择编译策略"></a>6，选择编译策略</h3><p>您可以使用自上而下或自下而上的策略。这两种策略都有优点和缺点，具体取决于您的特定设计和设计目标。</p><h3 id="7，编译"><a href="#7，编译" class="headerlink" title="7，编译"></a>7，编译</h3><p>用 Compile 命令执行综合与优化过程，还可以利用一些选项指导编译和优化过程。<code>compile_ultra or compile</code></p><h3 id="8，分析报告"><a href="#8，分析报告" class="headerlink" title="8，分析报告"></a>8，分析报告</h3><p>报告可以帮助我们进行迭代，分析，后续关于报告的使用也会跟进一步的介绍。</p><h3 id="9，写入相关文件，保存设计"><a href="#9，写入相关文件，保存设计" class="headerlink" title="9，写入相关文件，保存设计"></a>9，写入相关文件，保存设计</h3><p>使用 write_file 命令保存综合设计。 Design Compiler 在退出前不会自动保存设计。您可以用 .ddc、Milkyway 或 Verilog 格式写出设计。</p><h2 id="实践部分"><a href="#实践部分" class="headerlink" title="实践部分"></a>实践部分</h2><p>该部分参见dc_labs的<a href="https://guodongblog.com/posts/152222de7076/">lab1</a></p><h1 id="补充部分"><a href="#补充部分" class="headerlink" title="补充部分"></a>补充部分</h1><blockquote><p>该部分介绍了一些不需要知道但是不会特别影响你做综合的一些点，作为补充知识，进一步帮助理解。</p></blockquote><h2 id="什么是SDC"><a href="#什么是SDC" class="headerlink" title="什么是SDC"></a>什么是SDC</h2><p>术语“Synopsys公司设计约束”（又名SDC，Synopsys Design Constraints）用于描述对时序、功率和面积的设计要求，是EDA工具中用于综合、静态时序分析和布局布线最常用的格式。<br>DC命令基于Tcl语言。“工具命令语言”（又称Tcl，Tool Command Language）是一种非常流行的脚本语言，是常用于开发用户接口和嵌入式系统平台的应用程序。通过使SDC扩展到Tcl，特定于工具的命令可以与原生的Tcl结构，如变量、表达式、语句和子程序相混合，使其成为实现工具非常强大的语言。</p><h2 id="DC的拓扑模式与普通模式的区别"><a href="#DC的拓扑模式与普通模式的区别" class="headerlink" title="DC的拓扑模式与普通模式的区别"></a>DC的拓扑模式与普通模式的区别</h2><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220522003049548.png" alt="高级芯片综合流程"></p><p>真正的综合现在一般都是使用的是Ultra来进行的，一般是先使用compile来预编译，然后使用design_vision -topo模式来进行Compile_ultra的。这里我们可以看到哈，其加入了真正的RC，线延时等等一些真实的内容。所以可以简单的理解，一般我们实验或是学习，普通的dc_shell-t的compile，更高级，或是说更接近实际情况的其实是拓扑模式下的Compile_ultra。</p><h2 id="Optimization是在做什么"><a href="#Optimization是在做什么" class="headerlink" title="Optimization是在做什么"></a>Optimization是在做什么</h2><p>参考DC_SG_11，点击这里 FLAG！！会单独开一篇</p><h2 id="为什么做设计需要会STA-amp-DC综合"><a href="#为什么做设计需要会STA-amp-DC综合" class="headerlink" title="为什么做设计需要会STA&amp;DC综合"></a>为什么做设计需要会STA&amp;DC综合</h2><p>我们知道，你做设计最好是需要理解DC，STA的，一个设计的水平就取决于你对STA的理解。不可否认，功能是首先应该去考虑的问题，随着工具的逐渐强大，越来越多的设计问题可以通过工具来进行避免，但是这依旧不是一个设计人员不应该不懂得STA的理由。如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220522001725225.png" alt="DC student guide 4-3"></p><p>你需要给你的DC一个好的起点，记得看过一句话，大义是说，好的代码综合出来是好的电路，垃圾代码综合处理是垃圾电路！！我们需要注意下面的几点</p><ul><li>功能相同但编码不同的代码将给出不同的综合结果</li><li>不能仅依靠 Design Compiler 来“修复”编码不佳的设计！</li><li>尝试了解您所描述的“硬件”，为 DC 提供最佳起点</li></ul><p>该部分后续可能会开一个类似的系列！！留下一个坑：<strong>Verilog编码的艺术~</strong> FLAG！！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;前面介绍了STA部分，综合库的内容结束了基础部分，接下来是DC的使用篇。该部分首先会介绍DC的流程，然后对时序部分进行介绍，接下来是环境属性与较为复杂的时序约束的介绍。期间会有与之对应的dc_labs来帮助进行理解。dc_labs将会同步更新在对应</summary>
      
    
    
    
    <category term="DC" scheme="https://guodongblog.com/categories/DC/"/>
    
    <category term="DC学习笔记" scheme="https://guodongblog.com/categories/DC/DC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="DC学习笔记" scheme="https://guodongblog.com/tags/DC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>DC学习笔记正式篇之一——对时钟的约束建模</title>
    <link href="https://guodongblog.com/posts/e717ab93a361/"/>
    <id>https://guodongblog.com/posts/e717ab93a361/</id>
    <published>2022-05-21T08:19:35.000Z</published>
    <updated>2022-08-11T13:15:30.912Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>经过前面的学习，已经知道了STA是在查什么，也对DC有了一定的了解，该部分对时钟的建模进行总结，对应的实践篇也在本文后给出。<br>我们需要分析时序路径，最基本的需要一个时钟，只要有了时钟，就可以解决寄存器到寄存器（Register to Register）的时序问题，换而言之，即计算建立时间保持时间，来验证是否符合预期，这将是占比很大的一部分时序路径。本节将主要介绍时钟的建模方式。</p></blockquote><h1 id="时钟的约束与建模"><a href="#时钟的约束与建模" class="headerlink" title="时钟的约束与建模"></a>时钟的约束与建模</h1><p>首先对时钟相关的基本知识进行介绍，然后在对DC中对时钟的处理进行总计学习。需要知道<a href="https://blog.csdn.net/qq_41467882/article/details/126154769?spm=1001.2014.3001.5501">时钟的同步与异步</a>与亚稳态的概念。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;经过前面的学习，已经知道了STA是在查什么，也对DC有了一定的了解，该部分对时钟的建模进行总结，对应的实践篇也在本文后给出。&lt;br&gt;我们需要分析时序路径，最基本的需要一个时钟，只要有了时钟，就可以解决寄存器到寄存器（Register to Regi</summary>
      
    
    
    
    <category term="DC" scheme="https://guodongblog.com/categories/DC/"/>
    
    <category term="DC学习笔记" scheme="https://guodongblog.com/categories/DC/DC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="DC学习笔记" scheme="https://guodongblog.com/tags/DC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>个人博客搭建——环境部署最终解决方案</title>
    <link href="https://guodongblog.com/posts/f4fcb8b173dc/"/>
    <id>https://guodongblog.com/posts/f4fcb8b173dc/</id>
    <published>2022-05-18T03:09:22.000Z</published>
    <updated>2022-05-21T07:32:58.961Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>个人博客的搭建首先需要知道自己为什么需要搭建，才能选择一个合适的平台。笔者本身并不是做软件前端设计，基本上是没有基础的，搭建博客的目的就是为了给自己一个小小的慰藉，有一个自己的小平台，可以记录自己的留下来的痕迹，因为比较喜欢念旧啦~也是喜欢，并不要很多人来看，做一件事情开心最重要啦 ，只要自己开心，有没有关注其实也并不是那么重要的了，不是吗？有了自己的选择，就可以开始进一步的环境搭建。至于网站的内容，可以选择自己熟悉的内容，可以是你自己领域内的专业笔记，也可以是自己小小的心得体会，不想对别人说的话。<br>最后笔者也是小白，本文的角度同样如此。</p></blockquote><hr><h1 id="搭建博客平台"><a href="#搭建博客平台" class="headerlink" title="搭建博客平台"></a>搭建博客平台</h1><p>github-page&#x2F;gitee-page–&gt;github-page+vercel–&gt;云服务器</p><p>开始的平台选择的是Github Page，后来知道了Gitee 也有类的的Gitee page，但是访问速度都没有一个很好的提高，于是尝试使用<a href="https://vercel.com/">vercel</a>来进行加速。同样类似的平台还有<a href="https://app.netlify.com/">netlify</a>。建议购买一个域名，可以先买一个便宜的，自己决定要使用在购买贵的或者时间长的。后来为了提高访问速度，买了一个自己的云服务器，很便宜的，一年几十块钱。进行了域名备案。<br>这里需要安装git与基本的使用。然后是安装nvs。nvs是用来安装配置node的。可以很方便的进行node的版本管理。强烈建议使用nvs来进行nodejs的安装。</p><h2 id="主题的选择"><a href="#主题的选择" class="headerlink" title="主题的选择"></a>主题的选择</h2><p>想搭建一个人博客，开始接触的可能是部署在GitHub上。笔者自己使用的是Hexo框架，使用的主题开始是ayer，后来使用的是butterfly，建议使用比较多的主题，好处是有对应的群，而且相对应的参考方案比较多。选的方式是看⭐标数目。后续根据自己需要进行修改的时候更加方便。</p><div class="note warning simple"><p>注意千万选择使用的人比较多的主题，完全不用担心你的博客最后会没有特点！！！博客最开始只是提供的一个框架而已</p></div><h2 id="图床的选择"><a href="#图床的选择" class="headerlink" title="图床的选择"></a>图床的选择</h2><p>图床开始的时候选择的是GitHub+PicGo+jsd。然后jsd挂了……但是要是可以科学上网的话是可以访问的，我可以随时挂代理，所以可以对于GitHub Page继续使用该方案。<br>准备使腾讯cos做一个备份。应该不是很贵吧，个人使用后续价钱用起来再看。同时可以使用Typora将数据同步很好的进行。如下图所示</p><p><img src="https://blog-1305888790.cos.ap-nanjing.myqcloud.com/image-20220520112535331.png" alt="typora图像设计部分"><br>将图片上传到腾讯cos存储列表的同时将数据放到本地的指定路径,该路径就是GitHub图床的路径，然后本地push,后续使用的时候只需要将路径进行全部替换,就可以将使用cos的图片换到使用jsd加速的图片,然后再服务器以及GitHub上分别进行部署.同时图片也会再本地进行保留,数据的安全有了更好的保证.就算所有图床都无法使用,本地的图片也还是在的.</p><h1 id="最终解决方案（必看，超级好用）"><a href="#最终解决方案（必看，超级好用）" class="headerlink" title="最终解决方案（必看，超级好用）"></a>最终解决方案（必看，超级好用）</h1><p>这里简单总结下 准备部署如下</p><table><thead><tr><th>部署平台</th><th>对应图床</th><th>其他</th></tr></thead><tbody><tr><td>GitHub</td><td>jsd+GitHub</td><td>PicGo+Typora+vercel</td></tr><tr><td>Gitee</td><td>jsd+GitHub</td><td>PicGo+Typora</td></tr><tr><td>云服务器</td><td>tent-cos-&gt;使用CSDN的图床</td><td>PicGo+Typora</td></tr><tr><td>CSDN(独立)</td><td>独立</td><td>独立</td></tr></tbody></table><p>域名解析国内走腾讯，国外走GitHub+vercel.</p><p>优缺点:</p><ul><li>优点是数据，国内使用速度快，要是挂代理不会使用国内的cos数据，省钱。</li><li>缺点是写作同步相对来说比较麻烦，<del>CSDN的部署需要进行单独的图片编辑</del>我后来发现很简单，因为CSDN会将腾讯cos的数据抓取放到自己的服务器上，也就是说，你在typora的腾讯cos链接，放到CSDN上就自动变成了CSDN的内部图像链接了，因此很是方便的同步一些你想要再CSDN与云服务器上发布的博文。然后云服务器以及GitHub需要进行一个批量交换，这里就相对来说很简单了，批量替换就好，同时也可以选择将服务器的文章换成CSDN的图片，超级easy，只需要简单的复制粘贴即可！！！！！所以我选择将GitHub作为主战场，选择性的同步数据到CSDN与云服务器，当然比较私密的内容更多的还是放在GitHub上，同时后续的修改以及更新更多的也是再GitHub-page上进行更新。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;个人博客的搭建首先需要知道自己为什么需要搭建，才能选择一个合适的平台。笔者本身并不是做软件前端设计，基本上是没有基础的，搭建博客的目的就是为了给自己一个小小的慰藉，有一个自己的小平台，可以记录自己的留下来的痕迹，因为比较喜欢念旧啦~也是喜欢，并不要</summary>
      
    
    
    
    <category term="个人博客搭建" scheme="https://guodongblog.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="Hexo" scheme="https://guodongblog.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo博文写作-文章写作模板与相关配置</title>
    <link href="https://guodongblog.com/posts/26f19a18323e/"/>
    <id>https://guodongblog.com/posts/26f19a18323e/</id>
    <published>2022-05-16T11:27:21.000Z</published>
    <updated>2022-05-18T16:16:21.103Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该文章配合<a href="https://www.guodongblog.site/posts/7ddf536be75c/">hexo博文写作——Typora的使用</a>进一步完善博文写作的准备部分。</p></blockquote><h1 id="写作的基本操作"><a href="#写作的基本操作" class="headerlink" title="写作的基本操作"></a>写作的基本操作</h1><h2 id="模板自定义"><a href="#模板自定义" class="headerlink" title="模板自定义"></a>模板自定义</h2><p>在新建文章时，Hexo 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件。打开<code>scaffolds</code>目录下，修改<code>post.md</code>的内容。如下是博主设置的文章模板，以后新建文章如下模板会自动添加在文章头。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">cover: </span><br><span class="line">password:</span><br><span class="line">description:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">top_img: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h2><p>他是Hexo的一种特殊布局：<code>draft</code>，这种布局在建立时会被保存到 <code>source/_drafts</code> 文件夹，您可通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹，该命令的使用方式与 <code>new</code> 十分类似，您也可在命令中指定 <code>layout</code> 来指定布局。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>草稿默认不会显示在页面中，您可在执行时加上 <code>--draft</code> 参数，或是把 <code>render_drafts</code> 参数设为 <code>true</code> 来预览草稿。</p><h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>您可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。<code>Hexo</code> 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>。</p><table><thead><tr><th align="left">布局</th><th align="left">路径</th></tr></thead><tbody><tr><td align="left"><code>post</code></td><td align="left"><code>source/_posts</code></td></tr><tr><td align="left"><code>page</code></td><td align="left"><code>source</code></td></tr><tr><td align="left"><code>draft</code></td><td align="left"><code>source/_drafts</code></td></tr></tbody></table><h1 id="相关模板"><a href="#相关模板" class="headerlink" title="相关模板"></a>相关模板</h1><h2 id="引用标注"><a href="#引用标注" class="headerlink" title="引用标注"></a>引用标注</h2><blockquote><p>simple</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note simple %&#125;</span><br><span class="line">默認 提示塊標籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;</span><br><span class="line">default 提示塊標籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;</span><br><span class="line">primary 提示塊標籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;</span><br><span class="line">success 提示塊標籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;</span><br><span class="line">info 提示塊標籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;</span><br><span class="line">warning 提示塊標籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;</span><br><span class="line">danger 提示塊標籤</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note simple"><p>默認 提示塊標籤</p></div><div class="note default simple"><p>default 提示塊標籤</p></div><div class="note primary simple"><p>primary 提示塊標籤</p></div><div class="note success simple"><p>success 提示塊標籤</p></div><div class="note info simple"><p>info 提示塊標籤</p></div><div class="note warning simple"><p>warning 提示塊標籤</p></div><div class="note danger simple"><p>danger 提示塊標籤</p></div><blockquote><p>modern</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note modern %&#125;</span><br><span class="line">默認 提示塊標籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;</span><br><span class="line">default 提示塊標籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;</span><br><span class="line">primary 提示塊標籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;</span><br><span class="line">success 提示塊標籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;</span><br><span class="line">info 提示塊標籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;</span><br><span class="line">warning 提示塊標籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;</span><br><span class="line">danger 提示塊標籤</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note modern"><p>默認 提示塊標籤</p></div><div class="note default modern"><p>default 提示塊標籤</p></div><div class="note primary modern"><p>primary 提示塊標籤</p></div><div class="note success modern"><p>success 提示塊標籤</p></div><div class="note info modern"><p>info 提示塊標籤</p></div><div class="note warning modern"><p>warning 提示塊標籤</p></div><div class="note danger modern"><p>danger 提示塊標籤</p></div><h2 id="mermaid"><a href="#mermaid" class="headerlink" title="mermaid"></a>mermaid</h2><p>使用mermaid标签可以绘制Flowchart（流程图）、Sequence diagram（时序图 ）、Class Diagram（类别图）、State Diagram（状态图）、Gantt（甘特图）和Pie Chart（圆形图），具体可以查看<a href="https://mermaid-js.github.io/mermaid/#/">mermaid文档</a>。</p><p>修改 <code>主題配置文件</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mermaid</span></span><br><span class="line"><span class="comment"># see https://github.com/mermaid-js/mermaid</span></span><br><span class="line"><span class="attr">mermaid:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># built-in themes: default/forest/dark/neutral</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">dark</span></span><br></pre></td></tr></table></figure><p>写法：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">內容</span><br><span class="line">&#123;% endmermaid %&#125;</span><br></pre></td></tr></table></figure><p>举例：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  pie    title Key elements in Product X    &quot;Calcium&quot; : 42.96    &quot;Potassium&quot; : 50.05    &quot;Magnesium&quot; : 10.01    &quot;Iron&quot; :  5  </pre></div><h2 id="Tabs"><a href="#Tabs" class="headerlink" title="Tabs"></a>Tabs</h2><blockquote><p>Demo 1 - 预设选择第一个【默认】</p></blockquote><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**<span class="emphasis">*\*</span>This is Tab 1.\**</span><span class="strong">**</span></span><br><span class="line"><span class="strong">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">&lt;!-- tab --&gt;</span></span><br><span class="line"><span class="strong">**</span><span class="emphasis">*\*</span>This is Tab 2.\<span class="strong">****</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**<span class="emphasis">*\*</span>This is Tab 3.\**</span><span class="strong">**</span></span><br><span class="line"><span class="strong">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="strong">&#123;% endtabs %&#125;</span></span><br></pre></td></tr></table></figure><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><em><strong>*This is Tab 1.*</strong></em></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><em><strong>*This is Tab 2.*</strong></em></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><em><strong>*This is Tab 3.*</strong></em></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>Demo 2 - 预设选择tabs</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 1.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 2.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>Demo 3 - 没有预设值</p></blockquote><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test3-1">test3 1</button></li><li class="tab"><button type="button" data-href="#test3-2">test3 2</button></li><li class="tab"><button type="button" data-href="#test3-3">test3 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p></blockquote><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一個Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字為第一個Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有圖標 沒有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸彈@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一個Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸彈</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字為第一個Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有圖標 沒有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="Button按钮"><a href="#Button按钮" class="headerlink" title="Button按钮"></a>Button按钮</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is my website, click the button &#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly %&#125;</span><br><span class="line">This is my website, click the button &#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right %&#125;</span><br><span class="line">This is my website, click the button &#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,,outline %&#125;</span><br><span class="line">This is my website, click the button &#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,outline %&#125;</span><br><span class="line">This is my website, click the button &#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,larger %&#125;</span><br></pre></td></tr></table></figure><p>This is my website, click the button <a class="btn-beautify " href="https://butterfly.js.org/"   title="Butterfly"><span>Butterfly</span></a><br>This is my website, click the button <a class="btn-beautify " href="https://butterfly.js.org/"   title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><br>This is my website, click the button <a class="btn-beautify outline" href="https://butterfly.js.org/"   title="Butterfly"><span>Butterfly</span></a><br>This is my website, click the button <a class="btn-beautify outline" href="https://butterfly.js.org/"   title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><br>This is my website, click the button <a class="btn-beautify larger" href="https://butterfly.js.org/"   title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,blue larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,pink larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,red larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,purple larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,orange larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,green larger %&#125;</span><br></pre></td></tr></table></figure><a class="btn-beautify larger" href="https://butterfly.js.org/"   title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify blue larger" href="https://butterfly.js.org/"   title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify pink larger" href="https://butterfly.js.org/"   title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify red larger" href="https://butterfly.js.org/"   title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify purple larger" href="https://butterfly.js.org/"   title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify orange larger" href="https://butterfly.js.org/"   title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify green larger" href="https://butterfly.js.org/"   title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><h2 id="高亮重点"><a href="#高亮重点" class="headerlink" title="高亮重点"></a>高亮重点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">臣亮言：&#123;% label 先帝 %&#125;创业未半，而&#123;% label 中道崩殂 blue %&#125;。今天下三分，&#123;% label 益州疲敝 pink %&#125;，此诚&#123;% label 危急存亡之秋 red %&#125;也！然侍衞之臣，不懈于内；&#123;% label 忠志之士 purple %&#125;，忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气；不宜妄自菲薄，引喻失义，以塞忠谏之路也。</span><br><span class="line">宫中、府中，俱为一体；陟罚臧否，不宜异同。若有&#123;% label 作奸 orange %&#125;、&#123;% label 犯科 green %&#125;，及为忠善者，宜付有司，论其刑赏，以昭陛下平明之治；不宜偏私，使内外异法也。</span><br></pre></td></tr></table></figure><p>臣亮言：<mark class="hl-label default">先帝</mark> 创业未半，而<mark class="hl-label blue">中道崩殂</mark> 。今天下三分，<mark class="hl-label pink">益州疲敝</mark> ，此诚<mark class="hl-label red">危急存亡之秋</mark> 也！然侍衞之臣，不懈于内；<mark class="hl-label purple">忠志之士</mark> ，忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气；不宜妄自菲薄，引喻失义，以塞忠谏之路也。<br>宫中、府中，俱为一体；陟罚臧否，不宜异同。若有<mark class="hl-label orange">作奸</mark> 、<mark class="hl-label green">犯科</mark> ，及为忠善者，宜付有司，论其刑赏，以昭陛下平明之治；不宜偏私，使内外异法也。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;该文章配合&lt;a href=&quot;https://www.guodongblog.site/posts/7ddf536be75c/&quot;&gt;hexo博文写作——Typora的使用&lt;/a&gt;进一步完善博文写作的准备部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1</summary>
      
    
    
    
    <category term="个人博客搭建" scheme="https://guodongblog.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="博文写作" scheme="https://guodongblog.com/tags/%E5%8D%9A%E6%96%87%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>基础知识之二——STA相关的基本定义</title>
    <link href="https://guodongblog.com/posts/4b760c56b458/"/>
    <id>https://guodongblog.com/posts/4b760c56b458/</id>
    <published>2022-05-16T11:20:15.000Z</published>
    <updated>2022-05-21T14:42:36.510Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在前一部分介绍了什么是STA，STA在数字IC设计流程中的位置，优点。该博文继续介绍STA，先通过一个简单的例子来引入，然后介绍一些STA的有关定义。我们的目的是为了建立一个模型，将我们的Verilog HDL语言综合的Schematic原理图转换为数学模型，这样就能使用计算机来进行分析时序。从而可以保证时序收敛。</p></blockquote><h1 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h1><p>先看下面一个例子，先做一个简单的介绍，有没有接触过的定义会在后面进行介绍，主要是通过引例使得后面的定义更好理解。可以暂时不需要理解，但是看完本后可以通过这个引例来进一步进行学习。下面的几个图可以理解是时序分析的核心了，理解他们可以帮助理解很多问题</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521115207112.png" alt="电路原理图"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521131449998.png" alt="建立时间分析时序图"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521130359813.png" alt="标注"></p><p>T<del>1</del>：为基准时钟与时钟到达一级寄存器的偏斜时间<br>T<del>2</del>：为基准时钟与时钟到达二级寄存器的偏斜时间<br>T<del>co</del>：数据在寄存器中传输的延时</p><p>T<del>su</del>：建立时间，寄存器的时钟信号有效沿到来之前数据必须稳定的最小时间</p><p>T<del>hold</del>：保持时间，寄存器的时钟信号有效沿到来之后数据必须稳定的最小时间</p><p>T<del>data</del>：数据经过一级寄存器（或经过组合逻辑），进入二级寄存器输入端的延时时间<br>CLK1：基准时钟经过延时后达到一级寄存器的时钟<br>CLK2：基准时钟经过延时后达到二级寄存器的时钟<br>数据到达时间（Data arrival time）：数据从D发送寄存器的D到接收寄存器的D端的时间 T<del>1</del>+ T<del>co</del>+ T<del>data</del><br>要求数据到达时间（Data Require time）：根据两级寄存器的是时钟偏移，加上数据的建立时间，计算要求数据到达的时间（T-T<del>su</del>）+T<del>cycle</del>。这里的数据到达时间计算以及数据到达时间的计算都是从基准时钟的发射沿开始计算的。</p><p>上边的是建立时间的例子，下面的图用来展示保持时间的例子。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521130426918.png" alt="保持时间时序图"></p><p>对于情况1，由于数据到达时间太短了，数据还没有取到，而下一个数据已经来了，因此就会使得错过这个数据。<br>情况2是正常的保持时间的情况。</p><h1 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h1><h2 id="时序路径（timing-path）"><a href="#时序路径（timing-path）" class="headerlink" title="时序路径（timing path）"></a>时序路径（timing path）</h2><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521140701238.png" alt="时序路径"></p><p>1：从输入端口到FF的D端；Input To Register<br>2：从FF1的CLK端到FF2的D端；Register To Register<br>3：从FF2的CLK端到输出端口；Register To Output<br>4：从输入端口到输出端口。Input To Output，一般设计中这种情况是尽量避免的，具体原因在后续的学习中将会进行解释。</p><h2 id="传播延时-propagation"><a href="#传播延时-propagation" class="headerlink" title="传播延时 propagation"></a>传播延时 propagation</h2><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521143538102.png" alt="传播延时的定义图示部分"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521143558499.png" alt="传播延时的定义"></p><p>本质上传播延时是一个人为定义的逻辑门质量指标，没有实际的物理意义。</p><p>举例如下：</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521143641430.png"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521143710286.png"></p><h2 id="转换时间-transition"><a href="#转换时间-transition" class="headerlink" title="转换时间 transition"></a>转换时间 transition</h2><p>转换时间是指信号在两个特定电平之间转换所需要的时间。与之有关的是下降沿阈值与上升沿阈值的设置。如下所示。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521144123271.png"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521144129181.png"></p><h2 id="时序弧"><a href="#时序弧" class="headerlink" title="时序弧"></a>时序弧</h2><p>时序弧是静态时序分析的基础，静态时序分析是基于时序弧数据的时序分析。时序弧是用来描述两个节点之间的时序信息来定义的，一般分为连线延时与单元延时。<br><strong>连线延时</strong>是单元输出端口和扇出网络负载之间的延时信息。1，理想导线2，集总模型3，集总RC模型4，分布式RC模型5，传输线模型等一些模型是用来计算RC的值的。至于为什么计算，参考补充定义的CMOS逻辑设计补充知识点部分，后续的博文还有有对其的解释与使用方式。<br><strong>单元延时</strong>是单元输入到输出端口之间的延时。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521143439843.png" alt="单元延时计算方式"></p><p>逻辑通过逻辑路径传播的总延迟称为路径延迟（path delay），包括了逻辑路径中经过各个逻辑单元（cell）和网络走线（net）的延迟。</p><h3 id="组合时序弧"><a href="#组合时序弧" class="headerlink" title="组合时序弧"></a>组合时序弧</h3><p>组合时序弧是最基本的单元延时信息时序弧，主要用于表示组合逻辑单元的延时信息在时序信息文件中通过时序弧类型信息Combinational进行声明，如下所示。<code>timing_type : combinational;</code><br>由于组合时序弧也是默认的时序弧类型，因此没有特别声明的时序弧就默认为组合时序弧。组合时序弧根据单元功能逻辑的不同，分为基于3种不同逻辑状态下的延时弧。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521145113543.png" alt="3种不同逻辑状态下的延时弧"></p><h4 id="同向时序弧"><a href="#同向时序弧" class="headerlink" title="同向时序弧"></a>同向时序弧</h4><p>同向时序弧表示输入端信号变化方向与输出端信号变化方向一致的时序弧</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521145155672.png"></p><h4 id="反向时序弧"><a href="#反向时序弧" class="headerlink" title="反向时序弧"></a>反向时序弧</h4><p>反向时序弧表示输人端信号变化方向与输出端信号变化方向相反的时序弧</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521145201216.png"></p><h4 id="不定态时序弧"><a href="#不定态时序弧" class="headerlink" title="不定态时序弧"></a>不定态时序弧</h4><p>不定态时序弧表示输入信号变化方向与输出端信号变化方向无固定确定关系的时序弧<br><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521145208510.png"></p><h3 id="边沿时序弧"><a href="#边沿时序弧" class="headerlink" title="边沿时序弧"></a>边沿时序弧</h3><p>边沿时序弧用来表示时序单元从时钟信号有效沿到输出信号有效的延时信息。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521145258615.png"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521145305257.png"></p><h3 id="复位清零时序弧"><a href="#复位清零时序弧" class="headerlink" title="复位清零时序弧"></a>复位清零时序弧</h3><p>复位清零时序弧用来表示具有复位清零端口的时序单元从复位清零信号有效沿到输出信号有效的延时信息。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521145336549.png"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521145342784.png"></p><h3 id="三态使能时序弧"><a href="#三态使能时序弧" class="headerlink" title="三态使能时序弧"></a>三态使能时序弧</h3><p>三态使能时序弧用来表示三态逻辑单元从使能信号有效到输出的延时信息</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521145400093.png"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521145405864.png"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521145411939.png"></p><h3 id="建立时序弧"><a href="#建立时序弧" class="headerlink" title="建立时序弧"></a>建立时序弧</h3><p>建立时序弧用来表示时序单元获得正确数据信号所需要的约束信息，即在时钟沿有效前数据输入信号保持有效的时间信息。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521145435229.png"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521145442309.png"></p><h3 id="保持时序弧"><a href="#保持时序弧" class="headerlink" title="保持时序弧"></a>保持时序弧</h3><p>保持时序弧也是用来表示时序单元获得正确信号所需要的约束信息，即在时钟沿有效后数据输入信号继续维持有效的时间信息。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521145502221.png"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521145507269.png"></p><h3 id="恢复时序弧"><a href="#恢复时序弧" class="headerlink" title="恢复时序弧"></a>恢复时序弧</h3><p>类似于复位的建立时间。恢复时序弧用来表示具有复位清零端口的时序单元成功使能所需要的约束信息，即在时钟沿有效前使能信号保持有效的时间信息。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521145617165.png"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521145634116.png"></p><h3 id="移除时序弧"><a href="#移除时序弧" class="headerlink" title="移除时序弧"></a>移除时序弧</h3><p>移除时序弧也是用来表示具有复位清零端口的时序单元成功使能所需要的约束信息，即在时钟沿有效后使能信号维持有效的时间信息。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521145652748.png"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521145658109.png"></p><h3 id="脉宽时序弧"><a href="#脉宽时序弧" class="headerlink" title="脉宽时序弧"></a>脉宽时序弧</h3><p>脉宽时序弧也是用来表示时序单元获得正确信号所需要的约束信息，即时钟信号同一状态下维持有效的最小总时间信息。时钟信号脉冲过窄会导致时序单元本身无法工作，或是在组合逻辑路径传输中慢慢削弱而失真。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521145720309.png"></p><p>通过使用<code>SDC</code>命令<code>set min pulse width</code>来定义时钟信号的最小脉宽<code>（minimum pulse width）</code>，示例命令如下：<br><code>set_min_pulse_width-high 1.5[all_clocks]</code><br><code>set_min_pulse_width-low 1.0[all_clocks]</code><br>以上命令定义所有时钟高电平最小脉宽为1.5s，低电平最小脉宽为1ns。</p><p>在后续的逻辑单元库的内容可以与之相互补充，这里再解释定义的同时其实对逻辑单元库进行了一部分的解释。</p><h2 id="时钟有关的定义"><a href="#时钟有关的定义" class="headerlink" title="时钟有关的定义"></a>时钟有关的定义</h2><h3 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h3><p>时钟周期也称为振荡周期，定义为时钟频率的倒数。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521140845462.png" alt="时钟周期"></p><h3 id="时钟占空比"><a href="#时钟占空比" class="headerlink" title="时钟占空比"></a>时钟占空比</h3><p>时钟占空比是指时钟信号高电平在一个周期之内所占的时间比率，一般设计中，大部分的时钟占空比为50%，即占空比为0.5，说明高、低电平所占时间都为0.5个周期。但根据设计需要，也可以设计占空比不同的时钟信号。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521140618889.png" alt="占空比"></p><h3 id="时钟抖动"><a href="#时钟抖动" class="headerlink" title="时钟抖动"></a>时钟抖动</h3><p>指两个时钟周期之间存在的差值，这个误差是在时钟发生器内部产生。可能是PLL等固有原因引起的。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521141015073.png" alt="jitter"></p><h3 id="时钟偏移"><a href="#时钟偏移" class="headerlink" title="时钟偏移"></a>时钟偏移</h3><p>时钟偏斜（clock skew）是集成电路中一个时钟翻转的到达时间在空间上的差别（到达不同时钟树终点的时间差）。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521141255647.png" alt="clock shew"></p><p>可以使用set_clock_uncertainty命令显式指定时钟不确定度的值。在实现时钟树前，set_clock_uncertainty命令指定的值将包括时钟抖动、时钟偏斜估计值以及额外悲观度。看一个例子。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set_clock_uncertainty 0.2 [get_clocks USBCLK]</span><br></pre></td></tr></table></figure><p>上面这条命令中200ps的时钟不确定度可能是由50ps时钟抖动、100ps时钟偏斜以及50ps的额外悲观度组成的。</p><h3 id="时钟延时"><a href="#时钟延时" class="headerlink" title="时钟延时"></a>时钟延时</h3><p>时钟延迟（clock latency）是指从时钟源到终点所花费的总时间。在逻辑设计的早期阶段，STA通常使用理想的时钟树来执行，因此分析的重点是数据路径（data path）</p><h2 id="PVT环境"><a href="#PVT环境" class="headerlink" title="PVT环境"></a>PVT环境</h2><p>静态时序分析通常是在特定的工作条件（operating condition）下执行的，工作条件定义为工艺（process）、电压（voltage）和温度（temperature）的组合，简称PVT。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521144404283.png" alt="PVT环境"></p><p>其中电压越高越好，温度越低越好，工艺偏差越小越好<br>半导体代工厂（foundry）为数字设计提供了3种加工工艺模型：慢速（slow）工艺模型，典型（typical）工艺模型和快速（fast）工艺模型，快速和慢速工艺模型代表了半导体代工厂加工的两个极端工艺角（process corner）。<br>可以使用<code>set_operating_conditions</code>命令明确指定设计的工作条件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set_operating_conditions “WCCOM” -library mychip</span><br></pre></td></tr></table></figure><p>上述命令使用了在单元库mychip中定义的名为WCCOM的工作条件。</p><h3 id="工艺角（工作条件）"><a href="#工艺角（工作条件）" class="headerlink" title="工艺角（工作条件）"></a>工艺角（工作条件）</h3><p>WCS（Worst-Case Slow）<br>    工艺慢（slow）、温度最高（例如125°C）并且电压最低（例如额定1.2V减去10％）<br>TYP（Typical）<br>    典型（typical）工艺，温度是额定值（例如25°C），电压是额定值（例如1.2V）<br>BCF（Best-Case Fast）<br>    工艺快（fast），温度最低（例如-40°C），电压最高（例如额定1.2V加10％）</p><h3 id="功耗分析工作条件"><a href="#功耗分析工作条件" class="headerlink" title="功耗分析工作条件"></a>功耗分析工作条件</h3><p>​ML（Maximal Leakage）：工艺快，温度最高（例如125°C），电压也最高（例如1.2V加10％）。<br>​该工作条件有最大的漏电功耗（leakage power），对于大多数设计，也有着最大的有效功耗（active power）。<br>​TL（Typical Leakage）：经典工艺，温度最高（例如125°C），电压是额定值（例如1.2V）<br>​该工作条件下的漏电功耗比较具有代表性，因为由于正常工作时的功耗，芯片温度往往会更高。</p><h1 id="补充定义"><a href="#补充定义" class="headerlink" title="补充定义"></a>补充定义</h1><h2 id="PAP"><a href="#PAP" class="headerlink" title="PAP"></a>PAP</h2><p>Power Area Performance 。这是一个需要进行折中的选择，你很难或者你不能做到这三个方面同时达到最优解。也是我们DC约束需要考虑的问题，也是你的约束应该体现的部分。在后续的学习中会进一步进行解释。</p><h2 id="时序收敛"><a href="#时序收敛" class="headerlink" title="时序收敛"></a>时序收敛</h2><p>时序收敛（英语：Timing closure）是现场可编程逻辑门阵列、特殊应用积体电路等集成电路设计过程中，调整、修改设计，从而使得所设计的电路满足时序要求的过程。一般也会称这项工作为收时序。</p><h2 id="CMOS逻辑设计补充知识点"><a href="#CMOS逻辑设计补充知识点" class="headerlink" title="CMOS逻辑设计补充知识点"></a>CMOS逻辑设计补充知识点</h2><blockquote><p>说明：该部分对《数字集成电路：电路、系统与设计（第二版）》的数字部分进行总结，主要以反相器为代表的一些电路的典型性质，帮助理解后续的相关概念，具体学习可以参考该部分的内容</p></blockquote><h3 id="CMOS逻辑电平"><a href="#CMOS逻辑电平" class="headerlink" title="CMOS逻辑电平"></a>CMOS逻辑电平</h3><p>一般的逻辑电平就是0-1.是我们数字电路中可以接收的两种状态。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521141715864.png" alt="0-1逻辑电平"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521141831143.png" alt="实际的输出电平"></p><h3 id="标准单元举例"><a href="#标准单元举例" class="headerlink" title="标准单元举例"></a>标准单元举例</h3><p>看一个两输入与非门的定义</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521141920748.png" alt="两输入与非门"></p><p>使用P做上拉网络，N管做下拉网络。由于其本身的强1弱0以及强0弱1的性质决定的。同时解释了我们为什么需要做一个布尔表达式的转换，就是由于基本单元都是与非门或非门这种形式，一个与门实际上是由6个管子（与非门四个＋反相器两个）来构成的。</p><h3 id="电平转换时间公式"><a href="#电平转换时间公式" class="headerlink" title="电平转换时间公式"></a>电平转换时间公式</h3><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521142437221.png" alt="表达式"></p><p>对于一个单元的时序关系，可以看到这里的转换时间与两个因素有关，负载电容与电阻有关，这就是是RC在电路中的影响，对于单元延时的影响。当然主要是C，因为R已经确定了，但是你的负载是不确定的。<br>因此在DC中确定一个单元延时的方式就是根据其负载电容来查表获取的。<br>其次影响一个单元延时的还有输入转换时间。因为我们输出的负载确定了，但是你的输入转换时间也是对单元延时有影响的。</p><p>我们总结一下就是这几个因素:</p><ul><li>内部：<ul><li>单元本身的电阻</li></ul></li><li>外部：<ul><li>单元的负载</li><li>单元的输入转换时间</li></ul></li><li>其他（通过设置缩放因子来解决）<ul><li>制成</li><li>温度</li><li>电压……</li></ul></li></ul><p>我们在后续的学习中都会见到对其进行的建模的相关指令</p><h2 id="时序计算单位"><a href="#时序计算单位" class="headerlink" title="时序计算单位"></a>时序计算单位</h2><p>时序分析中需要基于温度、电压、电流、电阻、电容负载和时间等不同类型的变量因子进行计算，因此需要在时序信息文件中定义不同类型的变量因子的单位。以下为时序信息文件中所定义的变量因子单位：</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220521144723751.png" alt="单位定义"></p><p>该部分会在第三节的单元库学习中进一步学习。</p><h3 id="查看库的信息"><a href="#查看库的信息" class="headerlink" title="查看库的信息"></a>查看库的信息</h3><p>举例<br><code>read_db &lt;target_library_FILE&gt;</code> 读入一个库文件<br><code>list_libs</code> 确定与该库文件对应的库的名称<br><code>redirect -file lib.rpt &#123;report_lib cb13fs120_tsmc_max&#125;</code> 为上述的库生成一个库报告文件<br>这里我们使用重定向的命令，将报告的结果保存到lib.rpt这个文件中。redirect是重定向的命令，-file是将命令产生信息保存到文件中，lib.rpt是要保存信息到文件，后面的{}中存放的是要执行的命令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在前一部分介绍了什么是STA，STA在数字IC设计流程中的位置，优点。该博文继续介绍STA，先通过一个简单的例子来引入，然后介绍一些STA的有关定义。我们的目的是为了建立一个模型，将我们的Verilog HDL语言综合的Schematic原理图转换</summary>
      
    
    
    
    <category term="DC" scheme="https://guodongblog.com/categories/DC/"/>
    
    <category term="DC学习笔记" scheme="https://guodongblog.com/categories/DC/DC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="DC学习笔记" scheme="https://guodongblog.com/tags/DC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="STA" scheme="https://guodongblog.com/tags/STA/"/>
    
  </entry>
  
  <entry>
    <title>基础知识之一——STA基础概述</title>
    <link href="https://guodongblog.com/posts/d998c5ed40bb/"/>
    <id>https://guodongblog.com/posts/d998c5ed40bb/</id>
    <published>2022-05-16T10:15:39.000Z</published>
    <updated>2022-05-21T14:39:06.572Z</updated>
    
    <content type="html"><![CDATA[<div class="note info simple"><p>本文是DC笔记系列的第一篇，也是第一次来尝试写这种系列文章，有不足的地方非常欢迎同学们指出，该部分主要介绍什么是STA，有一个感性的认识，了解其使用的好处，什么地方再用，怎么用等。是基础部分的第一篇~主要分三个部分，什么是STA，CMOS数字设计中STA的使用于STA的局限性三个部分展开，参考《Static Timing Analysis for Nanometer Designs 》（第一章）的内容。</p></div><h1 id="什么是STA"><a href="#什么是STA" class="headerlink" title="什么是STA"></a>什么是STA</h1><blockquote><p>静态时序分析（简称STA）是用来验证数字设计时序的技术之一。下面将就时序与验证两个部分对STA进行一定的解释。</p></blockquote><h2 id="时序部分"><a href="#时序部分" class="headerlink" title="时序部分"></a>时序部分</h2><p>简单介绍时序检查的内容及其优点。</p><h3 id="时序检查的内容"><a href="#时序检查的内容" class="headerlink" title="时序检查的内容"></a>时序检查的内容</h3><p>时序检查是指建立时间与保持时间检查：<strong>建立时间检查</strong>是用来保证数据可以在给定时钟周期内到达触发器；<strong>保持时间检查</strong>是用来保证数据在被触发器采样后还能保持一定时间，即保证触发器不要漏采数据。<br>这些时序检查的目的都是为了保证触发器可以发送并且采样到正确的数据。</p><p><img src="E:\git_prj\blog.img\image-20220516182520333-16531191424151.png" alt="STA"></p><h3 id="时序检查的优点"><a href="#时序检查的优点" class="headerlink" title="时序检查的优点"></a>时序检查的优点</h3><p>STA是一种可以验证设计中所有时序要求的详尽方法，而其他时序分析方法例如时序仿真则只能验证到被当前激励执行到的那部分时序路径。基于时序仿真的验证完备性取决于施加激励的完备性。如果使用时序仿真来验证一个千万门级别的设计，速度将会非常慢，并且实际上也无法充分验证。因此，想要基于时序仿真的方法来进行详尽的时序验证是非常困难的。<br>相比之下，STA则提供了一种更快更简单的方法去分析并检查设计中的全部时序路径。鉴于如今的ASIC设计规模已达千万门级别，STA已经成为了详尽地验证设计时序的必要方法。</p><h2 id="验证的分类"><a href="#验证的分类" class="headerlink" title="验证的分类"></a>验证的分类</h2><h3 id="动态仿真（时序仿真）"><a href="#动态仿真（时序仿真）" class="headerlink" title="动态仿真（时序仿真）"></a>动态仿真（时序仿真）</h3><p>施加外部输入激励到所设计的电路模型，判断它所产生的输出响应是否符合预期功能，主要用于验证电路功能。施加一组激励，观察在这组激励下电路行为是否符合要求，然后换一组激励再重复以上过程，以此类推。</p><h3 id="静态仿真"><a href="#静态仿真" class="headerlink" title="静态仿真"></a>静态仿真</h3><p>其对于设计的分析是静态地执行的，并不依赖于施加在输入端口上的激励<br>分析电路所有路径的时序，或者将待验证的电路与参考电路进行对照比较，主要用于验证电路性能指标，限于数字逻辑电路</p><h3 id="物理验证"><a href="#物理验证" class="headerlink" title="物理验证"></a>物理验证</h3><p>检查版图是否符合预定的设计规则，是否与电路一致<br>类型为DRC， ERC， LVS。设计规则检查（DRC， Design Rule Check）、 电气规则检查（ERC， Electronic Rule Check）、版图-原理图一致性检查（LVS， Layout Versus Schematic）</p><h1 id="CMOS数字设计中STA的使用"><a href="#CMOS数字设计中STA的使用" class="headerlink" title="CMOS数字设计中STA的使用"></a>CMOS数字设计中STA的使用</h1><h2 id="SAT的对象"><a href="#SAT的对象" class="headerlink" title="SAT的对象"></a>SAT的对象</h2><p>首先明确在设计流程中的位置，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220516185901909.png" alt="STA在设计流程中的位置"></p><p>主要是对门级电路进行的静态时序分析。STA很少在RTL级完成，因为在这一抽象层级上，验证设计的功能更为重要，而非时序。 同样，由于块（block）的描述处于行为级，因此时序信息也并非都是可用的。可以结合检查的内容进行理解，只有综合出来寄存器以后才可以进行检查。简单来说就是门级网表。<br>但是，需要明确的是，作为一名IC设计工程师，你需要在写RTL代码的时候，就需要有一定的STA意识。更具体的内容后续会单独展开，该部分不属于本系列分析的内容。</p><h2 id="不同阶段的STA"><a href="#不同阶段的STA" class="headerlink" title="不同阶段的STA"></a>不同阶段的STA</h2><h3 id="完成DC综合之后"><a href="#完成DC综合之后" class="headerlink" title="完成DC综合之后"></a>完成DC综合之后</h3><ul><li>DC(Design Compiler)将RTL转化为门级网表，这个时候进行的STA是属于逻辑设计层次的静态时序分析。</li><li>这个阶段时钟为带有延时和抖动的理想时钟</li><li>这个阶段没有与布局有关的实际物理信息，因此假设这个阶段线延时也是理想的或者使用线负载模型来进行评估</li></ul><h3 id="完成布局"><a href="#完成布局" class="headerlink" title="完成布局"></a>完成布局</h3><ul><li>这个时候有了布局的信息，全局布线（global route）阶段</li><li>在物理设计的全局布线阶段，简化的布线用于估计布线长度，而对布线的估计用于确定计算走线延迟所需的电阻和电容值。 在此阶段中，无法考虑耦合效应带来的影响。</li></ul><h3 id="完成时钟树综合"><a href="#完成时钟树综合" class="headerlink" title="完成时钟树综合"></a>完成时钟树综合</h3><ul><li>这个时候的时钟是真实的时钟树</li></ul><h3 id="完成布线"><a href="#完成布线" class="headerlink" title="完成布线"></a>完成布线</h3><ul><li>最终布线（final route）阶段，在实际精细的布线完成后，就可以提取实际的RC值，并且可以分析耦合效应带来的影响这个时候使用的是真实的时钟树，布局布线。提取工具用于从布线设计中提取详细的寄生参数（RC值），这样的提取工具一般具有以下选项：在迭代优化期间以较少的运行时间和较低精确度的RC值来获取寄生参数，以及在最终验证期间以较长的运行时间来提取非常精确的RC值。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在逻辑级（未进行物理设计的门级），STA可采用以下模型：</p><ul><li>理想的互连线或者基于线负载模型的互连线</li><li>带有延迟和抖动估计值的理想时钟</li></ul><p>在物理设计阶段，除了上述模型，STA还可采用以下模型：</p><ul><li>具有近似估计值的全局布线的互连线、具有近似寄生参数提取值的实际布线的互连线、具有可以签收（signoff）精度寄生参数提取值的实际布线的互连线</li><li>实际的时钟树</li><li>包括串扰的影响或者不包括串扰的影响</li></ul><h1 id="STA的局限性"><a href="#STA的局限性" class="headerlink" title="STA的局限性"></a>STA的局限性</h1><blockquote><p>这里的局限性可以理解为STA不能做的，经过后续的学习，也可以从本质上理解为什么不能处理这些问题，相关的内容将会在下节展开~</p></blockquote><p><strong>跨时钟周期的功能行为</strong>：STA无法建模或仿真跨时钟周期变化的功能行为<br><strong>IO接口时序</strong>：可能仅根据STA约束无法规定IO接口要求。例如，设计人员可能使用SDRAM仿真模型为DDR接口选择详细的电路级仿真<br> <strong>未知态X的处理</strong>：STA技术仅处理逻辑0和逻辑1（或高电平&#x2F;低电平）的逻辑域，或者是上升沿和下降沿的逻辑域。 设计中的未知态X导致不确定的值在整个设计中传播，这也是无法使用STA进行检查。<br><strong>PLL设置</strong>：PLL的配置可能未被正确加载或设置<br><strong>跨异步时钟域</strong><br><strong>FIFO指针不同步</strong><br><strong>跨时钟周期的功能行为</strong><br><strong>伪路径（false path）</strong>：当系统应用程序从不使用此类路径时，或者在时序违例路径的敏感列表中使用了互斥的条件时，可能会发生这种情况。 这种时序路径被称为伪路径，因为这种时序路径实际上不会被执行。<br>当在设计中指定了正确的时序约束（包括伪路径和多周期路径约束）时，STA结果的质量会更好。 在大多数情况下，设计人员可以利用设计的固有知识并指定约束条件，以便在STA期间消除伪路径。<br><strong>模拟模块和数字模块之间的接口</strong>：由于STA不处理模拟模块，因此验证方法需要确保这两种类型的模块之间的连接正确。<br><strong>复位顺序</strong>：检查所有触发器在异步或同步复位后是否都复位为所需的逻辑值，这是无法使用静态时序分析来检查的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note info simple&quot;&gt;&lt;p&gt;本文是DC笔记系列的第一篇，也是第一次来尝试写这种系列文章，有不足的地方非常欢迎同学们指出，该部分主要介绍什么是STA，有一个感性的认识，了解其使用的好处，什么地方再用，怎么用等。是基础部分的第一篇~主要分三个部分</summary>
      
    
    
    
    <category term="DC" scheme="https://guodongblog.com/categories/DC/"/>
    
    <category term="DC学习笔记" scheme="https://guodongblog.com/categories/DC/DC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="DC学习笔记" scheme="https://guodongblog.com/tags/DC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="STA" scheme="https://guodongblog.com/tags/STA/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-Butterfly音乐播放器的添加</title>
    <link href="https://guodongblog.com/posts/91597d56b19f/"/>
    <id>https://guodongblog.com/posts/91597d56b19f/</id>
    <published>2022-05-12T06:43:26.000Z</published>
    <updated>2022-05-18T16:16:21.104Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>说明：该配置基于Butterfly主题版本为 4.2.0，基本参考官方教程，不修改pug文件，主题已经集成了相关的设置，该博文对其部分内容进行补充。参考链接在文章末尾给出。</p></blockquote><h1 id="插件的安装与配置"><a href="#插件的安装与配置" class="headerlink" title="插件的安装与配置"></a>插件的安装与配置</h1><p>安装 <a href="https://github.com/MoePlayer/hexo-tag-aplayer">hexo-tag-aplayer</a> 这款插件。执行如下指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-tag-aplayer</span><br></pre></td></tr></table></figure><p>插件配置方式为修改<strong>Hexo 的配置文件</strong>中进行如下修改。就是你的Hexo根目录下的<code>_config.yml</code>文件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aplayer:</span><br><span class="line">  meting: true</span><br><span class="line">  asset_inject: false</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220512154054964.png"></p><p>开启主题配置文件中的<code>aplayerInject</code>如下所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Inject the css and script (aplayer/meting)</span><br><span class="line">aplayerInject:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: true</span><br></pre></td></tr></table></figure><p>主题配置文件的就是自己建立的<code>_config.butterfly.yml</code>文件。建议使用vscode，可以进行全局搜索。更加方便进行修改。<br>至此就已经可以使用了。下面介绍两种最常用的使用。</p><h1 id="普通界面播放器"><a href="#普通界面播放器" class="headerlink" title="普通界面播放器"></a>普通界面播放器</h1><p>以本博客为例，在博客的音乐页面（\source\music\index.md文件）添加如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% meting &quot;7422861869&quot; &quot;netease&quot; &quot;playlist&quot; &quot;autoplay&quot; &quot;mutex:false&quot; &quot;listmaxheight:400px&quot; &quot;preload:none&quot; &quot;theme:#ad7a86&quot;%&#125;</span><br></pre></td></tr></table></figure><p>常用的选项如下所示:<br><code>server</code>可选：<code>netease</code>（网易云音乐），<code>tencent</code>（QQ音乐），<code>kugou</code>（酷狗音乐），<code>xiami</code>（虾米音乐），<code>baidu</code>（百度音乐）。建议网易云<br><code>type</code>可选：<code>song</code>（歌曲），<code>playlist</code>（歌单），<code>album</code>（专辑），<code>search</code>（搜索关键字），<code>artist</code>（歌手）。添加单曲选的歌曲，歌单选择playlist，可以自行尝试。<br><code>id</code>获取示例: 打开网易云音乐，选择喜欢的歌单，在网页版打开，获取歌单list，填入即可。使用的时候将上边的ID号换为自己喜欢的歌单即可。&#x3D;&#x3D;<strong>注意歌单中不能包括VIP音乐，否则无法解析</strong>&#x3D;&#x3D;。建议单独建立一个歌单，以后有喜欢的音乐添加进去，网页也会自动同步添加。<br><code>lrcType</code>设置为 <code>-1</code>默认显示歌词，放在fixed模式下比较合适。</p><p>基本上修改的参数以上就已经足够了。ID获取的方式如下。完整的参数表见附录，也可以去参考链接中查看。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220512152603295.png"></p><p>也可以直接添加HTMI格式。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;aplayer&quot; data-id=&quot;000PeZCQ1i4XVs&quot; data-server=&quot;tencent&quot; data-type=&quot;artist&quot; data-preload=&quot;auto&quot; data-theme=&quot;#3F51B5&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>需要修改的参数已经给出，可以自行修改。</p><h1 id="全局吸底Aplayer模式"><a href="#全局吸底Aplayer模式" class="headerlink" title="全局吸底Aplayer模式"></a>全局吸底Aplayer模式</h1><p>把 aplayer代码 插入到主题配置文件的 inject.bottom 即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inject:</span><br><span class="line">  head:</span><br><span class="line">  bottom:</span><br><span class="line">    - &lt;div class=&quot;aplayer no-destroy&quot; data-id=&quot;7422861869&quot; data-server=&quot;netease&quot; data-type=&quot;playlist&quot; data-fixed=&quot;true&quot; data-autoplay=&quot;true&quot; data-lrcType=&quot;-1&quot;&gt; &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>需要修改的参数就只有<code>data-id、data-server、data-type、data-autoplay=&quot;true&quot;、data-lrcType=&quot;-1&quot;</code>一些常用的参数，可以自行根据需要修改。</p><p>最后，如果你想切换页面时，音乐不会中断。请把主题配置文件的 <code>pjax</code> 设为 true即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pjax:</span><br><span class="line"> enable: ture</span><br><span class="line"> exclude:</span><br></pre></td></tr></table></figure><p>css文件的建立参考<a href="https://tyxiumud.github.io/posts/b0fabd94caa6/">个人博客搭建与美化</a>中的鼠标样式部分。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 隐藏 Aplayer 的全局吸底音乐标签，在css中添加 */</span><br><span class="line">.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body &#123;</span><br><span class="line">    left: -66px !important</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover &#123;</span><br><span class="line">    left: 0 !important</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><h2 id="1，普通列表模式"><a href="#1，普通列表模式" class="headerlink" title="1，普通列表模式"></a>1，普通列表模式</h2><p>对应代码注意这里将 “listmaxheight:100px”列表高度调整为100，为了方便展示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% meting &quot;7422861869&quot; &quot;netease&quot; &quot;playlist&quot; &quot;autoplay&quot; &quot;mutex:false&quot; &quot;listmaxheight:100px&quot; &quot;preload:none&quot; &quot;autoplay = false&quot; &quot;theme:#ad7a86&quot;%&#125;</span><br></pre></td></tr></table></figure>    <div id="aplayer-oxvNdAJi" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="7422861869" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="100px" data-preload="none" data-theme="#ad7a86"    ></div><h2 id="2，单曲播放"><a href="#2，单曲播放" class="headerlink" title="2，单曲播放"></a>2，单曲播放</h2><p>插入单曲使用如下方式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;aplayer no-destroy&quot; data-id=&quot;1441758494&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot;  data-autoplay=&quot;true&quot; data-lrcType=&quot;-1&quot;&gt; &lt;/div&gt;</span><br></pre></td></tr></table></figure><div class="aplayer no-destroy" data-id="1441758494" data-server="netease" data-type="song"  data-autoplay="true" data-lrcType="-1"> </div><h2 id="3，迷你模式"><a href="#3，迷你模式" class="headerlink" title="3，迷你模式"></a>3，迷你模式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;aplayer no-destroy&quot; data-id=&quot;1441758494&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mini=&quot;true&quot; data-autoplay=&quot;true&quot; data-lrcType=&quot;-1&quot;&gt; &lt;/div&gt;</span><br></pre></td></tr></table></figure><div class="aplayer no-destroy" data-id="1441758494" data-server="netease" data-type="song" data-mini="true" data-autoplay="true" data-lrcType="-1"> </div><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/MoePlayer/hexo-tag-aplayer">hexo-tag-aplayer的GitHub地址</a><br><a href="https://aplayer.js.org/#/home">aplayer官方说明文档</a><br><a href="https://butterfly.js.org/posts/507c070f/">butterfly官方教程</a></p><h2 id="Aplayer完整配置可选参数表"><a href="#Aplayer完整配置可选参数表" class="headerlink" title="Aplayer完整配置可选参数表"></a>Aplayer完整配置可选参数表</h2><p>下面是官方所示的完整可选配置参数。</p><table><thead><tr><th>Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>container</td><td>document.querySelector(‘.aplayer’)</td><td>player container</td></tr><tr><td>fixed</td><td>false</td><td>enable fixed mode, <a href="https://aplayer.js.org/#/home?id=fixed-mode">see more details</a></td></tr><tr><td>mini</td><td>false</td><td>enable mini mode, <a href="https://aplayer.js.org/#/home?id=mini-mode">see more details</a></td></tr><tr><td>autoplay</td><td>false</td><td>audio autoplay</td></tr><tr><td>theme</td><td>‘#b7daff’</td><td>main color</td></tr><tr><td>loop</td><td>‘all’</td><td>player loop play, values: ‘all’, ‘one’, ‘none’</td></tr><tr><td>order</td><td>‘list’</td><td>player play order, values: ‘list’, ‘random’</td></tr><tr><td>preload</td><td>‘auto’</td><td>values: ‘none’, ‘metadata’, ‘auto’</td></tr><tr><td>volume</td><td>0.7</td><td>default volume, notice that player will remember user setting, default volume will not work after user set volume themselves</td></tr><tr><td>audio</td><td>-</td><td>audio info, should be an object or object array</td></tr><tr><td>audio.name</td><td>-</td><td>audio name</td></tr><tr><td>audio.artist</td><td>-</td><td>audio artist</td></tr><tr><td>audio.url</td><td>-</td><td>audio url</td></tr><tr><td>audio.cover</td><td>-</td><td>audio cover</td></tr><tr><td>audio.lrc</td><td>-</td><td><a href="https://aplayer.js.org/#/home?id=lrc">see more details</a></td></tr><tr><td>audio.theme</td><td>-</td><td>main color when switching to this audio, it has priority over the above theme</td></tr><tr><td>audio.type</td><td>‘auto’</td><td>values: ‘auto’, ‘hls’, ‘normal’ or other custom type, <a href="https://aplayer.js.org/#/home?id=mse-support">see more details</a></td></tr><tr><td>customAudioType</td><td>-</td><td><a href="https://aplayer.js.org/#/home?id=mse-support">see more details</a></td></tr><tr><td>mutex</td><td>true</td><td>prevent to play multiple player at the same time, pause other players when this player start play</td></tr><tr><td>lrcType</td><td>0</td><td><a href="https://aplayer.js.org/#/home?id=lrc">see more details</a></td></tr><tr><td>listFolded</td><td>false</td><td>indicate whether list should folded at first</td></tr><tr><td>listMaxHeight</td><td>-</td><td>list max height</td></tr><tr><td>storageName</td><td>‘aplayer-setting’</td><td>localStorage key that store player setting</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;说明：该配置基于Butterfly主题版本为 4.2.0，基本参考官方教程，不修改pug文件，主题已经集成了相关的设置，该博文对其部分内容进行补充。参考链接在文章末尾给出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;插件的安装与配置&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="个人博客搭建" scheme="https://guodongblog.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="Hexo" scheme="https://guodongblog.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>TCL脚本语言的学习（二）</title>
    <link href="https://guodongblog.com/posts/deed0e8e9628/"/>
    <id>https://guodongblog.com/posts/deed0e8e9628/</id>
    <published>2022-05-08T15:15:57.000Z</published>
    <updated>2022-05-21T07:53:25.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h1><p>介绍控制流命令，对之前系列<a href="https://tyxiumud.github.io/posts/eed5d1af4b43/">TCL脚本语言的学习（一）</a>进行补充</p><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>语法： if test1 body1 ?elseif test2 body2 elseif…. ? ?else bodyn?<br>TCL 先把 test1 当作一个表达式求值，如果值非 0，则把 body1 当作一个脚本执行并返回所得值，否则把 test2 当作一个表达式求值，如果值非 0，则把 body2 当作一个脚本执行并返回所得值……。例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> &#123; $x&lt;<span class="number">0</span> &#125; &#123;</span><br><span class="line">  <span class="built_in">puts</span> <span class="string">&quot;x is smaller than zero&quot;</span></span><br><span class="line">&#125; elseif &#123;$x==<span class="number">1</span>&#125; &#123;</span><br><span class="line">  <span class="built_in">puts</span> <span class="string">&quot;x is equal 1&quot;</span></span><br><span class="line">&#125; elseif &#123;$x==<span class="number">2</span>&#125; &#123;</span><br><span class="line">  <span class="built_in">puts</span> <span class="string">&quot;x is equal 2&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">puts</span> <span class="string">&quot;x is other&quot;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这里需要注意的是，<br>if 和{之间应该有一个空格，否则TCL解释器会把’if{‘作为一个整体当作一个命令名，从而导致错误。<br>‘{‘一定要写在上一行，因为如果不这样，TCL 解释器会认为if命令在换行符处已结<br>束，下一行会被当成新的命令，从而导致错误的结果需要将<code>&#125;&#123;</code> 分开写，<br>否则会报错<code>extra characters after close-brace</code><br><img src="https://img-blog.csdnimg.cn/20200324224458156.png"></p><h2 id="循环命令"><a href="#循环命令" class="headerlink" title="循环命令"></a>循环命令</h2><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>语法为: while test body<br>参数 test 是一个表达式，body 是一个脚本，<strong>如果表达式test 的值非 0，就运行脚本，直到表达式为0 才停止循环，此时 while 命令中断并返回一个空字符串。</strong><br>例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> a &#123;a b c d e&#125;</span><br><span class="line"><span class="built_in">set</span> b <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="built_in">set</span> i [expr [llength $a]<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">while</span> &#123;$i&gt;=<span class="number">0</span>&#125; &#123;</span><br><span class="line">lappend b [lindex $a $i]</span><br><span class="line">incr i <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span> <span class="string">&quot;b=$b&quot;</span></span><br></pre></td></tr></table></figure><p>对代码进行分析<br>set 变量a为一个list，b为一个空list<br>然后计算列表里有几个元素，将其减一后的值赋值给i，这里减一的目的是从零开始计数会多一个<br>开始进行循环，首先i的值是4大于0，表达式为真，开始执行脚本。<br>脚本为将数组a的第i个位置的元素添加到b list 里，然后给i减一同时进行下一次判断即可。<br>最后输出b的值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">b=e d c b a</span><br></pre></td></tr></table></figure><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>语法为: for init test reinit body<br>参数init是一个初始化脚本，第二个参数test是一个表达式，用来决定循环什么时候中断，第三个参数reinit是一个重新初始化的脚本，第四个参数body也是脚本，代表循环体。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;<span class="built_in">set</span> p <span class="number">0</span>&#125; &#123;$p&lt;=<span class="number">10</span>&#125; &#123;incr p&#125; &#123;</span><br><span class="line"><span class="built_in">puts</span> <span class="string">&quot;$p squared is : [expr $p*$p]&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> squared is : <span class="number">0</span></span><br><span class="line"><span class="number">1</span> squared is : <span class="number">1</span></span><br><span class="line"><span class="number">2</span> squared is : <span class="number">4</span></span><br><span class="line"><span class="number">3</span> squared is : <span class="number">9</span></span><br><span class="line"><span class="number">4</span> squared is : <span class="number">16</span></span><br><span class="line"><span class="number">5</span> squared is : <span class="number">25</span></span><br><span class="line"><span class="number">6</span> squared is : <span class="number">36</span></span><br><span class="line"><span class="number">7</span> squared is : <span class="number">49</span></span><br><span class="line"><span class="number">8</span> squared is : <span class="number">64</span></span><br><span class="line"><span class="number">9</span> squared is : <span class="number">81</span></span><br><span class="line"><span class="number">10</span> squared is : <span class="number">100</span></span><br></pre></td></tr></table></figure><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>foreach varName list body 第一个参数 varName 是一个变量，第二个参数 list 是一个表(有序集合)，第三个参数 body 是循环体。每次取得链表的一个元素，都会执行循环体一次。这里对于复杂的操作不进行解释，参考<a href="https://blog.csdn.net/qq_41467882/article/details/104841946">文章一</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> a [<span class="built_in">list</span> A B C D E F G]</span><br><span class="line"><span class="built_in">set</span> b <span class="string">&quot;&quot;</span></span><br><span class="line">foreach i $a &#123;</span><br><span class="line"><span class="built_in">set</span> b [linsert $b <span class="number">0</span> $i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span> $b</span><br></pre></td></tr></table></figure><p>运行结果为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">G F E D C B A</span><br></pre></td></tr></table></figure><p>赋值给变量</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% foreach &#123;x y&#125; &#123;a b c d &#125; &#123;</span><br><span class="line">  puts <span class="string">&quot;<span class="variable">$x</span> <span class="variable">$y</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">a b</span><br><span class="line">c d</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200324235828626.png">又例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% foreach i &#123;a b&#125; &#123;j k&#125; &#123;v W x y z&#125; &#123;</span><br><span class="line">puts <span class="string">&quot;i=<span class="variable">$i</span>,j=<span class="variable">$j</span>,k=<span class="variable">$k</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">i=a,j=v,k=W</span><br><span class="line">i=b,j=x,k=y</span><br><span class="line">i=,j=z,k=</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="break和continue命令"><a href="#break和continue命令" class="headerlink" title="break和continue命令"></a>break和continue命令</h3><p>在循环体中，可以用break和continue命令中断循环。其中break命令结束整个循环过程，并从循环中跳出，continue只是结束本次循环<br>这里有一个特别好的例子<br>说明：这里首先进行给一个list，然后使用foreach循环进行写入数据当遇见break时候直接退出了循环，而continue仅仅只是跳出此次循环继续向b里写入数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">% <span class="built_in">set</span> b &#123;&#125;</span><br><span class="line">% <span class="built_in">set</span> a &#123;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>&#125;</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">% foreach i $a &#123;</span><br><span class="line"><span class="keyword">if</span> &#123;$i == <span class="number">4</span>&#125; <span class="keyword">break</span> </span><br><span class="line"><span class="built_in">set</span> b [linsert $b <span class="number">0</span> $i]</span><br><span class="line">&#125;</span><br><span class="line">% <span class="built_in">puts</span> $b</span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% <span class="built_in">set</span> b &#123;&#125;</span><br><span class="line">% <span class="built_in">set</span> a &#123;1 2 3 4 5&#125;</span><br><span class="line">1 2 3 4 5</span><br><span class="line">% foreach i <span class="variable">$a</span> &#123;</span><br><span class="line"><span class="keyword">if</span> &#123;<span class="variable">$i</span> == 4&#125; <span class="built_in">continue</span> </span><br><span class="line"><span class="built_in">set</span> b [linsert <span class="variable">$b</span> 0 <span class="variable">$i</span>]</span><br><span class="line">&#125;</span><br><span class="line">% puts <span class="variable">$b</span></span><br><span class="line">5 3 2 1</span><br></pre></td></tr></table></figure><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>和 C 语言中 switch 语句一样，TCL 中的 switch 命令也可以由 if 命令实现。只是书写起来较为烦琐。 switch 命令的语法为: switch ? options? string { pattern body ? pattern body …?}<br>注意这里进行的是字符匹配<br><img src="https://img-blog.csdnimg.cn/20200325001239602.png"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> x a;</span><br><span class="line"><span class="built_in">set</span> t1 0;<span class="built_in">set</span> t2 0;<span class="built_in">set</span> t3 0;</span><br><span class="line">switch <span class="variable">$x</span> &#123;</span><br><span class="line">a -</span><br><span class="line">b &#123;incr t1&#125;</span><br><span class="line">c &#123;incr t2&#125;</span><br><span class="line">default &#123;incr t3&#125;</span><br><span class="line">&#125; </span><br><span class="line">puts <span class="string">&quot;t1=<span class="variable">$t1</span>,t2=<span class="variable">$t2</span>，t3=<span class="variable">$t3</span>&quot;</span></span><br></pre></td></tr></table></figure><p>x&#x3D;a时执行的是t1加2<br>其中 a 的后面跟一个’－’表示使用和下一个模式相同的脚本。default 表示匹配任意值。一旦switch 命令 找到一个模式匹配，就执行相应的脚本，并返回脚本的值，作为 switch 命令的返回值。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> grade B;</span><br><span class="line"><span class="keyword">switch</span> $grade &#123;</span><br><span class="line">   A &#123;</span><br><span class="line">     <span class="built_in">puts</span> <span class="string">&quot;Well done!&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">   B &#123;</span><br><span class="line">     <span class="built_in">puts</span> <span class="string">&quot;Excellent!&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   C &#123;</span><br><span class="line">     <span class="built_in">puts</span> <span class="string">&quot;You passed!&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">   F &#123;</span><br><span class="line">     <span class="built_in">puts</span> <span class="string">&quot;Better try again&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">default</span> &#123;</span><br><span class="line">     <span class="built_in">puts</span> <span class="string">&quot;Invalid grade&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span> <span class="string">&quot;Your grade is  $grade&quot;</span></span><br></pre></td></tr></table></figure><h2 id="source"><a href="#source" class="headerlink" title="source"></a>source</h2><p>source 命令读一个文件并把这个文件的内容作为一个脚本进行求值<br>以上边的switch第一段代码为例<br>使用VIM新建一个文件，写入文件后保存退出</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vim switch1.tcl</span><br></pre></td></tr></table></figure><p>键入<code>wish</code>然后输入<code>source switch1.tcl</code><br><img src="https://img-blog.csdnimg.cn/20200325010021646.png"></p><h1 id="过程（procedure）"><a href="#过程（procedure）" class="headerlink" title="过程（procedure）"></a>过程（procedure）</h1><p>TCL 支持过程的定义和调用，在 TCL 中,过程可以看作是用 TCL 脚本实现的命令，效果与 TCL的固有命令相似。我们可以在任何时候使用 proc 命令定义自己的过程，TCL 中的过程类似于 C中的函数。<br>TCL 中过程是由 proc 命令产生的：<br>例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">% proc add &#123;x y &#125; &#123;expr $x+$y&#125; </span><br></pre></td></tr></table></figure><p>proc 命令的第一个参数是你要定义的过程的名字，第二个参数是过程的参数列表，参数之间用空格隔开，第三个参数是一个 TCL 脚本，代表过程体。 proc 生成一个新的命令，可以象固有命令一样调用： </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">% add <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> </span><br></pre></td></tr></table></figure><p>此篇暂时这里结束，后又需要会继续记录</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;控制流&quot;&gt;&lt;a href=&quot;#控制流&quot; class=&quot;headerlink&quot; title=&quot;控制流&quot;&gt;&lt;/a&gt;控制流&lt;/h1&gt;&lt;p&gt;介绍控制流命令，对之前系列&lt;a href=&quot;https://tyxiumud.github.io/posts/eed5d1af4b4</summary>
      
    
    
    
    <category term="DC" scheme="https://guodongblog.com/categories/DC/"/>
    
    <category term="TCL" scheme="https://guodongblog.com/categories/DC/TCL/"/>
    
    
    <category term="TCL" scheme="https://guodongblog.com/tags/TCL/"/>
    
  </entry>
  
  <entry>
    <title>TCL脚本语言的学习（一）</title>
    <link href="https://guodongblog.com/posts/eed5d1af4b43/"/>
    <id>https://guodongblog.com/posts/eed5d1af4b43/</id>
    <published>2022-05-08T15:01:16.000Z</published>
    <updated>2022-05-21T07:53:45.198Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考资料为《<code>TCL</code>语言教程》，感谢作者的分享，这里仅仅作为简单常用语法的入门，若有需要后期对本文进行添加补充。</p></blockquote><h1 id="前言（TCL综述）"><a href="#前言（TCL综述）" class="headerlink" title="前言（TCL综述）"></a>前言（TCL综述）</h1><p><code>TCL</code>(Tool Command Language)是一种解释执行的脚本语言(Scripting Language)。 它提供了 通用的编程能力：支持变量、过程和控制结构；同时 <code>TCL</code>还拥有一个功能强大的固有的核心命令集。<br>由于<code>TCL</code>的解释器是用一个C\C++语言的过程库实现的，因此在某种意义上我们又可以把<code>TCL</code>看作一个C库，这个库中有丰富的用于扩展<code>TCL</code>命令的C\C++过程和函数，可以很容易就在C\C++应用程序中嵌入<code>TCL</code>，而且每个应用程序都可以根据自己的需要对<code>TCL</code>语言进行扩展。我们可以针对某一特定应用领域对<code>TCL</code>语言的核心命令集进行扩展，加入适合于自己的应用领域的扩展命令，如果需要，甚至可以加入新的控制结构，<code>TCL</code>解释器将把扩展命令和扩展控制结构与固有命令和固有控制结构同等看待。扩展后的<code>TCL</code>语言将可以继承<code>TCL</code> 核心部分的所有功能，包括核心命令、控制结构、数据类型、对过程的支持等。根据需要，我们甚至可以屏蔽掉<code>TCL</code>的某些固有命令和固有控制结构。通过对<code>TCL</code>的扩展、继承或屏蔽，用户用不着象平时定义一种计算机语言那样对词法、语法、语义、语用等各方面加以定义，就可以方便的为自己的应用领域提供一种功能完备的脚本语言。<br><code>TCL</code>良好的可扩展性使得它能很好地适应产品测试的需要，测试任务常常会由于设计和需求的改变而迅速改变，往往让测试人员疲于应付。利用<code>TCL</code>的可扩展性，测试人员就可以迅速继承多种新技术，并针对产品新特点迅速推出扩展<code>TCL</code>命令集，以用于产品的测试中，可以较容易跟上设计需求的变化。<br>另外，因为<code>TCL</code>是一种比C\C++ 语言有着更高抽象层次的语言，使用<code>TCL</code>可以在一种更高的层次上编写程序，它屏蔽掉了编写C\C++程序时必须涉及到的一些较为烦琐的细节，可以大大地提高开发测试例的速度。而且， 使用<code>TCL</code>语言写的测试例脚本，即使作了修改，也用不着重新编译就可以调用<code>TCL</code>解释器直接执行。可以省却不少时间。<code>TCL</code> 目前已成为自动测试中事实上的标准。<br>(这里笔者对于<code>TCL</code>脚本的用处目前还不是很明确，后期学习到了进行补充添加，此处作为EDA课程中的一部分进行学习)</p><h2 id="附录（Tcl的安装）"><a href="#附录（Tcl的安装）" class="headerlink" title="附录（Tcl的安装）"></a>附录（Tcl的安装）</h2><p>直接打开终端(terminal)，输入<code> sudo apt install tcl</code>即可进行安装，这里的截图是笔者安装成功后的实例。</p><p><img src="https://img-blog.csdnimg.cn/20200313161754650.png"><br>之后输入<code>tclsh</code>即可。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="脚本，命令和单词符号"><a href="#脚本，命令和单词符号" class="headerlink" title="脚本，命令和单词符号"></a>脚本，命令和单词符号</h2><p>一个<code>TCL</code>脚本可以包含一个或多个命令。命令之间必须用换行符或分号隔开，下面的两个脚本都<br>是合法的：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> a 1</span><br><span class="line"><span class="built_in">set</span> b 2</span><br><span class="line">或使用分号隔开</span><br><span class="line"><span class="built_in">set</span> a 1；<span class="built_in">set</span> b 2</span><br></pre></td></tr></table></figure><p><code>TCL</code>解释器对一个命令的求值过程分为两部分：分析和执行。在分析阶段，<code>TCL</code> 解释器运用规则把命令分成一个个独立的单词，同时进行必要的置换(substitution)； 在执行阶段，<code>TCL</code> 解释器会把第<br>一个单词当作命令名，并查看这个命令是否有定义，如果有定义就激活这个命令对应的C&#x2F;C++过程，并把所有的单词作为参数传递给该命令过程，让命令过程进行处理。</p><h2 id="置换-substitution"><a href="#置换-substitution" class="headerlink" title="置换(substitution)"></a>置换(substitution)</h2><p><code>TCL</code>解释器在分析命令时，把所有的命令参数都当作字符串看待，例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%<span class="built_in">set</span> x <span class="number">10</span> <span class="comment">//定义变量x,并把x的值赋为10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">%<span class="built_in">set</span> y x+<span class="number">100</span> <span class="comment">//y的值是x+100，而不是我们期望的110</span></span><br><span class="line">x+<span class="number">100</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200313162708793.png"><br>上例的第二个命令中，x被看作字符串x+100的一部分，如果我们想使用x的值’10’ ，就必须告诉<br><code>TCL</code>解释器：我们在这里期望的是变量x的值，而非字符’x’。怎么告诉<code>TCL</code>解释器呢，这就要用到<code>TCL</code>语言中提供的置换功能。置换功能分为三种.<code>TCL</code>提供三种形式的置换：变量置换、命令置换和反斜杠置换。每种置换都会导致一个或多个单词本身被其他的值所代替。置换可以发生在包括命令名在内的每一个单词中，而且置换可以嵌套。</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LRA[置换功能]  --&gt; B[变量置换variable subtitution]A[置换功能] --&gt; C[命令置换command substitution]A --&gt;D[反斜杠置换backslash substitution]  </pre></div><h2 id="变量置换variable-subtitution"><a href="#变量置换variable-subtitution" class="headerlink" title="变量置换variable subtitution"></a>变量置换variable subtitution</h2><p>变量置换由一个<code>＄</code>符号标记，变量置换会导致变量的值插入一个单词中。例如之前的一个例子</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%<span class="built_in">set</span> x <span class="number">10</span> <span class="comment">//定义变量x,并把x的值赋为10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">%<span class="built_in">set</span> y x+<span class="number">100</span> <span class="comment">//y的值是x+100，而不是我们期望的110</span></span><br><span class="line">x+<span class="number">100</span></span><br><span class="line">%<span class="built_in">set</span> y $x+<span class="number">100</span> <span class="comment">//y的值是我们期望的110</span></span><br><span class="line"><span class="number">110</span></span><br></pre></td></tr></table></figure><h2 id="命令置换command-substitution"><a href="#命令置换command-substitution" class="headerlink" title="命令置换command substitution"></a>命令置换command substitution</h2><p>命令置换是由<code>[]</code>括起来的<code>TCL</code>命令及其参数，命令置换会导致某一个命令的所有或部分单词被另一个命令的结果所代替。例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%<span class="built_in">set</span> y [expr $x+<span class="number">100</span>] </span><br><span class="line"><span class="number">110</span></span><br></pre></td></tr></table></figure><p>这里当<code>TCL</code>解释器遇到字符’[‘时，它就会把随后的expr作为一个命令名，从而激活与<code>expr</code>对应的C&#x2F;C++过程，并把<code>expr</code>和变量置换后得到的<code>10+100</code>传递给该命令过程进行处理。</p><h2 id="反斜杠置换backslash-substitution"><a href="#反斜杠置换backslash-substitution" class="headerlink" title="反斜杠置换backslash substitution"></a>反斜杠置换backslash substitution</h2><p><code>TCL</code>语言中的反斜杠置换类似于C语言中反斜杠的用法，主要用于在单词符号中插入诸如换行符、空格、[、$等被<code>TCL</code>解释器当作特殊符号对待的字符。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%<span class="built_in">set</span> msg money\ \$<span class="number">3333</span>\ \nArray\ a\[<span class="number">2</span>]</span><br><span class="line"><span class="comment">//这个命令的执行结果为：</span></span><br><span class="line">money $<span class="number">3333</span></span><br><span class="line">Array a[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h2 id="双引号和花括号"><a href="#双引号和花括号" class="headerlink" title="双引号和花括号"></a>双引号和花括号</h2><p>除了使用反斜杠外，<code>TCL</code>提供另外两种方法来使得解释器把分隔符和置换符等特殊字符当作普通字符，而不作特殊处理，这就要使用双引号和花括号(<code>&#123;&#125;</code>)。<br><code>TCL</code>解释器对双引号中的各种分隔符将不作处理，但是对换行符 及<code>＄</code>和<code>[]</code>两种置换符会照常处理。而在花括号中，所有特殊字符都将成为普通字符，失去其特殊意义，<code>TCL</code>解释器不会对其作特殊处理。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%<span class="built_in">set</span> y <span class="string">&quot;$x ddd&quot;</span></span><br><span class="line"><span class="number">100</span> ddd</span><br><span class="line">%<span class="built_in">set</span> y &#123;/n$x [expr <span class="number">10</span>+<span class="number">100</span>]&#125;</span><br><span class="line">/n$x [expr <span class="number">10</span>+<span class="number">100</span>]</span><br></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><code>TCL</code>中的注释符是<code>＃</code>，<code>＃</code>和直到所在行结尾的所有字符都被<code>TCL</code>看作注释，<code>TCL</code>解释器对注释将不作任何处理。<strong>不过，要注意的是，<code>＃</code>必须出现在<code>TCL</code>解释器期望命令的第一个字符出现的地方，才被当作注释。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%<span class="built_in">set</span> a <span class="number">100</span> # Not a comment</span><br><span class="line">wrong <span class="meta"># args: should be <span class="string">&quot;set varName ?newValue?&quot;</span></span></span><br><span class="line">%<span class="built_in">set</span> b <span class="number">101</span> ; <span class="meta"># this is a comment</span></span><br><span class="line"><span class="number">101</span></span><br></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量分为简单变量和数组</p><h2 id="简单变量"><a href="#简单变量" class="headerlink" title="简单变量"></a>简单变量</h2><p>一个 <code>TCL</code> 的简单变量包含两个部分：<strong>名字和值</strong>。名字和值都可以是任意字符串。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">% <span class="built_in">set</span> a <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="built_in">set</span> a<span class="number">.1</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">% <span class="built_in">set</span> b $a<span class="number">.1</span></span><br><span class="line"><span class="number">2.1</span></span><br></pre></td></tr></table></figure><p>在最后一个命令行，我们希望把变量a.1的值付给b，但是<code>TCL</code>解释器在分析时只把$符号之后直到第一个不是字母、数字或下划线的字符(这里是’.’)之间的单词符号(这里是’a’)当作要被置换的变量的名字，所以<code>TCL</code>解释器把a置换成2,然后把字符串“2.1”付给变量b。这显然与我们的初衷不同。<br>当然，如果变量名中有不是字母、数字或下划线的字符，又要用置换，可以用花括号把变量名括起来。例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%<span class="built_in">set</span> b $&#123;a<span class="number">.1</span>&#125;</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一些元素的集合。<code>TCL</code>的数组和普通计算机语言中的数组有很大的区别。在<code>TCL</code>中，不能单独声明一个数组，数组只能和数组元素一起声明。数组中，数组元素的名字包含两部分：数组名和数组中元素的名字，<code>TCL</code>中数组元素的名字（下标〕可以为任何字符串。 例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="title function_">day</span><span class="params">(monday)</span> 1</span><br><span class="line"><span class="built_in">set</span> <span class="title function_">day</span><span class="params">(tuesday)</span> 2</span><br></pre></td></tr></table></figure><p>数组元素的置换和简单变量类似。例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> a monday</span><br><span class="line"><span class="built_in">set</span> <span class="title function_">day</span><span class="params">(monday)</span> 1</span><br><span class="line"><span class="built_in">set</span> b $<span class="title function_">day</span><span class="params">(monday)</span> <span class="comment">//b 的值为 1 ，即 day(monday) 的值。</span></span><br><span class="line"><span class="built_in">set</span> c $<span class="title function_">day</span><span class="params">($a)</span> <span class="comment">//c 的值为 1 ，即 day(monday) 的值。</span></span><br></pre></td></tr></table></figure><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><h2 id="unset"><a href="#unset" class="headerlink" title="unset"></a>unset</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">% unset a b <span class="title function_">day</span><span class="params">(monday)</span></span><br></pre></td></tr></table></figure><p>上面的语句中删除了变量a、b和数组元素day(monday)，但是数组day并没有删除，其他元素还存在，要删除整个数组，只需给出数组的名字。</p><h2 id="append和incr"><a href="#append和incr" class="headerlink" title="append和incr"></a>append和incr</h2><p>这两个命令提供了改变变量的值的简单手段。<br><code>append</code>命令把文本加到一个变量的后面，例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">% <span class="built_in">set</span> txt hello</span><br><span class="line">hello</span><br><span class="line">% append txt <span class="string">&quot;! How are you&quot;</span></span><br><span class="line">hello! How are you</span><br></pre></td></tr></table></figure><p><code>incr</code>命令把一个变量值加上一个整数。incr要求变量原来的值和新加的值都必须是整数。</p><h2 id="expr"><a href="#expr" class="headerlink" title="expr"></a>expr</h2><p>可以进行基本的数学函数计算</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%expr <span class="number">1</span> ＋ <span class="number">2</span>*<span class="number">3</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>list这个概念在<code>TCL</code>中是用来表示集合的。<code>TCL</code>中list是由一堆元素组成的有序集合，list可以嵌套定<br>义，list每个元素可以是任意字符串，也可以是list。下面都是<code>TCL</code>中的合法的list：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;&#125; <span class="comment">//空list</span></span><br><span class="line">&#123;a b c d&#125;</span><br><span class="line">&#123;a &#123;b c&#125; d&#125; <span class="comment">//list可以嵌套</span></span><br></pre></td></tr></table></figure><p>list是<code>TCL</code>中比较重要的一种数据结构，对于编写复杂的脚本有很大的帮助</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>语法： list ? value value…?</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">这个命令生成一个<span class="built_in">list</span>，<span class="built_in">list</span>的元素就是所有的value。例：</span><br><span class="line">% <span class="built_in">list</span> <span class="number">1</span> <span class="number">2</span> &#123;<span class="number">3</span> <span class="number">4</span>&#125;</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> &#123;<span class="number">3</span> <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><p>使用置换将其相结合</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">% <span class="built_in">set</span> a &#123;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> &#123;<span class="number">1</span> <span class="number">2</span>&#125;&#125;</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> &#123;<span class="number">1</span> <span class="number">2</span>&#125;</span><br><span class="line">% <span class="built_in">puts</span> $a </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> &#123;<span class="number">1</span> <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><p>语法:concat list ?list…?<br>这个命令把多个list合成一个list，每个list变成新list的一个元素。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">% <span class="built_in">set</span> a &#123;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>&#125;</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">% <span class="built_in">set</span> a &#123;<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>&#125;</span><br><span class="line"> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">% concat $a $b</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="lindex"><a href="#lindex" class="headerlink" title="lindex"></a>lindex</h2><p>语法：lindex list index<br>返回list的第index个(0-based)元素。例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">% lindex &#123;<span class="number">1</span> <span class="number">2</span> &#123;<span class="number">3</span> <span class="number">4</span>&#125;&#125; <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="llength"><a href="#llength" class="headerlink" title="llength"></a>llength</h2><p>语法：llength list<br>返回list的元素个数。例</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">% llength &#123;<span class="number">1</span> <span class="number">2</span> &#123;<span class="number">3</span> <span class="number">4</span>&#125;&#125;</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">% <span class="keyword">set</span> a &#123;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>&#125;</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">% llength $a </span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="linsert"><a href="#linsert" class="headerlink" title="linsert"></a>linsert</h2><p>语法：linsert list index value ?value…?<br>返回一个新串，新串是把所有的value参数值插入list的第index个(0-based)元素之前得到。例:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">% linsert &#123;<span class="number">1</span> <span class="number">2</span> &#123;<span class="number">3</span> <span class="number">4</span>&#125;&#125; <span class="number">1</span> <span class="number">7</span> <span class="number">8</span> &#123;<span class="number">9</span> <span class="number">10</span>&#125;</span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">8</span> &#123;<span class="number">9</span> <span class="number">10</span>&#125; <span class="number">2</span> &#123;<span class="number">3</span> <span class="number">4</span>&#125;</span><br><span class="line">% linsert &#123;<span class="number">1</span> <span class="number">2</span> &#123;<span class="number">3</span> <span class="number">4</span>&#125;&#125; <span class="number">1</span> &#123;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> &#123;<span class="number">4</span> <span class="number">5</span>&#125;&#125;</span><br><span class="line"><span class="number">1</span> &#123;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> &#123;<span class="number">4</span> <span class="number">5</span>&#125;&#125; <span class="number">2</span> &#123;<span class="number">3</span> <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">% <span class="keyword">set</span> a &#123;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>&#125;</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">% linsert $a <span class="number">1</span> &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125;</span><br><span class="line"><span class="number">1</span> &#123;<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125; <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="lreplace"><a href="#lreplace" class="headerlink" title="lreplace"></a>lreplace</h2><p>语法：lreplace list first last ?value value …?<br>返回一个新串，新串是把list的第firs (0-based)t到第last 个(0-based)元素用所有的value参数替换得到的。如果没有value参数，就表示删除第first到第last个元素。例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">% lreplace &#123;<span class="number">1</span> <span class="number">7</span> <span class="number">8</span> &#123;<span class="number">9</span> <span class="number">10</span>&#125; <span class="number">2</span> &#123;<span class="number">3</span> <span class="number">4</span>&#125;&#125; <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">8</span> <span class="number">2</span> &#123;<span class="number">3</span> <span class="number">4</span>&#125;</span><br><span class="line">% lreplace &#123;<span class="number">1</span> <span class="number">7</span> <span class="number">8</span> <span class="number">2</span> &#123;<span class="number">3</span> <span class="number">4</span>&#125;&#125; <span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">8</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">% <span class="keyword">set</span> a &#123;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>&#125;</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">% lreplace $a <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line">% lreplace $a <span class="number">1</span> end </span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="lrange"><a href="#lrange" class="headerlink" title="lrange"></a>lrange</h2><p>语法:lrange list first last<br>返回list的第first (0-based)到第last (0-based)元素组成的串,如果last的值是end。就是从第first个直到串的最后。<br>例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">% lrange &#123;<span class="number">1</span> <span class="number">7</span> <span class="number">8</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>&#125; <span class="number">3</span> end</span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">% <span class="keyword">set</span> a &#123;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>&#125;</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">% lrange $a <span class="number">0</span> end</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="lappend"><a href="#lappend" class="headerlink" title="lappend"></a>lappend</h2><p>语法：lappend varname value ?value…?<br>把每个value的值作为一个元素附加到变量varname后面，并返回变量的新值，如果varname不存在，就生成这个变量。例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">% <span class="built_in">set</span> a &#123;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>&#125;</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">% lappend a <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="lsearch"><a href="#lsearch" class="headerlink" title="lsearch"></a>lsearch</h2><p>语法：lsearch ?-exact? ?-glob? ?-regexp? list pattern<br>返回list中第一个匹配模式pattern的元素的索引，如果找不到匹配就返回-1。-exact、-glob、 -regexp是三种模式匹配的技术。-exact表示精确匹配；-glob的匹配方式和string match命令的匹配方式相同；-regexp表示正规表达式匹配。缺省时使用-glob匹配。例:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">% <span class="built_in">set</span> a &#123; how are you &#125;</span><br><span class="line">how are you</span><br><span class="line">% lsearch $a y*</span><br><span class="line"><span class="number">2</span></span><br><span class="line">% lsearch $a y?</span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure><p>-all 返回一个列表，返回的列表中的数值就是字符在列表中的位置<br>默认全局匹配，返回第一个字符在列表中的位置，其位缺省状态</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% lsearch &#123;a b c d e&#125; c</span><br><span class="line">2</span><br><span class="line">% lsearch -all &#123;a b c a b c&#125; c</span><br><span class="line">2 5</span><br><span class="line">% lsearch &#123;a b c d c&#125; c</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>匹配不到返回-1</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">% lsearch &#123;a b c d e&#125; g</span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure><p>更详细的<a href="https://blog.csdn.net/dulixin/article/details/2185458?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task">点击</a> 查看。</p><h1 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h1><p>这里有之后学习的更加详细的笔记，主要是对于所有的控制流，包括 if、while、for、foreach、switch、break、continue 等以及过程，source的介绍总结<br><a href="https://tyxiumud.github.io/posts/deed0e8e9628/">TCL脚本语言的学习（二）</a>更为详细！！</p><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>语法： if test1 body1 ?elseif test2 body2 elseif…. ? ?else bodyn?<br><code>TCL</code>先把test1当作一个表达式求值，如果值非0，则把body1当作一个脚本执行并返回所得值，否则把test2当作一个表达式求值，如果值非0，则把body2当作一个脚本执行并返回所得值……。例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> &#123; $x&gt;<span class="number">0</span> &#125; &#123;</span><br><span class="line">.....</span><br><span class="line">&#125;elseif&#123; $x==<span class="number">1</span> &#125; &#123;</span><br><span class="line">.....</span><br><span class="line">&#125;elseif &#123; $x==<span class="number">2</span> &#125; &#123;</span><br><span class="line">....</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> &#123; $x&lt;<span class="number">0</span> &#125; &#123;</span><br><span class="line">  <span class="built_in">puts</span> <span class="string">&quot;x is smaller than zero&quot;</span></span><br><span class="line">&#125; elseif &#123;$x==<span class="number">1</span>&#125; &#123;</span><br><span class="line">  <span class="built_in">puts</span> <span class="string">&quot;x is equal 1&quot;</span></span><br><span class="line">&#125; elseif &#123;$x==<span class="number">2</span>&#125; &#123;</span><br><span class="line">  <span class="built_in">puts</span> <span class="string">&quot;x is equal 2&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">puts</span> <span class="string">&quot;x is other&quot;</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="循环命令：while-、for-、-foreach"><a href="#循环命令：while-、for-、-foreach" class="headerlink" title="循环命令：while  、for 、 foreach"></a>循环命令：while  、for 、 foreach</h2><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>语法为: while test body<br>参数test是一个表达式，body是一个脚本，如果表达式的值非0，就运行脚本，直到表达式为0才停止循环，此时while命令中断并返回一个空字符串。<br>例如：假设变量 a 是一个链表，下面的脚本把a 的值复制到b：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">% <span class="comment">#首先生成一个集合</span></span><br><span class="line">% <span class="built_in">set</span> a &#123;1 2 3 4&#125;</span><br><span class="line">1 2 3 4</span><br><span class="line">% <span class="built_in">set</span> b <span class="string">&quot; &quot;</span></span><br><span class="line"> </span><br><span class="line">% <span class="comment">#计算生成集合的长度（从0开始这里需要减去1例如：0-3一共有四个数）</span></span><br><span class="line">% <span class="built_in">set</span> i [<span class="built_in">expr</span> [llength <span class="variable">$a</span>] -1]</span><br><span class="line">3</span><br><span class="line"><span class="comment">#接下来进行判断，将集合a中的元素全部按顺序写入b中</span></span><br><span class="line">% <span class="keyword">while</span> &#123;<span class="variable">$i</span>&gt;=0&#125; &#123;</span><br><span class="line"><span class="comment">#思考执行该行代码替换会有怎样的结果打印出来</span></span><br><span class="line"><span class="comment">#lappend b [lindex $a $i]</span></span><br><span class="line">lappend b [lindex <span class="variable">$a</span> [<span class="built_in">expr</span> [llength <span class="variable">$a</span>] - 1 - <span class="variable">$i</span>]]</span><br><span class="line">incr i -1</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#打印观察结果</span></span><br><span class="line">% puts <span class="variable">$b</span></span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>语法为: for init test reinit body<br>参数init是一个初始化脚本，第二个参数test是一个表达式，用来决定循环什么时候中断，第三个参数reinit是一个重新初始化的脚本，第四个参数body也是脚本，代表循环体。下例与上例作用相同：（注意这里复制打印顺序的不同）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%  <span class="built_in">set</span> a &#123;1 2 3 4&#125;</span><br><span class="line">1 2 3 4</span><br><span class="line">% <span class="built_in">set</span> b <span class="string">&quot; &quot;</span></span><br><span class="line"> </span><br><span class="line">% <span class="keyword">for</span> &#123;<span class="built_in">set</span> i [<span class="built_in">expr</span> [llength <span class="variable">$a</span>] -1]&#125; &#123;<span class="variable">$i</span>&gt;=0&#125; &#123;incr i -1&#125; &#123;</span><br><span class="line">lappend b [lindex <span class="variable">$a</span> <span class="variable">$i</span>] &#125;</span><br><span class="line">% puts <span class="variable">$b</span></span><br><span class="line">4 3 2 1</span><br></pre></td></tr></table></figure><p>例</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">% <span class="keyword">for</span> &#123;<span class="keyword">set</span> i <span class="number">0</span>&#125; &#123;$i&lt;<span class="number">4</span>&#125; &#123;incr i&#125; &#123;</span><br><span class="line">    puts <span class="string">&quot;I is: $i &quot;</span></span><br><span class="line">&#125;</span><br><span class="line">I <span class="keyword">is</span>: <span class="number">0</span> </span><br><span class="line">I <span class="keyword">is</span>: <span class="number">1</span> </span><br><span class="line">I <span class="keyword">is</span>: <span class="number">2</span> </span><br><span class="line">I <span class="keyword">is</span>: <span class="number">3</span> </span><br></pre></td></tr></table></figure><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>这个命令有两种语法形式<br>1, <code>foreach varName list body</code><br>第一个参数varName是一个变量，第二个参数list 是一个表(有序集合)，第三个参数body是循环体。每次取得链表的一个元素，都会执行循环体一次。 下例与上例作用相同：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">% <span class="built_in">set</span> a &#123;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&#125;</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">% <span class="built_in">set</span> b <span class="string">&quot; &quot;</span></span><br><span class="line"> </span><br><span class="line">% foreach i $a &#123;</span><br><span class="line"><span class="built_in">set</span> b [linsert $b <span class="number">0</span> $i]</span><br><span class="line">&#125;</span><br><span class="line">% <span class="built_in">puts</span> $b</span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">% <span class="keyword">foreach</span> <span class="keyword">var</span> &#123;a b c d e f&#125; &#123;</span><br><span class="line">puts $<span class="keyword">var</span></span><br><span class="line">&#125;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">f</span><br></pre></td></tr></table></figure><p>2, <code>foreach varlist1 list1 ?varlist2 list2 ...? Body</code><br>这种形式包含了第一种形式。第一个参数varlist1是一个循环变量列表，第二个参数是一个列表list1，varlist1中的变量会分别取list1中的值。body参数是循环体。 ?varlist2 list2 …?表示可以有多个变量列表和列表对出现。例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> x &#123;&#125;</span><br><span class="line">foreach &#123;i j&#125; &#123;a b c d e f&#125; &#123;</span><br><span class="line">lappend x $j $i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">% <span class="keyword">foreach</span> i &#123;a b c&#125; j &#123;d e f g&#125; &#123;</span><br><span class="line">puts  $i   </span><br><span class="line">puts $j</span><br><span class="line">&#125;</span><br><span class="line">a</span><br><span class="line">d</span><br><span class="line">b</span><br><span class="line">e</span><br><span class="line">c</span><br><span class="line">f</span><br><span class="line"></span><br><span class="line">g</span><br></pre></td></tr></table></figure><p>这时总共有三次循环，x的值为”b a d c f e”。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> x &#123;&#125;</span><br><span class="line"><span class="keyword">foreach</span> i &#123;a b c&#125; j &#123;d e f g&#125; &#123;</span><br><span class="line">lappend x $i $j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时总共有四次循环， x的值为”a d b e c f {} g” 。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> x &#123;&#125;</span><br><span class="line"><span class="keyword">foreach</span> i &#123;a b c&#125; &#123;j k&#125; &#123;d e f g&#125; &#123;</span><br><span class="line">lappend x $i $j $k</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时总共有三次循环，x的值为”a d e b f g c {} {}”。<br>例子：<br><img src="https://img-blog.csdnimg.cn/2cb2ebf42b3a429d9ab0b798b8effc87.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文参考资料为《&lt;code&gt;TCL&lt;/code&gt;语言教程》，感谢作者的分享，这里仅仅作为简单常用语法的入门，若有需要后期对本文进行添加补充。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言（TCL综述）&quot;&gt;&lt;a href=&quot;#前言（TCL</summary>
      
    
    
    
    <category term="DC" scheme="https://guodongblog.com/categories/DC/"/>
    
    <category term="TCL" scheme="https://guodongblog.com/categories/DC/TCL/"/>
    
    
    <category term="TCL" scheme="https://guodongblog.com/tags/TCL/"/>
    
  </entry>
  
  <entry>
    <title>个人博客搭建与美化</title>
    <link href="https://guodongblog.com/posts/b0fabd94caa6/"/>
    <id>https://guodongblog.com/posts/b0fabd94caa6/</id>
    <published>2022-05-07T08:55:14.000Z</published>
    <updated>2022-05-18T16:16:21.103Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>博主并不是很了解前端知识，只是想搭建一个自己的平台，留下自己的一点痕迹，有一个属于自己的网络小小天地。因此对于博客配置也是很简单的配置，博客也相对比较简单，基本上为小白白，因此教程笔记应该是很好复现的。有任何问题欢迎留言评论~</p></blockquote><h1 id="基础框架搭建"><a href="#基础框架搭建" class="headerlink" title="基础框架搭建"></a>基础框架搭建</h1><p>基础配置部分不进行介绍，参考官方的手册<a href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安装文档(一) 快速开始</a>，这里进行一些重要的点的总结</p><h2 id="关于主题配置文件-config-yml"><a href="#关于主题配置文件-config-yml" class="headerlink" title="关于主题配置文件_config.yml"></a>关于主题配置文件<code>_config.yml</code></h2><p>在 <code>hexo</code> 的根目录创建一个文件 <code>_config.butterfly.yml</code>，并把主题目录的 <code>_config.yml</code> 内容复製到 <code>_config.butterfly.yml</code> 去。( 注意: 复製的是主题的 <code>_config.yml</code> ,而不是 <code>hexo</code> 的 <code>_config.yml</code>)_<br><em>注意： 不要把主题目录的 <code>_config.yml</code> 删掉<br>注意： 以后只需要在 <code>_config.butterfly.yml</code>进行配置就行。<br>如果使用了 <code>_config.butterfly.yml</code>， 配置主题的 <code>_config.yml</code> 将不会有效果。</em><br><code>Hexo</code>会自动合并主题中的<code>_config.yml</code>和 <code>_config.butterfly.yml</code>里的配置，如果存在同名配置，会使用<code>_config.butterfly.yml</code>的配置，其优先度较高。</p><h2 id="hexo-的-config-yml配置"><a href="#hexo-的-config-yml配置" class="headerlink" title="hexo 的 _config.yml配置"></a><code>hexo</code> 的 <code>_config.yml</code>配置</h2><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>需要安装插件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>下面是博主部署的配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  - type: git</span><br><span class="line">    repo: git@github.com:tyxiumud/tyxiumud.github.io.git</span><br><span class="line">    ## 库地址</span><br><span class="line">    branch: gh-pages</span><br><span class="line">    ## 分支名称</span><br><span class="line">  - type: git</span><br><span class="line">    repo: https://gitee.com/xiumud/xiumud.git</span><br><span class="line">    branch: gh-pages</span><br></pre></td></tr></table></figure><p>然后使用默认三连即可</p><p>预览三连： <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code></p><p>部署三连： <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></p><p>参考：<a href="https://hexo.io/docs/one-command-deployment">https://hexo.io/docs/one-command-deployment</a></p><h3 id="检查url配置"><a href="#检查url配置" class="headerlink" title="检查url配置"></a>检查url配置</h3><ul><li>url应该是你的地址</li><li>permalink建议设置为如下形式，就是静态地址的形式</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url: https://tyxiumud.github.io</span><br><span class="line">permalink: posts/:hash/</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br></pre></td></tr></table></figure><p>实例如下，需要首先安装</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  - type: git</span><br><span class="line">    repo: git@github.com:tyxiumud/tyxiumud.github.io.git</span><br><span class="line">    ## 库地址</span><br><span class="line">    branch: gh-pages</span><br><span class="line">    ## 分支名称</span><br><span class="line">  - type: git</span><br><span class="line">    repo: https://gitee.com/xiumud/xiumud.git</span><br><span class="line">    branch: gh-pages</span><br></pre></td></tr></table></figure><h1 id="进阶部分"><a href="#进阶部分" class="headerlink" title="进阶部分"></a>进阶部分</h1><h2 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h2><p>本博客使用的是<code>Twikoo</code>，<code>Vercel</code>部署，免费，缺点是速度慢…..具体程度可以参考本网站的底部的评论。</p><p>再说说好处，教程很全，有对应的QQ群进行交流，作者的<a href="https://www.bilibili.com/video/BV1Fh411e7ZH">部署教程</a>。很快捷的定义邮箱通知评论，评论管理方便。点击齿轮即可进行配置。页面很友好。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220512193458618.png"></p><h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2><p>Butterfly主题如果需要使用到很多图片。尤其是访问github或者gitee总是速度不是很快。图片太大，会严重拖慢网站的加载速度。图片压缩能够有效的缓解这个问题。</p><ul><li><a href="https://tinypng.com/">在线网站</a>可以进行线上图片文件的的压缩。对于图床推荐使用<code>imgbot</code>进行整个图床的压缩。</li><li><a href="https://github.com/marketplace/imgbot">imgbot</a>是一款 Github 插件。安装后，你上传图片到 Github 去，imgbot 会自动压缩图片并推送 PR，只需要合并PR 就行你可以配置 imgbot 的侦测方法、压缩方法（有损&#x2F;无损），具体可以查看插件的文档。</li><li><a href="https://saerasoft.com/caesium/">caesium</a>本地软件图片压缩<br>建议使用网站或者本地软件将网站使用的图片压缩，使用imgbot用来图床文件的压缩。</li></ul><h1 id="定制化功能实现"><a href="#定制化功能实现" class="headerlink" title="定制化功能实现"></a>定制化功能实现</h1><h2 id="Hexo-Butterfly添加音乐播放器"><a href="#Hexo-Butterfly添加音乐播放器" class="headerlink" title="Hexo-Butterfly添加音乐播放器"></a>Hexo-Butterfly添加音乐播放器</h2><p>改部分分为两个小节，普通音乐播放与全局固定模式。效果演示如下所示，配置添加方式详见请<a class="btn-beautify " href="https://tyxiumud.github.io/posts/91597d56b19f/"   title="点击这里"><span>点击这里</span></a></p><h3 id="普通界面播放器"><a href="#普通界面播放器" class="headerlink" title="普通界面播放器"></a>普通界面播放器</h3><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220512145018965.png" alt="普通界面播放器"></p><h3 id="全局吸底Aplayer模式"><a href="#全局吸底Aplayer模式" class="headerlink" title="全局吸底Aplayer模式"></a>全局吸底Aplayer模式</h3><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/20220512151140.png" alt="全局吸底Aplayer模式"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 隐藏 Aplayer 的全局吸底音乐标签，在css中添加 */</span><br><span class="line">.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body &#123;</span><br><span class="line">    left: -66px !important</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover &#123;</span><br><span class="line">    left: 0 !important</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="页脚的美化"><a href="#页脚的美化" class="headerlink" title="页脚的美化"></a>页脚的美化</h2><h3 id="实现跳动的心功能"><a href="#实现跳动的心功能" class="headerlink" title="实现跳动的心功能"></a>实现跳动的心功能</h3><p>实现效果如下</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220512180706770.png"><br>实现方式：添加下述代码，到<code>themes\butterfly\layout\includes\footer.pug</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;i id=&quot;heartbeat&quot; class=&quot;fa fas fa-heartbeat&quot;&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure><p>将其复制到By与<code>$&#123;config.author&#125;</code>的中间，注意第6与第8行均需要复制，然后将如下指令复制到文件的最后一行即可。或者将By删除也是可以的，具体看自己喜好。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220512180533190.png"></p><p>参考：<a href="https://blog.csdn.net/weixin_42429718/article/details/105723193">https://blog.csdn.net/weixin_42429718/article/details/105723193</a></p><h3 id="页脚年份与版权设置"><a href="#页脚年份与版权设置" class="headerlink" title="页脚年份与版权设置"></a>页脚年份与版权设置</h3><p>在custom_text:项下输入如下指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#博客年份</span><br><span class="line">footer:</span><br><span class="line">  owner:</span><br><span class="line">    enable: true</span><br><span class="line">    since: 2022</span><br><span class="line">  copyright: false # Copyright of theme and framework    </span><br><span class="line">  custom_text: &lt;p&gt;  &lt;a style=&quot;margin-inline:5px&quot; target=&quot;_blank&quot; href=&quot;https://hexo.io/&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo&quot; title=&quot;博客框架为Hexo&quot;&gt;&lt;/a&gt;  &lt;a style=&quot;margin-inline:5px&quot; target=&quot;_blank&quot; href=&quot;https://butterfly.js.org/&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender&quot; title=&quot;主题采用butterfly&quot;&gt;&lt;/a&gt;&lt;a style=&quot;margin-inline:5px&quot; target=&quot;_blank&quot; href=&quot;https://github.com/&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub&quot; title=&quot;本站项目由Gtihub托管&quot;&gt;&lt;/a&gt;&lt;a style=&quot;margin-inline:5px&quot; target=&quot;_blank&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris&quot; title=&quot;本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可&quot;&gt;&lt;/a&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.cnblogs.com/yyyzyyyz/p/15542401.html">https://www.cnblogs.com/yyyzyyyz/p/15542401.html</a></p><h2 id="鼠标样式"><a href="#鼠标样式" class="headerlink" title="鼠标样式"></a>鼠标样式</h2><p>参考<a href="https://yyyzyyyz.cn/posts/2d51c9bd3490/#%E5%AE%89%E8%A3%85rss%E6%8F%92%E4%BB%B6%E7%94%9F%E6%88%90atom-xml%E6%96%87%E4%BB%B6">yyyz</a>的设置。在我的<code>themes\butterfly\source\css</code>目录下新建一个css文件。命名为my.css</p><p>写入如下内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*指针样式*/</span><br><span class="line">body &#123;</span><br><span class="line">    cursor: url(https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/default.cur),</span><br><span class="line">        default;</span><br><span class="line">&#125;</span><br><span class="line">/*链接小手样式*/</span><br><span class="line">a,</span><br><span class="line">img &#123;</span><br><span class="line">    cursor: url(https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/pointer.cur),</span><br><span class="line">        default;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主题配置文件中引入即可。下面是我自己的配置，使用时根据自己的css名称进行修改</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inject:</span><br><span class="line">  head:</span><br><span class="line">    - &lt;link rel=&quot;stylesheet&quot; href= &quot;/css/my.css&quot;&gt;</span><br><span class="line">  bottom:</span><br><span class="line">    #- &lt;script src=&quot;/js/catch-the-cat.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    #- &lt;div class=&quot;aplayer no-destroy&quot; data-id=&quot;7422861869&quot; data-server=&quot;netease&quot; data-type=&quot;playlist&quot; data-fixed=&quot;true&quot; data-autoplay=&quot;true&quot; data-lrcType=&quot;-1&quot;&gt; &lt;/div&gt; </span><br></pre></td></tr></table></figure><p>参考：<a href="https://yyyzyyyz.cn/posts/2d51c9bd3490/">https://yyyzyyyz.cn/posts/2d51c9bd3490/</a></p><h2 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h2><p>修改字体样式直接引入css文件和字体包即可。</p><p>1、首先寻找喜欢的字体，有些字体很好看并且是免费非商用的，我们可以拿来用。</p><p>这里推荐几个网址供参考：<a href="https://www.foundertype.com/">方正字库</a>，<a href="https://www.diyiziti.com/">第一字体网</a>，字体天下，字体家，<a href="https://ziyouziti.com/">自由字体</a></p><p>2、将需要使用的字体文件放入博客目录下，我这里是放在<code>themes\butterfly\source\css</code>下，方便css文件引入。</p><p>3、如有有css文件，就在最下面继续写；如果没有，则新建一个css文件，文件名任取。写入保存。引用方式同鼠标样式引入方式一致。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@font-face&#123;</span><br><span class="line">  font-family: &#x27;FZQianLXSJW&#x27; ;  /* 自定义字体名称 */</span><br><span class="line">  src: url(FZQianLXSJW.tff); /* 引入字体文件的路径 */</span><br><span class="line">&#125;</span><br><span class="line">/*应用在body体里，放在第一个，font-family会按顺序使用字体族。如果第一个没找到就会找第二个，以此类推。*/</span><br><span class="line">body &#123;</span><br><span class="line">font-family: FZQianLXSJW,-apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, &quot;Helvetica Neue&quot;, Lato, Roboto, &quot;PingFang SC&quot;, &quot;STZhongsong&quot;, &quot;Lantinghei SC&quot;, sans-serif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将你的字体放在你的根目录下 <code>themes\butterfly</code></p><p>参考：<a href="https://yyyzyyyz.cn/posts/2d51c9bd3490/">https://yyyzyyyz.cn/posts/2d51c9bd3490/</a></p><h2 id="About-Me-自我介绍botui机器人"><a href="#About-Me-自我介绍botui机器人" class="headerlink" title="About Me-自我介绍botui机器人"></a>About Me-自我介绍botui机器人</h2><p>页面效果<a class="btn-beautify " href="https://tyxiumud.github.io/about//"   title="点击查看"><span>点击查看</span></a></p><p>代码如下，自行下载<code>srcJelly.js</code>文件即可，这里放在githhub或者是放在本地都是可以的。放在本地就是将其放置在<code>themes\butterfly\source\js</code>如下目录即可。下载地址<a href="https://github.com/tyxiumud/tyxiumud.github.io/blob/gh-pages/js/jelly.js">点击这里</a>。内容如下，将其修改为你想修改的即可。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220512190836724.png"></p><p>修改对应的<code>index.xml</code>文件如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220512190346063.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;entry-content&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;hello-mashiro&quot; class=&quot;popcontainer&quot; style=&quot;min-height: 300px; padding: 2px 6px 4px; background-color: rgba(242, 242, 242, 0.5); border-radius: 10px;&quot;&gt;</span><br><span class="line">    &lt;center&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;h4&gt;</span><br><span class="line">    与&amp;nbsp;&lt;ruby&gt;</span><br><span class="line">    Jelly&amp;nbsp;&lt;rp&gt;</span><br><span class="line">    （&lt;/rp&gt;</span><br><span class="line">    &lt;rp&gt;</span><br><span class="line">    ）&lt;/rp&gt;</span><br><span class="line">    &lt;/ruby&gt;</span><br><span class="line">    通话中：&lt;/h4&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;/center&gt;</span><br><span class="line">    &lt;bot-ui&gt;&lt;/botui&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;../js/jelly.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;link href=&quot;https://cdn.bootcss.com/botui/0.3.9/botui-theme-default.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;link href=&quot;https://cdn.bootcss.com/botui/0.3.9/botui.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/qq_35982918/article/details/106728754?spm=1001.2014.3001.8078#comments_21134639">https://blog.csdn.net/qq_35982918/article/details/106728754?spm=1001.2014.3001.8078#comments_21134639</a></p><h2 id="透明背景设置与黑暗模式下的适配"><a href="#透明背景设置与黑暗模式下的适配" class="headerlink" title="透明背景设置与黑暗模式下的适配"></a>透明背景设置与黑暗模式下的适配</h2><p>css文件如下。可以新建一个，也可以直接写入之前的文件里。使用vscode可以查看基本的形式。使用F12，分析网页元素来进行查看对应的样式，需要有一丢丢前端的基础。不会的可以直接使用博主提供给的css文件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*文章页背景*//*分类页面*//*时间轴页面*/</span><br><span class="line">.layout #post, .layout #page , .layout #archive , .layout #category&#123;</span><br><span class="line">    /* 以下代表透明度为0.5 可以自行修改*/</span><br><span class="line">background:rgba(255, 255, 255, .9);</span><br><span class="line">&#125;</span><br><span class="line">/*侧边栏页面*/</span><br><span class="line">#aside-content .sticky_layout .card-widget , #aside-content .card-widget&#123;</span><br><span class="line">    background: rgba(255,255,255,.8);</span><br><span class="line">&#125;</span><br><span class="line">/* 所有页面背景 */</span><br><span class="line">#recent-posts&gt;.recent-post-item, .read-mode .layout_post&gt;#post&#123;</span><br><span class="line">    /* 以下代表透明度为0.5 */</span><br><span class="line">    background: rgba(255,255,255,.8);</span><br><span class="line">&#125;</span><br><span class="line">#page-header #nav &#123;</span><br><span class="line">    /* 以下代表透明度为0.5 */</span><br><span class="line">    background: transparent!important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*以下是封面图透明*/</span><br><span class="line">#page-header.full_page::before &#123;</span><br><span class="line">    background-color: transparent!important;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">/*文章页背景*//*分类页面*//*时间轴页面*/</span><br><span class="line">[data-theme = dark] .layout&gt;#post,[data-theme = dark] .layout #page ,[data-theme = dark] .layout #archive ,[data-theme = dark] .layout&gt;#category&#123;</span><br><span class="line">    /* 以下代表透明度为0.5 可以自行修改*/</span><br><span class="line">background:rgba(0, 0, 0, 0.9);</span><br><span class="line">    &#125;   </span><br><span class="line">/*侧边栏页面*/</span><br><span class="line">[data-theme = dark] #aside-content .sticky_layout .card-widget , [data-theme = dark] #aside-content .card-widget&#123;</span><br><span class="line">    background:rgba(0, 0, 0, 0.9);</span><br><span class="line">&#125;</span><br><span class="line">/* 所有页面背景 */</span><br><span class="line">[data-theme = dark] #recent-posts&gt;.recent-post-item,[data-theme = dark]  .read-mode .layout_post&gt;#post&#123;</span><br><span class="line">    /* 以下代表透明度为0.5 */</span><br><span class="line">    background:rgba(0, 0, 0, 0.9);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面提供两种方式进行查看配置。可以帮助根据需要查看修改自己的配置。</p><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">方式1</button></li><li class="tab"><button type="button" data-href="#-2">方式2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><p>使用F12查找样式的方式</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220513025455335.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><p>使用vscode查看样式</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220513031105754.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>参考：</p><p><a href="https://www.cnblogs.com/glory-yl/p/15399411.html">https://www.cnblogs.com/glory-yl/p/15399411.html</a></p><p><a href="https://www.yyyzyyyz.cn/posts/2d51c9bd3490/#%E5%9B%BE%E7%89%87%E9%80%8F%E6%98%8E%E5%BA%A6%E4%BF%AE%E6%94%B9">https://www.yyyzyyyz.cn/posts/2d51c9bd3490/#%E5%9B%BE%E7%89%87%E9%80%8F%E6%98%8E%E5%BA%A6%E4%BF%AE%E6%94%B9</a></p><h2 id="随机背景"><a href="#随机背景" class="headerlink" title="随机背景"></a>随机背景</h2><p>在 bottom 处插入以下代码。在 backimg 数组里替换自己想要的图片链接。即可。实现效果参见笔者的博客。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inject:</span><br><span class="line">  head:</span><br><span class="line">  bottom:</span><br><span class="line">    - &lt;script&gt; let backimg =[&quot;url(/img/background.png)&quot;,&quot;url(/img/background1.png)&quot;,&quot;url(/img/background2.png)&quot;];let index =Math.ceil(Math.random() * (backimg.length));document.getElementById(&quot;web_bg&quot;).style.backgroundImage = backimg[index]&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>推荐两个网站，可以下载高清图片，记得使用上述的压缩软件进行图片的压缩。</p><p>参考：</p><p><a href="https://zfe.space/post/55346.html">https://zfe.space/post/55346.html</a></p><p><a href="https://akilar.top/posts/ebf20e02/#%E9%9A%8F%E6%9C%BA%E8%83%8C%E6%99%AF%E6%88%96banner%E6%95%88%E6%9E%9C">https://akilar.top/posts/ebf20e02/#%E9%9A%8F%E6%9C%BA%E8%83%8C%E6%99%AF%E6%88%96banner%E6%95%88%E6%9E%9C</a></p><p>两位都是大佬~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;博主并不是很了解前端知识，只是想搭建一个自己的平台，留下自己的一点痕迹，有一个属于自己的网络小小天地。因此对于博客配置也是很简单的配置，博客也相对比较简单，基本上为小白白，因此教程笔记应该是很好复现的。有任何问题欢迎留言评论~&lt;/p&gt;
&lt;/bloc</summary>
      
    
    
    
    <category term="个人博客搭建" scheme="https://guodongblog.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="Hexo" scheme="https://guodongblog.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>基础知识之三——标准单元库</title>
    <link href="https://guodongblog.com/posts/bd5d5e54f486/"/>
    <id>https://guodongblog.com/posts/bd5d5e54f486/</id>
    <published>2022-05-06T03:44:12.000Z</published>
    <updated>2022-05-21T14:39:23.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>Synopsys_工艺库格式是事实上的库标准。对库格式和延时计算方法的基本理解是成功综合的关键Synopsys工艺库可分为两大类：<br>逻辑库：包含仅与综合过程有关的信息且通过DC用于设计的综合和优化。如pin到pin的时序、面积、引脚类型等<br>物理库：包含单元的物理特征，如物理尺寸、层信息、单元方位等。<br>半导体厂商提供给我们DC兼容的工艺技术库——<strong>综合库</strong>来进行逻辑综合。大多数情况下，半导体厂商提供二进制格式的.db文件，也有可能只提供文本(ASCII)格式的.lib文件，或两者。DC使用的综合库必须是.db格式的库。因此，如果我们只有.lib文件，需要用Library Compiler将其转换为.db文件。<br>综合库的结构如下图所示。<img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220504112821556.png" alt="综合库的结构">？<br>可以将其分为两个部分，标题部分与单元描述部分。我们使用smic180工艺下的typical.lib进行分析。<br>其中标题部分主要是介绍使用的延时模型，工艺角，库的名称等一些公共部分，后面的部分是库里单元的描述，也是这个文件的主要部分。文档一共214835行，其中第一部分一共由250行左右进行描述，剩下的都是对单元的描述。<br>对应的文本描述如下所示。下面也将通过介绍标题部分以及特定的几个单元描述来进行总结学习。参考的smic180-typical.lib。可能不同的库的内容有所不同，但都是大同小异的。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220504114613505.png" alt="单元库的文本描述"></p><h1 id="库属性部分"><a href="#库属性部分" class="headerlink" title="库属性部分"></a>库属性部分</h1><ul><li>库组(library group)</li><li>工艺库的一般属性(general attributes)</li><li>库文档资料(documentation attributes)</li><li>单位定义(unit attributes)</li></ul><h2 id="1，库组-library-Group"><a href="#1，库组-library-Group" class="headerlink" title="1，库组(library Group)"></a>1，库组(library Group)</h2><p>库组指令定义工艺库名。这个指令必须是在库文件中的第一个可执行行。例如：<br>library(my_library)<br>{<br>…}</p><h2 id="2，工艺库的一般属性-general-attributes"><a href="#2，工艺库的一般属性-general-attributes" class="headerlink" title="2，工艺库的一般属性(general attributes)"></a>2，工艺库的一般属性(general attributes)</h2><p>包括以下属性</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* general attributes */</span></span><br><span class="line">delay_model : table_lookup;</span><br><span class="line">in_place_swap_mode : match_footprint;</span><br><span class="line">library_features(report_delay_calculation);库特征 也就是这个库具有延迟计算的特征</span><br><span class="line"></span><br><span class="line">in_place_swap_mode : [match_footpoint/no_swapping];   替代交换方式 这里选的是匹配封装的方式。具体的信息可以查阅其他治疗或者询问半导体厂商。</span><br><span class="line">bus_naming_style : <span class="string">&quot;Bus***...&quot;</span>;   总线命名方式 例如：bus_naming_style:<span class="string">&quot;Bus%spin%d&quot;</span>;这个库没有进行总线规则的命名。</span><br></pre></td></tr></table></figure><h3 id="1-technology-工艺类型"><a href="#1-technology-工艺类型" class="headerlink" title="1)technology  工艺类型"></a>1)technology  工艺类型</h3><p>工艺属性定义用来区别时序分析的设计是基于那种类型的设计。目前有两种类型的设计需要时序分析，一种是ASIC设计，一种是FPGA设计。但是它们在设计流程上有很大的不同，所以在进行时序分析时也有所区别。因此工艺属性有两个设置值可以选择：CMOS和FPGA。<br>工艺属性识别库中使用的工艺类型：CMOS(预设值)、 FPGA。工艺类型必须先定义，放在属性清单的顶部。如果库中没有技术属性，Library Compiler预设其为cmos。</p><h3 id="2-in-place-swap-mode"><a href="#2-in-place-swap-mode" class="headerlink" title="2)in_place_swap_mode"></a>2)in_place_swap_mode</h3><p>设计工具需要对设计进行时序和功耗优化，最基本的方法就是把不合适的单元替换成合适的单元。但是是否可以允许设计工具进行单元替换优化操作，需要在时序信息文件中通过单元优化替换属性进行定义。因此单元优化替换属性有两个设置值可以选择：match footprint和no swapping。</p><h3 id="3-library-features"><a href="#3-library-features" class="headerlink" title="3)library_features"></a>3)library_features</h3><p>工艺库特征属性定义其他Synopsys工具可以使用具有该工艺库特征定义的命令进行设计。工艺库特征属性有5个设置值可以选择：report_delay_calculation、report_power_calculation、report_noise_calculation、report_user_data和allow_update_attribute。</p><h3 id="4-delay-model-延时模型"><a href="#4-delay-model-延时模型" class="headerlink" title="4)delay_model  延时模型"></a>4)delay_model  延时模型</h3><p>指明在计算延迟时用的那个模型，主要有generic_cmos(默认值)、table-lookup(非线性模型)、piecewise-cmos(optional)、dcm(Delay Calculation Module)、polynomial。如果库组中没有定义延时模型属性，那么默认设置是generic_cmos。<br><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505133009410.png" alt="delay_model 延时模型"></p><h4 id="a-非线性模型"><a href="#a-非线性模型" class="headerlink" title="a)非线性模型"></a>a)非线性模型</h4><p>大多数单元库都包括表格模型(table model)，用于为单元的各种时序弧指定延迟并进行时序检查。 这些表格模型被称为NLDM(Non-Linear Delay Model)，可用于延迟、输出压摆计算或其他时序检查。表格模型中提供了：在单元输入引脚处输入过渡时间和输出引脚处输出负载电容的各种组合下通过单元的延迟。<br>CMOS非线性延时计算模型(NLDM)是一种时序计算精度较高的延时计算模型。在Synopsys工艺库模型中，目前业界主要使用非线性延时计算模型。该延时模型由&#x3D;&#x3D;<strong>输入信号转换时间</strong>&#x3D;&#x3D;与&#x3D;&#x3D;<strong>输出负载</strong>&#x3D;&#x3D;作为索引，时序分析时以一个二维查找表的形式来计算延时，查找表中时序数据的实际构成如下图所示。<br><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505134501911.png" alt="查找表构成" style="zoom:80%;" /></p><p>基于非线性延时计算模型通常的计算过程为：查找表中索引参数的某个采样点延时可直接查表得出，再通过插值算法来计算延时。通过非线性延时计算模型计算所能达到的精度有赖于采样点选取的合理性以及所用的插值算法。只要采样点较为合理，采用一般的多项式插值算法就能取得较好的延时结果。延时的一般插值计算方法如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505134557942.png"></p><p>三维坐标中，X为输入端口信号的跳变时间Transition time(ns)，y为输出端负载电容值Cload(pf)，Z为延时值Tdelay(ns)，计算式为<code>Z=A+B·X+C·Y+D·X·Y</code>如果要计算X&#x3D;0.32、Y&#x3D;0.05时的Z值，只需取最接近X、Y的4个采样点。构建如下方程</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505135114504.png" alt="插值近似方程组"></p><p>A&#x3D;0.2006,B&#x3D;0.1983,C&#x3D;0.2399,D&#x3D;0.0677。带入X、Y即可</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505135214006.png" alt="延时计算"></p><p>现已经通过查找表与插值的方式计算得到了单元延时。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220506000624568.png"></p><p><code>Dc</code>是通过<code>WLM</code>(wire load model)以及<code>type_tree</code>来进行计算的，参看文章后续的这两个部分即可得到线延时。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505194504208.png"></p><p>如下图所示，计算逻辑门U1的Dcell值时，先确定输入端口的转换时间，U1输入端口的转换时间由前级单元U0的输出决定。当U0的输出为上升（rise）转换时间时，由于U1的时序弧为反向时序弧，因此U1的逻辑门延时应该在对应的U1下降时序弧查找表中进行插值计算。由于下降时序弧查找表是二维表，因此还需要确定U1输出端负载值，通过互连线负载模型和驱动节点负载值得到输出端总负载值。最后，根据U1输入端口转换时间和输出端负载电容值作为索引，在对应的U1下降时序弧二维查找表得到相应数据，并进行插值计算直接得到延时。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505213859119.png"></p><h2 id="3，库文档资料-documentation-attributes"><a href="#3，库文档资料-documentation-attributes" class="headerlink" title="3，库文档资料(documentation attributes)"></a>3，库文档资料(documentation attributes)</h2><p>主要是库的版本、库的日期、还有注释。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">revision : ***;</span><br><span class="line">date : ***;</span><br><span class="line">comment : ***;</span><br></pre></td></tr></table></figure><h2 id="4，单位定义-unit-attributes"><a href="#4，单位定义-unit-attributes" class="headerlink" title="4，单位定义(unit attributes)"></a>4，单位定义(unit attributes)</h2><p> Design Compiler工具本身是没有单位的。然而在建立工艺库和产生报告时，必须要有单位。库中有6个库级属性定义单位:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">time_unit : <span class="string">&quot;1ns&quot;</span>;   时间单位</span><br><span class="line">voltage_unit : <span class="string">&quot;1V&quot;</span>;   电压单位</span><br><span class="line">current_unit : <span class="string">&quot;1mA&quot;</span>;   电流单位</span><br><span class="line">pulling_resistance_unit : <span class="string">&quot;1kohm&quot;</span>;   上下拉电阻单位</span><br><span class="line">leakage_power_unit : <span class="string">&quot;1pW&quot;</span>;　　漏电功耗</span><br><span class="line">capacitive_load_unit : (<span class="number">1.0</span>,pf);　　电容单位</span><br></pre></td></tr></table></figure><p>单元描述中数值的单位都是在库中指定的，可使用Liberty命令集在库文件中声明单位。  </p><h1 id="环境属性部分"><a href="#环境属性部分" class="headerlink" title="环境属性部分"></a>环境属性部分</h1><ul><li>操作环境(operation conditions)</li><li>阈值定义(threshold definitions)</li><li>默认环境属性(default attributes)</li><li>模板(templates)</li><li>比例缩放因子(k-factors)</li><li>I&#x2F;Opad属性(pad attributes)</li><li>线负载模型(wire-loads)</li></ul><h2 id="1，工作条件-operation-conditions"><a href="#1，工作条件-operation-conditions" class="headerlink" title="1，工作条件(operation conditions)"></a>1，工作条件(operation conditions)</h2><p>指定了工艺、温度、电压以及RC树模型，用于设计的综合和时序分析。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505141917579.png" alt="操作环境示意"></p><p>这里就是对于库基本的情况进行了说明。会与slow.lib内容不同。主要是对于温度、电压等操作环境进行说明。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505144141794.png" alt="工作条件"></p><p>这里的工作条件与我们之前了解的PVT环境联系到了一起。</p><h3 id="1-tree-type"><a href="#1-tree-type" class="headerlink" title="1)tree_type"></a>1)tree_type</h3><p>tree type属性定义了使用的环境互连模型，DC在计算互连延迟时使用这一属性值来选择合适的公式。</p><p>对于预布局估计，可以使用以下三种不同形式来表示互连RC树。请注意，每个互连线的总长度(以及电阻和电容估计值)在这三种情况下是相同的。  </p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505142752630.png"></p><p>Best-case tree：在最佳情况树中，假定负载引脚在物理上与驱动引脚相邻。因此，到负载引脚的路径中都没有互连电阻，来自其它扇出引脚的所有互连线电容和引脚电容仍然作为驱动引脚上的负载。  </p><p>Balanced tree：在这种情况下，假定每个负载引脚都在互连线的一部分上，并且每条到达负载引脚的路径上的总电阻和电容都相等。  </p><p>Worst-case tree ：在最差情况树中，假定所有负载引脚都集中在互连线的另一端。因此，每条到负载引脚的路径上都会有全部的互连线电阻和电容。  </p><h2 id="2，阈值定义-threshold-definitions"><a href="#2，阈值定义-threshold-definitions" class="headerlink" title="2，阈值定义(threshold definitions)"></a>2，阈值定义(threshold definitions)</h2><p>压摆值(slew)基于的是在库中指定的测量阈值点，大多数上一代的库(0.25um或更旧的库)都使用10％和90％作为压摆(或称过渡时间)的测量阈值点。  </p><p>压摆阈值点的选择对应的是波形的线性部分。随着技术的发展，实际波形最线性的部分通常在30％至70％之间。 因此，大多数新一代时序库都将压摆测量阈值点指定为Vdd的30％和70％。但是，由于之前测得的过渡时间在10％至90％之间，因此在填充库时，通常将测得的30％至70％的过渡时间加倍，这由<strong>压摆降额系数</strong>(slew derate factor)指定，通常指定为0.5。压摆测量阈值点为30％和70％且压摆降额系数为0.5，等效于测量阈值点为10％和90％。 阈值设置的示例如下：  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">slew_lower_threshold_pct_fall : <span class="number">30.0</span>;</span><br><span class="line">slew_upper_threshold_pct_fall : <span class="number">70.0</span>;</span><br><span class="line">slew_lower_threshold_pct_rise : <span class="number">30.0</span>;</span><br><span class="line">slew_upper_threshold_pct_rise : <span class="number">70.0</span>;</span><br><span class="line">input_threshold_pct_fall      : <span class="number">50.0</span>;输入上升/下降沿采样点</span><br><span class="line">input_threshold_pct_rise      : <span class="number">50.0</span>;</span><br><span class="line">output_threshold_pct_fall     : <span class="number">50.0</span>;输出上升/下降沿采样点</span><br><span class="line">output_threshold_pct_rise     : <span class="number">50.0</span>;</span><br><span class="line">slew_derate_from_library      : <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505145445468.png" alt="阈值设定"></p><p>上面的设置规定了要将表格中的过渡时间乘以0.5，以获得与阈值(30%-70%)设置相对应的过渡时间。这意味着表格中的值(以及相应的索引值)实际上是10%-90%阈值点的测量值。在标定过渡时间值时，首先在30%-70%处测量，然后再把测量值外推到10％至90％((70-30)&#x2F;(90-10)&#x3D; 0.5)。  </p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505151327674.png" alt="修正后如图所示"></p><p>未指定slew_derate_from_library(默认值为1.0)，这意味着库中的过渡时间不会降额(derate)  </p><h2 id="3，默认环境属性-default-attributes"><a href="#3，默认环境属性-default-attributes" class="headerlink" title="3，默认环境属性(default attributes)"></a>3，默认环境属性(default attributes)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* default attributes */</span></span><br><span class="line">default_leakage_power_density: <span class="number">0.0</span>;</span><br><span class="line">default_cell_leakage_power: <span class="number">0.0</span>;</span><br><span class="line">default_fanout_load: <span class="number">1.0</span>;</span><br><span class="line">default_output_pin_cap: <span class="number">0.0</span>;</span><br><span class="line">default_inout_pin_cap: <span class="number">0.0035</span>;</span><br><span class="line">default_input_pin_cap: <span class="number">0.0035</span>;</span><br><span class="line">default_max_transition: <span class="number">3.0</span>;</span><br></pre></td></tr></table></figure><h3 id="1-漏电功率-leakage-power"><a href="#1-漏电功率-leakage-power" class="headerlink" title="1)漏电功率(leakage_power)"></a>1)漏电功率(leakage_power)</h3><p>大多数标准单元的设计都仅在输出或状态发生变化时才消耗功率。单元通了电但没有任何行为时，所有功耗都归因于泄漏电流(leakage current)。泄漏可能是由于MOS器件的亚阈值电流引起的，也可能是由于通过栅极氧化物的隧穿电流引起的。在以前的CMOS工艺技术中，漏电功率可以忽略不计，并且在设计过程中并不是主要考虑因素。但是，随着技术的发展，漏电功率变得越来越大，与有功功率相比，漏电功率已经无法忽略不计了。</p><p>如上所述，漏电功率主要有两个来源：MOS器件中的亚阈值电流和栅氧化物隧穿。通过使用高阈值电压单元，可以降低亚阈值电流；然而，由于高阈值电压单元的速度较低而存在一个折中(rde-of)：高阈值电压单元的漏电较小，但速度较慢。同样，低阈值电压单元的漏电较大，但速度较高。无论是使用高阈值电压还是低阈值电压的单元，栅极氧化物隧穿带来的影响都差不多。因此，控制漏电功率的可能方法是使用高阈值电压的单元。类似于在高阈值电压和标准阈值电压单元之间进行选择，设计中使用的单元强度(strength)也是一种漏电和速度之间的折中。强度较高的单元具有较高的漏电功率，但速度较高。</p><p>MOS器件的亚阈值泄漏电流与温度具有很强的非线性特性，在大多数工艺技术中，随着器件温度从25°C升高到125°C，亚阈值泄漏电流可能会增加10倍至20倍。栅极氧化物隧穿带来的影响基本不随温度或器件阈值电压而改变，在100m及以上工艺技术中可以忽略的栅极氧化物隧穿已成为65nm或更精细技术在较低温度下漏电的主要原因。例如，对于65m或更精细的工艺技术，栅极氧化物隧穿漏电量可能等于室温下的亚阈值漏电量。而在高温下，亚阈值漏电仍然是导致漏电功率的主要因素。</p><h2 id="4，模板-templates"><a href="#4，模板-templates" class="headerlink" title="4，模板(templates)"></a>4，模板(templates)</h2><p>这里提供了很多查找表的模板。</p><h3 id="1-功耗查找表模板组-power-lut-template-group"><a href="#1-功耗查找表模板组-power-lut-template-group" class="headerlink" title="1)功耗查找表模板组(power lut template group)"></a>1)功耗查找表模板组(power lut template group)</h3><p>功耗查找表模板组(power lut template group)是库组中为其他功耗相关组所调用的查找表模板，通过该模板可以构成一维到三维的查找表结构，如下所示。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505190536108.png"></p><p>如上所示存在3个不同的变量：variable1、variable2和variable3，对应的变量参数值也存在3种：total_output_net_capacitance、equal_or_opposite_output_net_capacitance和input_transition_time。通过3个索引变量index1、index2和index3的值来确定最终的功耗结果。</p><p>举例如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">power_lut_template(energy_template_7x3x3) &#123;</span><br><span class="line">  variable_1 : input_transition_time;</span><br><span class="line">  variable_2 : total_output_net_capacitance;</span><br><span class="line">  variable_3 : equal_or_opposite_output_net_capacitance;</span><br><span class="line">  index_1 (<span class="string">&quot;1000, 1001, 1002, 1003, 1004, 1005, 1006&quot;</span>);</span><br><span class="line">  index_2 (<span class="string">&quot;1000, 1001, 1002&quot;</span>);</span><br><span class="line">  index_3 (<span class="string">&quot;1000, 1001, 1002&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="b-延时查找表模板组-lu-table-template-group"><a href="#b-延时查找表模板组-lu-table-template-group" class="headerlink" title="b)延时查找表模板组(lu_table_template_group)"></a>b)延时查找表模板组(lu_table_template_group)</h3><p>延时查找表模板组(lu_table_template_group)是库组中为其他延时相关组所调用的查找表模板，通过该模板可以构成一维到三维的查找表结构，如下所示。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505190943079.png"></p><p>与功耗查找表模板组结构类似，延时查找表模板组存在3个不同的变量：variable1、variable2和variable3，其中变量参数值根据所调用的延时相关组的不同而不同，主要包括以下变量参数值：input_voltage、output_voltagefanout_number、fanout_pin_capacitance、driver_slew、input_net_transition和total_output_net_capacitance等，通过3个索引变量index 1、index2和index3的值来确定最终的延时结果。</p><p>举例如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">power_lut_template(energy_template_7x7) &#123;</span><br><span class="line">  variable_1 : input_transition_time;</span><br><span class="line">  variable_2 : total_output_net_capacitance;</span><br><span class="line">  index_1 (&quot;1000, 1001, 1002, 1003, 1004, 1005, 1006&quot;);</span><br><span class="line">  index_2 (&quot;1000, 1001, 1002, 1003, 1004, 1005, 1006&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还有很多其他的模板，不一一列举</p><h2 id="5，比例缩放因子-k-factors"><a href="#5，比例缩放因子-k-factors" class="headerlink" title="5，比例缩放因子(k-factors)"></a>5，比例缩放因子(k-factors)</h2><p>库的表征是一个耗时的过程，针对各种工艺角(process corner)对库进行表征可能需要数周的时间，工艺变量的设置使得以特定工艺角为特征的库可以用于不同工艺角的时序计算。工艺的k-系数可用于完成从特征库工艺到目标工艺的延迟降额。如上所述，降额系数的使用在时序计算期间引入了不准确性，跨工艺条件进行降额尤其不准确，因此很少采用。总而言之，指定不同工艺变量值(例如1.0或任何其它值)的唯一功能就是在少数情况下允许跨工艺条件进行降额处理。<br>与作为物理量的温度和电压不同，工艺是不可量化的变量。就数字特征和验证而言，它可能是缓慢(slow)、典型(typical)或快速(fast)的工艺之一。  工作条件(nom_process、nom_temperature和nom_voltage)指定了对库进行表征的工艺、电压和温度， 也指定了使用该库中单元的条件。如果特征和工作条件不同，则需要对延迟计算过程中获得的时序值进行降额(derate)处理， 这可以通过使用库中指定的降额系数(k-系数)来实现 。使得时序分析的结果更接近真实值。<br>当延迟计算过程中工作条件的工艺、电压或温度与库中的标称条件不同时，可使用这些系数来进行计算。注意，k_volt系数为负，这意味着延迟随着电压的增加而减小，而k_temp因子为正，这意味着延迟通常随温度的升高而增加 。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505185813416.png"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505185846312.png"></p><p>形式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* k-factors */</span><br><span class="line"> k_process_cell_leakage_power: 0;</span><br><span class="line"> k_temp_cell_leakage_power: 0;</span><br><span class="line"> k_volt_cell_leakage_power: 0;</span><br><span class="line"> k_process_internal_power: 0;</span><br><span class="line"> k_temp_internal_power: 0;</span><br><span class="line"> k_volt_internal_power: 0;</span><br><span class="line"> k_process_rise_transition: 1;</span><br><span class="line"> k_temp_rise_transition: 0;</span><br><span class="line"> k_volt_rise_transition: 0;</span><br><span class="line"> k_process_fall_transition: 1;</span><br><span class="line"> k_temp_fall_transition: 0;</span><br><span class="line"> k_volt_fall_transition: 0;</span><br><span class="line"> k_process_setup_rise: 1;</span><br><span class="line"> k_temp_setup_rise: 0;</span><br><span class="line"> k_volt_setup_rise: 0;</span><br><span class="line"> k_process_setup_fall: 1;</span><br><span class="line"> k_temp_setup_fall: 0;</span><br><span class="line"> k_volt_setup_fall: 0;</span><br><span class="line"> k_process_hold_rise: 1;</span><br><span class="line"> k_temp_hold_rise: 0;</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><h2 id="6，I-x2F-Opad属性-pad-attributes"><a href="#6，I-x2F-Opad属性-pad-attributes" class="headerlink" title="6，I&#x2F;Opad属性(pad attributes)"></a>6，I&#x2F;Opad属性(pad attributes)</h2><p>定义I&#x2F;O引脚的电平属性，告诉你输入是COMS还是TTL，什么时候达到高电平、什么时候是低电平。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* pad attributes */</span><br><span class="line">output_voltage(GENERAL) &#123;</span><br><span class="line">  vol: 0.4;</span><br><span class="line">  voh: VDD - 0.4;</span><br><span class="line">  vomin: -0.5;</span><br><span class="line">  vomax: VDD + 0.5;</span><br><span class="line">&#125;</span><br><span class="line">input_voltage(CMOS) &#123;</span><br><span class="line">  vil: 0.3 * VDD;</span><br><span class="line">  vih: 0.7 * VDD;</span><br><span class="line">  vimin: -0.5;</span><br><span class="line">  vimax: VDD + 0.5;</span><br><span class="line">&#125;</span><br><span class="line">input_voltage(TTL) &#123;</span><br><span class="line">  vil: 0.8;</span><br><span class="line">  vih: 2;</span><br><span class="line">  vimin: -0.5;</span><br><span class="line">  vimax: VDD + 0.5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7，线负载模型-wire-loads"><a href="#7，线负载模型-wire-loads" class="headerlink" title="7，线负载模型(wire-loads)"></a>7，线负载模型(wire-loads)</h2><p>在进行布局规划(floorplanning)或布局(layout)之前，可以使用线负载模型(wireload models)来估计由互连线带来的电容、电阻以及面积开销。 线负载模型可用于根据扇出数量来估计网络的长度，线负载模型取决于块(block)的面积，具有不同面积的设计可以选择不同的线负载模型。线负载模型还可以将网络的估计长度映射(map)为电阻、电容以及由于布线而产生的相应面积开销。   形式如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* wire-loads */</span></span><br><span class="line">wire_load(<span class="string">&quot;smic18_wl10&quot;</span>) &#123;</span><br><span class="line">  resistance: <span class="number">8.5e-8</span>;</span><br><span class="line">  capacitance: <span class="number">1.5e-4</span>;</span><br><span class="line">  area: <span class="number">0.7</span>;</span><br><span class="line">  slope: <span class="number">66.667</span>;</span><br><span class="line">  fanout_length(<span class="number">1</span>,<span class="number">66.667</span>);</span><br><span class="line">&#125;</span><br><span class="line">wire_load(<span class="string">&quot;smic18_wl20&quot;</span>) &#123;</span><br><span class="line">  resistance: <span class="number">8.5e-8</span>;</span><br><span class="line">  capacitance: <span class="number">1.5e-4</span>;</span><br><span class="line">  area: <span class="number">0.7</span>;</span><br><span class="line">  slope: <span class="number">133.334</span>;</span><br><span class="line">  fanout_length(<span class="number">1</span>,<span class="number">133.334</span>);</span><br><span class="line">&#125;</span><br><span class="line">wire_load(<span class="string">&quot;smic18_wl30&quot;</span>) &#123;</span><br><span class="line">  resistance: <span class="number">8.5e-8</span>;</span><br><span class="line">  capacitance: <span class="number">1.5e-4</span>;</span><br><span class="line">  area: <span class="number">0.7</span>;</span><br><span class="line">  slope: <span class="number">200.001</span>;</span><br><span class="line">  fanout_length(<span class="number">1</span>,<span class="number">200.001</span>);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>其中参数wire load定义线负载模型的名称，参数resistance定义互连线单位电阻值，参数capacitance定义互连线单位电容值，参数area定义互连线单位长度的面积值，参数slope定义扩展斜率值，参数fanout length定义对应扇出大小的互连线长度。<br><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505154443537.png"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505154453497.png"><br>至此，我们得到了互连线的电阻与电容。</p><h3 id="补充：tree-type与线负载模型的关系"><a href="#补充：tree-type与线负载模型的关系" class="headerlink" title="补充：tree-type与线负载模型的关系"></a>补充：tree-type与线负载模型的关系</h3><p>线负载模型(<code>WLM</code>)是根据连线的扇出来估算连线的RC寄生参数那么RC是如何分配呢？<br><strong>操作条件中有“tree-type’”的属性，该属性决定R和C的分配以计算时间延迟</strong>这也是tree-type与线负载模型的关系，也是笔者学习的时候不是很好理解的部分。<br>简单来说就是需要用线负载模型去计算一个R，C，那么RC是怎么影响延时的呢，就是看其在电路中的拓扑结构。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505182507290.png"></p><p>这里的图与上述tree_type部分介绍的实际上是一致的。</p><h1 id="单元描述部分"><a href="#单元描述部分" class="headerlink" title="单元描述部分"></a>单元描述部分</h1><ul><li>单元描述</li></ul><p>该部分提供了库里标准单元的描述。标准单元也可以在提供的doc下的文档中找到。文档标题如下</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505191436806.png"></p><p>这里使用几个特殊的标准单元进行学习。<code>DFFR</code>，以及<code>INV</code>。其余基本上是一致的。</p><h2 id="1，INV"><a href="#1，INV" class="headerlink" title="1，INV"></a>1，INV</h2><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505214910528.png"></p><p>lib中的描述如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cell (INVX20) &#123; </span><br><span class="line">  cell_footprint : inv;</span><br><span class="line">  area : 63.201600;</span><br><span class="line">  pin(A) &#123;</span><br><span class="line">    direction : input;</span><br><span class="line">    capacitance : 0.011338;</span><br><span class="line">  &#125;</span><br><span class="line">  pin(Y) &#123;</span><br><span class="line">    direction : output;</span><br><span class="line">    capacitance : 0.0;</span><br><span class="line">    function : &quot;(!A)&quot;;</span><br><span class="line">    internal_power() &#123;</span><br><span class="line">      ...(略)</span><br><span class="line">    &#125;</span><br><span class="line">    timing() &#123;</span><br><span class="line">      related_pin : &quot;A&quot;;</span><br><span class="line">      timing_sense : negative_unate;</span><br><span class="line">      cell_rise(delay_template_7x7) &#123;</span><br><span class="line">        index_1 (&quot;0.03, 0.1, 0.4, 0.9, 1.5, 2.2, 3&quot;);   /*input_net_transition*/</span><br><span class="line">        index_2 (&quot;0.007, 0.42, 0.77, 1.68, 2.94, 4.62, 6.23&quot;);/* total_output_net_capacitance */</span><br><span class="line">        values ( ...);/* delay */</span><br><span class="line">      &#125;</span><br><span class="line">      rise_transition(delay_template_7x7) &#123;</span><br><span class="line">        index_1 (&quot;0.03, 0.1, 0.4, 0.9, 1.5, 2.2, 3&quot;);</span><br><span class="line">        index_2 (&quot;0.007, 0.42, 0.77, 1.68, 2.94, 4.62, 6.23&quot;);</span><br><span class="line">        values (...)</span><br><span class="line">      &#125;</span><br><span class="line">      cell_fall(delay_template_7x7) &#123;</span><br><span class="line">        index_1 (&quot;0.03, 0.1, 0.4, 0.9, 1.5, 2.2, 3&quot;);</span><br><span class="line">        index_2 (&quot;0.007, 0.42, 0.77, 1.68, 2.94, 4.62, 6.23&quot;);</span><br><span class="line">        values (...);</span><br><span class="line">      &#125;</span><br><span class="line">      fall_transition(delay_template_7x7) &#123;</span><br><span class="line">        index_1 (&quot;0.03, 0.1, 0.4, 0.9, 1.5, 2.2, 3&quot;);</span><br><span class="line">        index_2 (&quot;0.007, 0.42, 0.77, 1.68, 2.94, 4.62, 6.23&quot;);</span><br><span class="line">        values ( ...);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    max_capacitance : 6.230000;</span><br><span class="line">  &#125;</span><br><span class="line">  cell_leakage_power : 504.392580;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-引脚电容"><a href="#1-引脚电容" class="headerlink" title="1)引脚电容"></a>1)引脚电容</h3><p>单元的每个输入和输出都可以在引脚（pin）上指定电容。在大多数情况下，仅为单元输入引脚指定电容，而不为输出引脚指定<br>电容，即大多数单元库中的输出引脚电容为0。  </p><h3 id="2-internal-power"><a href="#2-internal-power" class="headerlink" title="2)internal power"></a>2)internal power</h3><p>内部开关功率在单元库中被称为internal power，这是当单元的输入或输出处于活动状态时单元内部的功耗。对于组合逻辑单元，输入引脚的电平跳变会导致输出引脚的电平跳变，从而导致内部开关功耗。  </p><h3 id="3-时序模型"><a href="#3-时序模型" class="headerlink" title="3)时序模型"></a>3)时序模型</h3><p>逻辑单元的时序模型（timing model）旨在为设计中的各种单元实例（instance）提供准确的时序信息。通常会从单元的详细电路仿真中获得时序模型，用以对单元工作时的实际情况进行建模，且需要为逻辑单元的每个时序弧都建立一个时序模型。</p><p>表征反相器的两种延迟是：<br>Tr：输出上升沿延迟<br>Tf：输出下降沿延迟  </p><p>通过反相器的时序弧的延迟取决于两个因素  input_net_transition以及total_output_net_capacitance。</p><p>逻辑单元输出引脚的压摆（slew）主要取决于输出引脚电容：输出信号过渡时间会随着输出负载的增加而增加。 因此，在输入端压摆较大（输入信号过渡时间较长）的情况下，选择合适的单元类型及输出负载，可以改善输出端的压摆。  下图展示了通过调节逻辑单元的输出负载，可以改善或恶化单元输出信号过渡时间的情况。  </p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505221525284.png" alt="Slew changes going through a cell  "></p><p>一个简单的时序模型是 linear delay 模型，其中单元的延迟和输出转换时间表示为两个参数的线性函数：输入转换时间和输出负载电容。通过单元的延迟 D 的线性模型的一般形式如下所示<code>:D=D0+D1*S+D2*C</code>其中D0，D1，D2是常数，S是输入过渡时间，C是输出负载电容  </p><h2 id="2，DFFR"><a href="#2，DFFR" class="headerlink" title="2，DFFR"></a>2，DFFR</h2><p>先看文档描述如下图，可以看到有四种不同驱动强度的，对应这不同的size。我们选择DFFRX4的工艺库文件进行学习。这是一个带复位的寄存器。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505222103992.png"></p><p>我们对DFFRX4的lib内容进行学习，开始同样是cellname,area以及功耗。我们略过看时序的部分。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505223213311.png"></p><p>setup_rising指相关引脚D的上升和下降建立时间。hold_rising是对应的保持时间。这就是我们STA里说到的。这里会进行计算。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505223352898.png"></p><p>脉冲宽度检查 。对于CK引脚有了脉冲宽度的检查，也是对时钟另一种约束，类似于出现毛刺，或者是超高频，DFF就不可以正常工作，这里随着工艺会不断改变。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505223634753.png"></p><p>对于复位引脚recover与removal的时序要求如上图所示。接下来就是输出了。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505223752206.png"></p><p>首先是对功能的描述，其次就是对PIN(Q)功耗的查找表。我们重点关注时序信息。</p><p>非单边类型（non-unate）的时序弧 。(在非单边（non-unate）时序弧中，仅仅从一个输入引脚的跳变方向是无法确定输出引脚电平将如何跳变的，还要取决于其他输入引脚的状态。  )</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505225030281.png"></p><p>PIN(Q)与CK有关的传播延时。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505225202893.png"></p><p>对于Q还在引脚级别定义了功耗。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505225253967.png"></p><p>这里的时序弧类型是负单边（negative unate）类型 </p><p>如果输入引脚上的上升沿跳变导致输出引脚电平下降（或不变），而输入引脚上的下降沿跳变导致输出引脚电平上升（或不变），则时序弧为负单边（negative unate）类型 。当复位有效时候，输输出变为0的延时时间。注意这里只有下降，很好理解，当你复位的时候，要是Q是0的话，也就不需要进行动作了。同时定义了max_capacitance。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505225606750.png"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505225645466.png"></p><p>对于引脚QN的时序模型。与Q的模型很类似，这里不进行分析。</p><p>总结一下对于DFFR的时序模型。CK对于D查建立时间，保持时间。对复位查恢复撤离时间，对于Q计算传播延时，对于CK本身，查脉冲宽度。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505225811130.png"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505225934898.png"></p><p>至此，前面总结了STA的相关知识，这里对于DC综合标准单元lib库进行了学习，后续将开始<strong>时钟</strong>的学习。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h1&gt;&lt;p&gt;Synopsys_工艺库格式是事实上的库标准。对库格式和延时计算方法的基本理解是成功综合的关键Synopsys工艺库可分为两大类：&lt;br&gt;逻</summary>
      
    
    
    
    <category term="DC" scheme="https://guodongblog.com/categories/DC/"/>
    
    <category term="DC学习笔记" scheme="https://guodongblog.com/categories/DC/DC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="DC学习笔记" scheme="https://guodongblog.com/tags/DC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="STA" scheme="https://guodongblog.com/tags/STA/"/>
    
  </entry>
  
  <entry>
    <title>hexo博文写作——Typora的使用</title>
    <link href="https://guodongblog.com/posts/7ddf536be75c/"/>
    <id>https://guodongblog.com/posts/7ddf536be75c/</id>
    <published>2022-05-02T03:36:08.000Z</published>
    <updated>2022-05-18T16:16:21.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo博文写作——Typora的使用"><a href="#hexo博文写作——Typora的使用" class="headerlink" title="hexo博文写作——Typora的使用"></a>hexo博文写作——Typora的使用</h1><p>Typora是一款Markdown编辑器，可以使得你的编辑所见即所得。Typora更多的快捷键以及可以和图床<code>PicGo</code>进行联合使用(图床就是专门用来存放图片，允许你把图片对外连接的网上空间)。从而方便的进行文本编辑而不需要去关心图片的管理问题。其次使用简单，方便，保存都是在本地进行管理，可以保证数据的安全，页面简介简单，功能非常强大。<br>简单来说有以下的优点：</p><ul><li>快捷键多，文本编辑速度快</li><li>图片管理极为方便</li><li>功能强大，页面简介<br>接下来介绍安装，常用快捷键的使用，图床的设置与相关问题<h1 id="安装地址"><a href="#安装地址" class="headerlink" title="安装地址"></a>安装地址</h1><a href="https://support.typora.io/">Typora支持地址</a><br>官网<a href="https://typora.io/">下载地址</a></li></ul><h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>在Typora中，也可以使用快捷键<code>Ctrl+1（2，3，4，5，6）</code>表示相对应的标题。<code>Ctrl+0</code>表示段落。</p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>一般使用的字体如下</p><table><thead><tr><th>字体描述</th><th>快捷键</th></tr></thead><tbody><tr><td><strong>黑体</strong></td><td><code>Ctrl+B</code></td></tr><tr><td><u>下划线</u></td><td><code>Ctrl+U</code></td></tr><tr><td><del>删除线</del></td><td><code>Alt+Shift+5</code></td></tr><tr><td><em>斜体</em></td><td><code>Ctrl+Shift+I</code></td></tr></tbody></table><p>选中字体使用快捷键即可，也可以直接使用后输入文本。</p><h3 id="文本颜色与大小"><a href="#文本颜色与大小" class="headerlink" title="文本颜色与大小"></a>文本颜色与大小</h3><p>可以使用使用<code>&lt;font&gt; &lt;/font&gt;</code>标签来改变字体的颜色及大小。<br>如下：所示<br><code>&lt;font size=3 color=&quot;red&quot;&gt;字体颜色为红色，大小为3&lt;/font&gt;</code><br><code>&lt;font size=4 color=&quot;blue&quot;&gt;字体颜色为蓝色，大小为4&lt;/font&gt;</code><br><code>&lt;font size=6 color=&quot;violet&quot;&gt;字体颜色为紫罗兰，大小为6&lt;/font&gt;</code><br><font size=3 color="red">字体颜色为红色，大小为3</font><br><font size=4 color="blue">字体颜色为蓝色，大小为4</font><br><font size=6 color="violet">字体颜色为紫罗兰，大小为6</font></p><h3 id="文本高亮"><a href="#文本高亮" class="headerlink" title="文本高亮"></a>文本高亮</h3><p>使用&#x3D;&#x3D;需要高亮的文字&#x3D;&#x3D;<br>注意，这里的高亮需要打开<code>文件-&gt;偏好设置</code>进行设置。或使用快捷键<code>Ctrl+，</code>直接打开,设置如下图所示<br><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220501225730007.png"></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>使用<code>Ctrl+T</code>进行表格</p><table><thead><tr><th>说明</th><th>快捷键</th></tr></thead><tbody><tr><td>创建表格</td><td><code>Ctrl+T</code></td></tr><tr><td>删除行</td><td><code>Ctrl+Shift+Backspace</code></td></tr><tr><td>添加行</td><td><code>Ctrl+Enter</code></td></tr></tbody></table><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>可以添加有序列表与无序列表</p><table><thead><tr><th>列表</th><th>快捷键</th></tr></thead><tbody><tr><td>有序列表</td><td><code>Ctrl + Shift + [</code></td></tr><tr><td>无序列表</td><td><code>Ctrl + Shift + ]</code></td></tr></tbody></table><p>演示：</p><ol><li>有序列表1</li><li>有序列表2</li></ol><ul><li>无序列表1</li><li>无序列表2<h2 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h2>一般使用两种方式进行舒适，<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以快速使用代码栏目，使用快捷键Ctrl+Shift+K来进行设置</span><br></pre></td></tr></table></figure>较为短快捷键  <code>Ctrl+shift+</code><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2>使用三个<code>---</code>来表示分割线</li></ul><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>使用快捷键 <code>Ctrl+Shift+Q</code></p></blockquote><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>复制网址后直接使用快捷键<code>Ctrl+K</code><br>点击<a href="https://tyxiumud.github.io/">我的博客</a>跳转</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>直接使用<code>[TOC]</code>在文章的开头即可</p><h2 id="换行问题"><a href="#换行问题" class="headerlink" title="换行问题"></a>换行问题</h2><p>使用Typora的时候，直接使用Enter时候会有一个空格，需要使用shift+enter进行换行即可。举例如下：<br>直接使用Enter<br>这是第一行</p><p>这是第二行<br>使用shift+Enter进行换行<br>这是第一行<br>这是第二行</p><h2 id="图床的设置于相关问题"><a href="#图床的设置于相关问题" class="headerlink" title="图床的设置于相关问题"></a>图床的设置于相关问题</h2><h3 id="安装与配置问题"><a href="#安装与配置问题" class="headerlink" title="安装与配置问题"></a>安装与配置问题</h3><p>–建议这里使用<code>github+PicGo+CDN</code>搭建自己的图床，简单好用，免费。具体设置如下–</p><h4 id="1，下载PicGo"><a href="#1，下载PicGo" class="headerlink" title="1，下载PicGo"></a>1，下载<code>PicGo</code></h4><p>github地址：<a href="https://github.com/Molunerfinn/picgo/releases">https://github.com/Molunerfinn/picgo/releases</a><br>选择latest版本即可，下载对应的版本，笔者使用的如下<br><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220502002103441.png"><br>下载完成后安装即可。</p><h4 id="2，软件配置"><a href="#2，软件配置" class="headerlink" title="2，软件配置"></a>2，软件配置</h4><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220502002941857.png" alt="软件配置"><br>获取你github上的Token，填入即可，然后设定你的自定义域名如下<br><code>https://cdn.jsdelivr.net/gh/</code>+<code>tyxiumud/blog.img</code><br>我的仓库名称。这里仓库的建立于Token获取方式自行百度。</p><h4 id="3，在Typora中使用"><a href="#3，在Typora中使用" class="headerlink" title="3，在Typora中使用"></a>3，在Typora中使用</h4><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220502003324053.png"><br>这里验证上传选项要是验证不通过也不用担心，编辑界面可以点击图片上传或者图片会自动上传到你的仓库。</p><h4 id="4，将文章图片整理保存-建议"><a href="#4，将文章图片整理保存-建议" class="headerlink" title="4，将文章图片整理保存(建议)"></a>4，将文章图片整理保存(建议)</h4><p>数据无价，本地的或许是最安全的，每次写完一篇笔记文章建议进行对其中的图片进行保存<br><code>C:\Users\username\AppData\Roaming\Typora\typora-user-images</code>可以找到对应的图片。<img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220502003907502.png" alt="image-20220502003907502"><br>要是有需要的话将其自行整理保存即可。</p><h2 id="CSDN-转存失败问题解决"><a href="#CSDN-转存失败问题解决" class="headerlink" title="CSDN 转存失败问题解决"></a>CSDN 转存失败问题解决</h2><p>将Typora的文章转到CSDN时候会出现问题。使用如下脚本替换图片显示的方式即可。<a href="https://blog.csdn.net/weixin_43578492/article/details/117087023?spm=1001.2014.3001.8078">参考链接</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">name = &quot;文章名称&quot;</span><br><span class="line">old_path = name+&quot;.md&quot;</span><br><span class="line">new_path = name+&quot;csdn&quot;+&quot;.md&quot;</span><br><span class="line">old_file = open(old_path, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;)</span><br><span class="line">new_file = open(new_path, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line">old_line = old_file.readline()</span><br><span class="line">count = 0</span><br><span class="line"></span><br><span class="line">while old_line:</span><br><span class="line">    if &quot;![&quot; in old_line:</span><br><span class="line">        url = re.findall(&#x27;https://.*png|https://.*jpeg|https://.*jpg&#x27;, old_line)</span><br><span class="line">        img = &#x27;&lt;img src=&quot;&#x27; + url[0] + &#x27;&quot;/&gt;&#x27;</span><br><span class="line">        new_line = re.sub(&#x27;!\[.*\)&#x27;, img, old_line)</span><br><span class="line">        new_file.write(new_line)</span><br><span class="line">        print(old_line + &#x27;   ===&gt;   &#x27; + new_line)</span><br><span class="line">        count += 1</span><br><span class="line">    else:</span><br><span class="line">        new_file.write(old_line)</span><br><span class="line">    old_line = old_file.readline()</span><br><span class="line"></span><br><span class="line">old_file.close()</span><br><span class="line">new_file.close()</span><br><span class="line"></span><br><span class="line">print(&#x27;\n已成功替换&#x27; + str(count) + &#x27;处外链问题&#x27;)</span><br></pre></td></tr></table></figure><p>最后输出的文件复制到csdn即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hexo博文写作——Typora的使用&quot;&gt;&lt;a href=&quot;#hexo博文写作——Typora的使用&quot; class=&quot;headerlink&quot; title=&quot;hexo博文写作——Typora的使用&quot;&gt;&lt;/a&gt;hexo博文写作——Typora的使用&lt;/h1&gt;&lt;p&gt;Ty</summary>
      
    
    
    
    <category term="个人博客搭建" scheme="https://guodongblog.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="Typora" scheme="https://guodongblog.com/tags/Typora/"/>
    
    <category term="博文写作" scheme="https://guodongblog.com/tags/%E5%8D%9A%E6%96%87%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>用GVIM/VIM写Verilog——VIM配置分享</title>
    <link href="https://guodongblog.com/posts/d995527356d1/"/>
    <id>https://guodongblog.com/posts/d995527356d1/</id>
    <published>2022-04-30T15:47:25.000Z</published>
    <updated>2022-05-17T07:44:45.440Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用VIM或GVIＭ最基本的配置，不包含任何插件相关的设置，VIM用于写verilog，非常欢迎大家在评论区分享讨论。本文不进行插件的配置，不进行基本使用方式与使用技巧的说明，仅作为基本配置的分享交流</p></blockquote><h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> nocompatible <span class="string">&quot;不兼容vi</span></span><br><span class="line"><span class="string">syntax on  &quot;</span>语法高亮度显示 </span><br><span class="line"><span class="built_in">set</span> noerrorbells <span class="string">&quot; 不让vim发出讨厌的滴滴声 </span></span><br><span class="line"><span class="string">set shortmess=atI &quot;</span> 启动的时候不显示那个援助索马里儿童的提示 </span><br><span class="line"><span class="built_in">set</span> t_Co=256  <span class="string">&quot;开启256色支持</span></span><br><span class="line"><span class="string">set hlsearch  &quot;</span>搜索设置高亮</span><br><span class="line">colorscheme desert <span class="string">&quot;配色方案</span></span><br><span class="line"><span class="string">set background=dark &quot;</span>配置主题整体的色调，只有两个选择：dark和light（暗色调和亮色调）</span><br><span class="line">highlight Function cterm=bold,underline ctermbg=red ctermfg=green <span class="string">&quot;color set</span></span><br><span class="line"><span class="string">set nu  &quot;</span>显示行号</span><br><span class="line"><span class="built_in">set</span> relativenumber <span class="string">&quot;显示相对行号</span></span><br><span class="line"><span class="string">set cursorcolumn &quot;</span>add cursor <span class="keyword">in</span> column</span><br><span class="line"><span class="built_in">set</span> cursorline <span class="string">&quot;add cursor in line </span></span><br><span class="line"><span class="string">&quot;</span><span class="built_in">set</span> guifont=Monospace\ 16 <span class="string">&quot;gui style</span></span><br><span class="line"><span class="string">set guifont=Courier_new:h16</span></span><br><span class="line"><span class="string">set lines=35 columns=118 &quot;</span>其中lines是窗口显示的行数，columns是窗口显示的列数</span><br><span class="line">winpos 200 100 <span class="string">&quot;后面两个参数指的自屏幕左上角像素值参考位置</span></span><br><span class="line"><span class="string">set tabstop=4 &quot;</span>tab键相当于4个空格键</span><br><span class="line"><span class="built_in">set</span> expandtab <span class="string">&quot;來將 tab 转成 space  combine with tabstop</span></span><br><span class="line"><span class="string">set shiftwidth=4 &quot;</span>换行自动变为空格</span><br><span class="line"><span class="built_in">set</span> autoindent <span class="string">&quot;设置自动缩进  自动缩进，当你第一行敲 tab + 文字 回车后 下一行自动给你加个 tab </span></span><br><span class="line"><span class="string">set backspace=2 &quot;</span><span class="built_in">enable</span> backspace</span><br><span class="line"><span class="built_in">set</span> novisualbell <span class="string">&quot;不要闪烁</span></span><br><span class="line"><span class="string">set laststatus=2 &quot;</span>启动显示状态行</span><br><span class="line"><span class="built_in">set</span> encoding=utf-8 <span class="string">&quot;文件编码</span></span><br><span class="line"><span class="string">set completeopt=menu,preview,longest &quot;</span>自动补全相关的设置</span><br><span class="line"><span class="string">&quot;不要生成swap文件，当buffer被丢弃的时候隐藏它</span></span><br><span class="line"><span class="string">set local noswapfile</span></span><br><span class="line"><span class="string">set bufhidden=hide</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">inoremap ( ()&lt;ESC&gt;i</span></span><br><span class="line"><span class="string">inoremap [ []&lt;ESC&gt;i</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>ban up and also keys </span><br><span class="line"><span class="string">&quot;imap &lt;Up&gt; &lt;Nop&gt;</span></span><br><span class="line"><span class="string">&quot;</span>imap &lt;Down&gt; &lt;Nop&gt;</span><br><span class="line"><span class="string">&quot;imap &lt;Left&gt; &lt;Nop&gt;</span></span><br><span class="line"><span class="string">&quot;</span>imap &lt;Right&gt; &lt;Nop&gt;</span><br><span class="line"><span class="string">&quot;nmap &lt;Up&gt; &lt;Nop&gt;</span></span><br><span class="line"><span class="string">&quot;</span>nmap &lt;Down&gt; &lt;Nop&gt;</span><br><span class="line"><span class="string">&quot;nmap &lt;Left&gt; &lt;Nop&gt;</span></span><br><span class="line"><span class="string">&quot;</span>nmap &lt;Right&gt; &lt;Nop&gt;</span><br><span class="line"></span><br><span class="line">imap jk &lt;Esc&gt;  <span class="string">&quot;在编辑模式下使用jk替代ESC进入命令模式</span></span><br><span class="line"><span class="string">imap &lt;C-L&gt; &lt;C-X&gt;&lt;C-L&gt; “使用CTRL L 代替 CTRL X ＋CTRL L 就是整个句子的补全</span></span><br><span class="line"><span class="string">nmap ,l ^</span></span><br><span class="line"><span class="string">nmap ,r $</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>进行版权声明的设置</span><br><span class="line"><span class="string">&quot;添加或更新头</span></span><br><span class="line"><span class="string">map &lt;F3&gt; :call TitleDet()&lt;cr&gt;&#x27;s</span></span><br><span class="line"><span class="string">function AddTitle()</span></span><br><span class="line"><span class="string">    call append(0,&quot;</span>/*=============================================================================<span class="string">&quot;)</span></span><br><span class="line"><span class="string">    call append(1,&quot;</span><span class="comment">#&quot;)</span></span><br><span class="line">    call append(2,<span class="string">&quot;# Author: meng  - email@vip.qq.com&quot;</span>)</span><br><span class="line">    call append(3,<span class="string">&quot;#&quot;</span>)</span><br><span class="line">    call append(4,<span class="string">&quot;# QQ : xxxxxxxxx &quot;</span>)</span><br><span class="line">    call append(5,<span class="string">&quot;#&quot;</span>)</span><br><span class="line">    call append(6,<span class="string">&quot;# Last modified: &quot;</span>.strftime(<span class="string">&quot;%Y-%m-%d %H:%M&quot;</span>))</span><br><span class="line">    call append(7,<span class="string">&quot;#&quot;</span>)</span><br><span class="line">    call append(8,<span class="string">&quot;# Filename: &quot;</span>.<span class="built_in">expand</span>(<span class="string">&quot;%:t&quot;</span>))</span><br><span class="line">    call append(9,<span class="string">&quot;#&quot;</span>)</span><br><span class="line">    call append(10,<span class="string">&quot;# Description: &quot;</span>)</span><br><span class="line">    call append(11,<span class="string">&quot;#&quot;</span>)</span><br><span class="line">    call append(12,<span class="string">&quot;=============================================================================*/&quot;</span>)</span><br><span class="line">    echohl WarningMsg | <span class="built_in">echo</span> <span class="string">&quot;Successful in adding the copyright.&quot;</span> | echohl None</span><br><span class="line">endf</span><br><span class="line"><span class="string">&quot;更新最近修改时间和文件名</span></span><br><span class="line"><span class="string">function UpdateTitle()</span></span><br><span class="line"><span class="string">    normal m&#x27;</span></span><br><span class="line"><span class="string">    execute &#x27;/# *Last modified:/s@:.*<span class="variable">$@</span>\=strftime(&quot;</span>:\t%Y-%m-%d %H:%M<span class="string">&quot;)@&#x27;</span></span><br><span class="line"><span class="string">    normal &#x27;&#x27;</span></span><br><span class="line"><span class="string">    normal mk</span></span><br><span class="line"><span class="string">    execute &#x27;/# *Filename:/s@:.*<span class="variable">$@</span>\=&quot;</span>:\t\t<span class="string">&quot;.expand(&quot;</span>%:t<span class="string">&quot;)@&#x27;</span></span><br><span class="line"><span class="string">    execute &quot;</span>noh<span class="string">&quot;</span></span><br><span class="line"><span class="string">    normal &#x27;k</span></span><br><span class="line"><span class="string">    echohl WarningMsg | echo &quot;</span>Successful <span class="keyword">in</span> updating the copy right.<span class="string">&quot; | echohl None</span></span><br><span class="line"><span class="string">endfunction</span></span><br><span class="line"><span class="string">&quot;</span>判断前10行代码里面，是否有Last modified这个单词，</span><br><span class="line"><span class="string">&quot;如果没有的话，代表没有添加过作者信息，需要新添加；</span></span><br><span class="line"><span class="string">&quot;</span>如果有的话，那么只需要更新即可</span><br><span class="line"><span class="keyword">function</span> TitleDet()</span><br><span class="line">    <span class="built_in">let</span> n=1</span><br><span class="line">    <span class="string">&quot;默认为添加</span></span><br><span class="line"><span class="string">    while n &lt; 10</span></span><br><span class="line"><span class="string">        let line = getline(n)</span></span><br><span class="line"><span class="string">        if line =~ &#x27;^\#\s*\S*Last\smodified:\S*.*$&#x27;</span></span><br><span class="line"><span class="string">            call UpdateTitle()</span></span><br><span class="line"><span class="string">            return</span></span><br><span class="line"><span class="string">        endif</span></span><br><span class="line"><span class="string">        let n = n + 1</span></span><br><span class="line"><span class="string">    endwhile</span></span><br><span class="line"><span class="string">    call AddTitle()</span></span><br><span class="line"><span class="string">endfunction</span></span><br></pre></td></tr></table></figure><h1 id="几点说明"><a href="#几点说明" class="headerlink" title="几点说明"></a>几点说明</h1><h2 id="1，禁用方向键，使用-jk-代替ESC"><a href="#1，禁用方向键，使用-jk-代替ESC" class="headerlink" title="1，禁用方向键，使用 jk 代替ESC"></a>1，禁用方向键，使用 jk 代替ESC</h2><p>在VIN中操作，为了使得双手脱离键盘，但是方向键距离手指较远，ESC同样，因此禁用掉方向键，同时使用jk代替ESC进入命令模式。<br>VIM中有三种模式：命令模式，输入模式，命令行模式，其<a href="https://www.cnblogs.com/helloweworld/p/3525905.html">map映射</a><br>在vim配置文件中经常会看到map、nmap、imap<br>n ——表示在普通模式下生效。<br>v ——表示在可视模式下生效。<br>i ——表示在插入模式下效。<br>具体配置方式见上</p><h2 id="2，自动补全命令配置"><a href="#2，自动补全命令配置" class="headerlink" title="2，自动补全命令配置"></a>2，自动补全命令配置</h2><p>当我按下a的时候，弹出的提示框是包含所有a开头的提示，但是编辑器上只有a和光标，这个时候如果我需要再次使用b来进行过滤直接敲入b，编辑器上就是ab和光标，过滤出来的就是ab开头的单词。<br><img src="https://img-blog.csdnimg.cn/94cddb804f1047768c9935774bf4ecdd.png"><br>该设置摘自<a href="https://www.douban.com/group/topic/26633511/">vim自动补全的问题</a><br>设置行命令补时候，直接使用Ctrl-l即可，不用使用Ctrl-x Ctrl-l</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">imap &lt;C-L&gt; &lt;C-X&gt;&lt;C-L&gt;</span><br></pre></td></tr></table></figure><h2 id="3，进行版权声明的设置"><a href="#3，进行版权声明的设置" class="headerlink" title="3，进行版权声明的设置"></a>3，进行版权声明的设置</h2><p>改声明摘自博客，可以继续进行完善，使用F3即可调用</p><h2 id="4，一些其他映射"><a href="#4，一些其他映射" class="headerlink" title="4，一些其他映射"></a>4，一些其他映射</h2><p>“调整格式以便对齐（例化后的）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:map &lt;F6&gt; :s/^ *\./        ./&lt;cr&gt;^f(i                              &lt;ESC&gt;f)i                               &lt;ESC&gt;^24ldw24ldwa  &lt;ESC&gt;hdwj</span><br></pre></td></tr></table></figure><p>GVIM配置自动调整将F6映射为后面一长串指令，具体指令可以自行尝试</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;使用VIM或GVIＭ最基本的配置，不包含任何插件相关的设置，VIM用于写verilog，非常欢迎大家在评论区分享讨论。本文不进行插件的配置，不进行基本使用方式与使用技巧的说明，仅作为基本配置的分享交流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 i</summary>
      
    
    
    
    <category term="文本编辑器" scheme="https://guodongblog.com/categories/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
    
    <category term="GVIM" scheme="https://guodongblog.com/tags/GVIM/"/>
    
  </entry>
  
  <entry>
    <title>IC设计EDA软件虚拟机环境配置与安装教程</title>
    <link href="https://guodongblog.com/posts/a65941daccf9/"/>
    <id>https://guodongblog.com/posts/a65941daccf9/</id>
    <published>2022-04-28T12:04:59.000Z</published>
    <updated>2022-05-18T16:16:21.103Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>IC学习的时候，需要搭建的EDA环境。以数字电路设计为例，需要进行代码编写，验证仿真，综合，形式验证，后端综合等，相关软件，本博文分享一篇EETOP论坛网友ZHZIC分享的安装方式与资源，笔者自行依据教程进行安装，可以运行相关数字设计所需要用的软件。<br>EDA虚拟机仅供个人学习使用，且为免费使用，切勿商用。如果商用，请购买正版工具。使用者禁止私自售卖该虚拟机，带来的侵权后果由使用者自行承担。</p></blockquote><p>先给我的环境。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1WfbL6dcHg7nKVTDGq9hOzQ </span><br><span class="line">提取码：nnsq </span><br></pre></td></tr></table></figure><p>其中解压密码与root密码均是： 123456<br>目前已经集成了数字，模拟相关的基本工具，工艺库如下。</p><p>├── Cdence<br>│   ├── IC617<br>│   ├── IScape<br>│   ├── license<br>│   └── MMSIM151<br>├── iso<br>├── lib<br>│   ├── SMIC_018_MMRF_oa<br>│   └── tsmc180rf<br>├── Mentor<br>│   ├── calibre2018<br>│   └── license<br>├── Package<br>│   ├── cadence<br>│   └── synopsys2018<br>├── patch<br>└── Synopsys<br>    ├── Formality2018<br>    ├── ICC2018<br>    ├── installer<br>    ├── LC2018<br>    ├── PrimeTime2018<br>    ├── SCL_2018<br>    ├── SpyGlass2016<br>    ├── Starrc2018<br>    ├── syn2018<br>    ├── VCS2018<br>    └── Verdi2018</p><p>现在的资源太多了，自己去找，会找到很多，不知道有用没用的，下面的教程笔者经过尝试可以安装运行。教程步骤非常齐全，且论坛坛友评价也很不错。链接如下<br>1，博文的推荐与安装方式<br><a href="http://bbs.eetop.cn/thread-897274-1-1.html">EDA软件安装教程，包括RHEL7.8、cadence软件、calibre、s家软件</a><br>2，SpyGlass的安装<br><a href="http://bbs.eetop.cn/thread-627969-1-1.html">SpyGlass2016.06安装破解教程</a><br>3，笔者安装环境展示<br><img src="https://img-blog.csdnimg.cn/37ad1535831f489ea48962f716ca53cb.png" alt="测试文章图片1"><br><img src="https://img-blog.csdnimg.cn/289eb3a412b44e23b56004db646ff593.png"><br><img src="https://img-blog.csdnimg.cn/817f3c43bd024911a8dccedacc522621.png"></p><p>最后，根据教程，可以完成GVIM，SpyGalass,VCS，Verdi，DC，PT，FM，ICC等主要是数字相关的软件。有需要笔者可以提供安装好的虚拟机资源。后续笔者会提供各个软件使用的教程，主要是官方UG（User Guide）或者是SU（Student Guide）的lab学习总结或者是自行学习总结的小demo。<br>最后，感谢以上同学无私分享。</p><p>其他：<br>1，下面是自己在eetop开的帖子，有进一步问题可以进行参考。<a href="https://bbs.eetop.cn/thread-919520-1-1.html">全套数字模拟设计EDA环境。带模拟工艺库</a><br>VM版本笔者使用的链接如下，带破解安装教程。要是有可以使用自己的即可。最开始使用的时候选择我已移动虚拟机。否则无法使用。会导致破解失败！！！</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1H1gmtQf6GTGVczGQP1j_5g</span><br><span class="line">提取码：e61y</span><br></pre></td></tr></table></figure><p>2，模拟的工艺库配置参考链接如下<br><a href="https://blog.csdn.net/weixin_44115643/article/details/118930454">Cadence Virtuoso IC617的启动和新建工程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;IC学习的时候，需要搭建的EDA环境。以数字电路设计为例，需要进行代码编写，验证仿真，综合，形式验证，后端综合等，相关软件，本博文分享一篇EETOP论坛网友ZHZIC分享的安装方式与资源，笔者自行依据教程进行安装，可以运行相关数字设计所需要用的软件</summary>
      
    
    
    
    <category term="数字IC设计" scheme="https://guodongblog.com/categories/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="EDA环境搭建" scheme="https://guodongblog.com/categories/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1/EDA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="数字IC环境配置" scheme="https://guodongblog.com/tags/%E6%95%B0%E5%AD%97IC%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>RedHat Linux 7安装CentOS 7 yum源</title>
    <link href="https://guodongblog.com/posts/46f984b01519/"/>
    <id>https://guodongblog.com/posts/46f984b01519/</id>
    <published>2022-04-28T10:26:34.000Z</published>
    <updated>2022-05-18T16:16:21.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>使用yum进行安装软件的时候报错</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Loaded plugins: langpacks, product-id, search-disabled-repos, subscription-manager</span><br><span class="line">This system is not registered with an entitlement server. You can use subscription-manager to register.</span><br></pre></td></tr></table></figure><p>yum 是一个软件安装管理的机制，通常情况下安装软件需要连接到网络上，从网络上的软件库进行软件的下载及安装，但是 RHEL 系统只有注册的用户才能用 yum 机制进行线上安装，可以直接将将 RHEL7 的 yum 源换成 Centos7 的。就可以进行安装了。</p><h1 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h1><h2 id="0，进入-x2F-opt目录，进入root模式，新建yum目录"><a href="#0，进入-x2F-opt目录，进入root模式，新建yum目录" class="headerlink" title="0，进入&#x2F;opt目录，进入root模式，新建yum目录"></a>0，进入&#x2F;opt目录，进入root模式，新建yum目录</h2><p><img src="https://img-blog.csdnimg.cn/fc214cfdf56e44e38b824e4a39b57b2d.png"></p><h2 id="1，查看自己redhat版本"><a href="#1，查看自己redhat版本" class="headerlink" title="1，查看自己redhat版本"></a>1，查看自己redhat版本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/redhat-release</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/892387f5b703417098a222cc6a378f11.png"><br>要是版本一致后续的操作与博主一致，不一致的需要自行进行略微的改动。</p><h2 id="2，查看redhat-7-0系统本身所安装的那些yum-软件包并将其一一删除"><a href="#2，查看redhat-7-0系统本身所安装的那些yum-软件包并将其一一删除" class="headerlink" title="2，查看redhat 7.0系统本身所安装的那些yum 软件包并将其一一删除"></a>2，查看redhat 7.0系统本身所安装的那些yum 软件包并将其一一删除</h2><p>查看已经安装的软件包</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep yum</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/02855ac9303142b18b5cb480c69690a8.png"><br>删除<br>将黑体换为以上安装的软件包，将其意义删除<br>rpm -e <strong>yum-rhn-plugin-2.0.1-10.el7.noarch</strong> –nodeps<br>也可以使用如下命令，将其一次删除完<br>rpm -e PackageKit-yum-1.1.10-2.el7.x86_64 yum-3.4.3-167.el7.noarch  –nodeps</p><p>可重新查看，检查是否已经去全部删除，确保已经完全删除</p><h2 id="3，确定自己的虚拟机可以上网"><a href="#3，确定自己的虚拟机可以上网" class="headerlink" title="3，确定自己的虚拟机可以上网"></a>3，确定自己的虚拟机可以上网</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/11e99542f04d455e86b35da8087324ea.png"><br>使用<code>Ctrl+C</code>可以终止访问</p><h2 id="4，找到自己系统所对应的文件包版本更新"><a href="#4，找到自己系统所对应的文件包版本更新" class="headerlink" title="4，找到自己系统所对应的文件包版本更新"></a>4，找到自己系统所对应的文件包版本更新</h2><p>下载的网站为  <a href="http://mirrors.163.com/">http://mirrors.163.com/</a></p><p>进入找到你自己版本的对应文件，注意下载的需要与你上面删除的一致。CentOS几乎和RedHat是一样的，所以无需担心软件包是否可安装。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://mirrors.163.com/centos/7/os/x86_64/Packages/PackageKit-yum-1.1.10-2.el7.centos.x86_64.rpm</span><br><span class="line">wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-3.4.3-168.el7.centos.noarch.rpm</span><br><span class="line">wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-langpacks-0.4.2-7.el7.noarch.rpm</span><br><span class="line">wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-metadata-parser-1.1.4-10.el7.x86_64.rpm</span><br><span class="line">wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-rhn-plugin-2.0.1-10.el7.noarch.rpm</span><br><span class="line">wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-utils-1.1.31-54.el7_8.noarch.rpm</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5d451b63adeb432691a5da30834ed3d4.png"></p><h2 id="5，查看已经下载的文件"><a href="#5，查看已经下载的文件" class="headerlink" title="5，查看已经下载的文件"></a>5，查看已经下载的文件</h2><p><img src="https://img-blog.csdnimg.cn/037eb47f34084444ad36ff2806b9bbcb.png"></p><h2 id="6，安装软件包"><a href="#6，安装软件包" class="headerlink" title="6，安装软件包"></a>6，安装软件包</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh *.rpm --force --nodeps</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/3b2f31ed764048c2a508c2d6cf44a97e.png"></p><h2 id="7，新建repo-配置文件"><a href="#7，新建repo-配置文件" class="headerlink" title="7，新建repo 配置文件"></a>7，新建repo 配置文件</h2><p>新建一个终端，进入超级用户模式，进入目录<code>cd /etc/yum.repos.d/</code><br>编辑文件<code>gedit CentOS-Base.repo</code>在弹出的文本框输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#CentOS-Base.repo</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The mirror system uses the connecting IP address of the client and the</span></span><br><span class="line"><span class="comment"># update status of each mirror to pick mirrors that are updated to and</span></span><br><span class="line"><span class="comment"># geographically close to the client.  You should use this for CentOS updates</span></span><br><span class="line"><span class="comment"># unless you are manually picking other mirrors.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If the mirrorlist= does not work for you, as a fall back you can try the</span></span><br><span class="line"><span class="comment"># remarked out baseurl= line instead.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">[base]</span><br><span class="line">name=CentOS-<span class="variable">$7</span> - Base - 163.com</span><br><span class="line"><span class="comment">#mirrorlist=http://mirrorlist.centos.org/?release=$7&amp;arch=$basearch&amp;repo=os</span></span><br><span class="line">baseurl=http://mirrors.163.com/centos/7/os/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line"><span class="comment">#released updates</span></span><br><span class="line">[updates]</span><br><span class="line">name=CentOS-<span class="variable">$7</span> - Updates - 163.com</span><br><span class="line"><span class="comment">#mirrorlist=http://mirrorlist.centos.org/?release=$7&amp;arch=$basearch&amp;repo=updates</span></span><br><span class="line">baseurl=http://mirrors.163.com/centos/7/updates/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line"><span class="comment">#additional packages that may be useful</span></span><br><span class="line">[extras]</span><br><span class="line">name=CentOS-<span class="variable">$7</span> - Extras - 163.com</span><br><span class="line"><span class="comment">#mirrorlist=http://mirrorlist.centos.org/?release=$7&amp;arch=$basearch&amp;repo=extras</span></span><br><span class="line">baseurl=http://mirrors.163.com/centos/7/extras/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line"><span class="comment">#additional packages that extend functionality of existing packages</span></span><br><span class="line">[centosplus]</span><br><span class="line">name=CentOS-<span class="variable">$7</span> - Plus - 163.com</span><br><span class="line">baseurl=http://mirrors.163.com/centos/7/centosplus/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7</span><br></pre></td></tr></table></figure><p>保存退出<br><img src="https://img-blog.csdnimg.cn/e6acbf67982a485ab52b1977bf7b438e.png"></p><h2 id="8，清除缓存"><a href="#8，清除缓存" class="headerlink" title="8，清除缓存"></a>8，清除缓存</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum clean all</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/ffb0db9781964d198052ad1bd2a6195d.png"></p><h2 id="9，尝试安装Gvim，测试可以正常使用"><a href="#9，尝试安装Gvim，测试可以正常使用" class="headerlink" title="9，尝试安装Gvim，测试可以正常使用"></a>9，尝试安装Gvim，测试可以正常使用</h2><p>使用如下<code>yum -y install gvim</code><br><img src="https://img-blog.csdnimg.cn/c8c7aed6189e4f7bae6826c41f4fa9e3.png"><br>安装等待，完成时候会出现Complete！<br><img src="https://img-blog.csdnimg.cn/b01af2b383ec4347b7d42af05ec68f43.png"></p><p>打开一个终端，输入<code>gvim</code>键入<code>:q</code>退出<br><img src="https://img-blog.csdnimg.cn/cca38f3a3ca54914ad0c8155092778e9.png"></p><h2 id="10，删除下载的安装包与yum目录"><a href="#10，删除下载的安装包与yum目录" class="headerlink" title="10，删除下载的安装包与yum目录"></a>10，删除下载的安装包与yum目录</h2><p><img src="https://img-blog.csdnimg.cn/60ab0fd1c4f246d59b5baf8f33a3f8fb.png"></p><h1 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h1><p><a href="https://www.linuxidc.com/Linux/2017-04/142444.htm">RedHat Linux 7安装CentOS 7 yum源</a><br><a href="https://blog.csdn.net/u010194538/article/details/77855103">rpm安装软件时提示warning: *.rpm: Header V3 RSA&#x2F;SHA256 Signature, keykey ID c105b9de:</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;使用yum进行安装软件的时候报错&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr</summary>
      
    
    
    
    <category term="数字IC设计" scheme="https://guodongblog.com/categories/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="EDA环境搭建" scheme="https://guodongblog.com/categories/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1/EDA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="数字IC环境配置" scheme="https://guodongblog.com/tags/%E6%95%B0%E5%AD%97IC%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
</feed>
