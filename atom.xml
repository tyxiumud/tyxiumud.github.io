<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GuoDong の Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-05-06T01:23:56.729Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>MengGuodong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基础知识之——标准单元库</title>
    <link href="http://example.com/2022/05/06/dc/DC%E7%BB%BC%E5%90%88%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/05/06/dc/DC%E7%BB%BC%E5%90%88%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-05-06T03:44:12.000Z</published>
    <updated>2022-05-06T01:23:56.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>Synopsys_工艺库格式是事实上的库标准。对库格式和延时计算方法的基本理解是成功综合的关键Synopsys工艺库可分为两大类：<br>逻辑库：包含仅与综合过程有关的信息且通过DC用于设计的综合和优化。如pin到pin的时序、面积、引脚类型等<br>物理库：包含单元的物理特征，如物理尺寸、层信息、单元方位等。</p><p>半导体厂商提供给我们DC兼容的工艺技术库——<strong>综合库</strong>来进行逻辑综合。大多数情况下，半导体厂商提供二进制格式的.db文件，也有可能只提供文本(ASCII)格式的.lib文件，或两者。DC使用的综合库必须是.db格式的库。因此，如果我们只有.lib文件，需要用Library Compiler将其转换为.db文件。</p><p>综合库的结构如下图所示。<img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220504112821556.png" alt="综合库的结构"></p><p>可以将其分为两个部分，标题部分与单元描述部分。我们使用smic180工艺下的typical.lib进行分析。</p><p>其中标题部分主要是介绍使用的延时模型，工艺角，库的名称等一些公共部分，后面的部分是库里单元的描述，也是这个文件的主要部分。文档一共214835行，其中第一部分一共由250行左右进行描述，剩下的都是对单元的描述。</p><p>对应的文本描述如下所示。下面也将通过介绍标题部分以及特定的几个单元描述来进行总结学习。参考的smic180-typical.lib</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220504114613505.png" alt="单元库的文本描述"></p><h1 id="库属性部分"><a href="#库属性部分" class="headerlink" title="库属性部分"></a>库属性部分</h1><ul><li>库组(library group)</li><li>工艺库的一般属性(general attributes)</li><li>库文档资料(documentation attributes)</li><li>单位定义(unit attributes)</li></ul><h2 id="1，库组-library-Group"><a href="#1，库组-library-Group" class="headerlink" title="1，库组(library Group)"></a>1，库组(library Group)</h2><p>库组指令定义工艺库名。这个指令必须是在库文件中的第一个可执行行。例如：<br>library(my_library)<br>{<br>…}</p><h2 id="2，工艺库的一般属性-general-attributes"><a href="#2，工艺库的一般属性-general-attributes" class="headerlink" title="2，工艺库的一般属性(general attributes)"></a>2，工艺库的一般属性(general attributes)</h2><p>包括以下属性</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* general attributes */</span></span><br><span class="line">delay_model : table_lookup;</span><br><span class="line">in_place_swap_mode : match_footprint;</span><br><span class="line">library_features(report_delay_calculation);库特征 也就是这个库具有延迟计算的特征</span><br><span class="line"></span><br><span class="line">in_place_swap_mode : [match_footpoint/no_swapping];   替代交换方式 这里选的是匹配封装的方式。具体的信息可以查阅其他治疗或者询问半导体厂商。</span><br><span class="line">bus_naming_style : <span class="string">&quot;Bus***...&quot;</span>;   总线命名方式 例如：bus_naming_style:<span class="string">&quot;Bus%spin%d&quot;</span>;这个库没有进行总线规则的命名。</span><br></pre></td></tr></table></figure><h3 id="1-technology-工艺类型"><a href="#1-technology-工艺类型" class="headerlink" title="1)technology  工艺类型"></a>1)technology  工艺类型</h3><p>工艺属性定义用来区别时序分析的设计是基于那种类型的设计。目前有两种类型的设计需要时序分析，一种是ASIC设计，一种是FPGA设计。但是它们在设计流程上有很大的不同，所以在进行时序分析时也有所区别。因此工艺属性有两个设置值可以选择：CMOS和FPGA。</p><p>工艺属性识别库中使用的工艺类型：CMOS(预设值)、 FPGA。工艺类型必须先定义，放在属性清单的顶部。如果库中没有技术属性，Library Compiler预设其为cmos。</p><h3 id="2-in-place-swap-mode"><a href="#2-in-place-swap-mode" class="headerlink" title="2)in_place_swap_mode"></a>2)in_place_swap_mode</h3><p>设计工具需要对设计进行时序和功耗优化，最基本的方法就是把不合适的单元替换成合适的单元。但是是否可以允许设计工具进行单元替换优化操作，需要在时序信息文件中通过单元优化替换属性进行定义。因此单元优化替换属性有两个设置值可以选择：match footprint和no swapping。</p><h3 id="3-library-features"><a href="#3-library-features" class="headerlink" title="3)library_features"></a>3)library_features</h3><p>工艺库特征属性定义其他Synopsys工具可以使用具有该工艺库特征定义的命令进行设计。工艺库特征属性有5个设置值可以选择：report_delay_calculation、report_power_calculation、report_noise_calculation、report_user_data和allow_update_attribute。</p><h3 id="4-delay-model-延时模型"><a href="#4-delay-model-延时模型" class="headerlink" title="4)delay_model  延时模型"></a>4)delay_model  延时模型</h3><p>指明在计算延迟时用的那个模型，主要有generic_cmos(默认值)、table-lookup(非线性模型)、piecewise-cmos(optional)、dcm(Delay Calculation Module)、polynomial。如果库组中没有定义延时模型属性，那么默认设置是generic_cmos。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505133009410.png" alt="delay_model 延时模型"></p><h4 id="a-非线性模型"><a href="#a-非线性模型" class="headerlink" title="a)非线性模型"></a>a)非线性模型</h4><p>大多数单元库都包括表格模型(table model)，用于为单元的各种时序弧指定延迟并进行时序检查。 这些表格模型被称为NLDM(Non-Linear Delay Model)，可用于延迟、输出压摆计算或其他时序检查。表格模型中提供了：在单元输入引脚处输入过渡时间和输出引脚处输出负载电容的各种组合下通过单元的延迟。</p><p> CMOS非线性延时计算模型(NLDM)是一种时序计算精度较高的延时计算模型。在Synopsys工艺库模型中，目前业界主要使用非线性延时计算模型。该延时模型由&#x3D;&#x3D;<strong>输入信号转换时间</strong>&#x3D;&#x3D;与&#x3D;&#x3D;<strong>输出负载</strong>&#x3D;&#x3D;作为索引，时序分析时以一个二维查找表的形式来计算延时，查找表中时序数据的实际构成如下图所示。</p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505134501911.png" alt="查找表构成" style="zoom:80%;" /><p>基于非线性延时计算模型通常的计算过程为：查找表中索引参数的某个采样点延时可直接查表得出，再通过插值算法来计算延时。通过非线性延时计算模型计算所能达到的精度有赖于采样点选取的合理性以及所用的插值算法。只要采样点较为合理，采用一般的多项式插值算法就能取得较好的延时结果。延时的一般插值计算方法如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505134557942.png"></p><p>三维坐标中，X为输入端口信号的跳变时间Transition time(ns)，y为输出端负载电容值Cload(pf)，Z为延时值Tdelay(ns)，计算式为<code>Z=A+B·X+C·Y+D·X·Y</code>如果要计算X&#x3D;0.32、Y&#x3D;0.05时的Z值，只需取最接近X、Y的4个采样点。构建如下方程</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505135114504.png" alt="插值近似方程组"></p><p>A&#x3D;0.2006,B&#x3D;0.1983,C&#x3D;0.2399,D&#x3D;0.0677。带入X、Y即可</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505135214006.png" alt="延时计算"></p><p>现已经通过查找表与插值的方式计算得到了单元延时。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220506000624568.png" alt="image-20220506000624568"></p><p><code>Dc</code>是通过<code>WLM</code>(wire load model)以及<code>type_tree</code>来进行计算的，参看文章后续的这两个部分即可得到线延时。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505194504208.png"></p><p>如下图所示，计算逻辑门U1的Dcell值时，先确定输入端口的转换时间，U1输入端口的转换时间由前级单元U0的输出决定。当U0的输出为上升（rise）转换时间时，由于U1的时序弧为反向时序弧，因此U1的逻辑门延时应该在对应的U1下降时序弧查找表中进行插值计算。由于下降时序弧查找表是二维表，因此还需要确定U1输出端负载值，通过互连线负载模型和驱动节点负载值得到输出端总负载值。最后，根据U1输入端口转换时间和输出端负载电容值作为索引，在对应的U1下降时序弧二维查找表得到相应数据，并进行插值计算直接得到延时。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505213859119.png"></p><h2 id="3，库文档资料-documentation-attributes"><a href="#3，库文档资料-documentation-attributes" class="headerlink" title="3，库文档资料(documentation attributes)"></a>3，库文档资料(documentation attributes)</h2><p>主要是库的版本、库的日期、还有注释。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">revision : ***;</span><br><span class="line">date : ***;</span><br><span class="line">comment : ***;</span><br></pre></td></tr></table></figure><h2 id="4，单位定义-unit-attributes"><a href="#4，单位定义-unit-attributes" class="headerlink" title="4，单位定义(unit attributes)"></a>4，单位定义(unit attributes)</h2><p> Design Compiler工具本身是没有单位的。然而在建立工艺库和产生报告时，必须要有单位。库中有6个库级属性定义单位:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">time_unit : <span class="string">&quot;1ns&quot;</span>;   时间单位</span><br><span class="line">voltage_unit : <span class="string">&quot;1V&quot;</span>;   电压单位</span><br><span class="line">current_unit : <span class="string">&quot;1mA&quot;</span>;   电流单位</span><br><span class="line">pulling_resistance_unit : <span class="string">&quot;1kohm&quot;</span>;   上下拉电阻单位</span><br><span class="line">leakage_power_unit : <span class="string">&quot;1pW&quot;</span>;　　漏电功耗</span><br><span class="line">capacitive_load_unit : (<span class="number">1.0</span>,pf);　　电容单位</span><br></pre></td></tr></table></figure><p>单元描述中数值的单位都是在库中指定的，可使用Liberty命令集在库文件中声明单位。  </p><h1 id="环境属性部分"><a href="#环境属性部分" class="headerlink" title="环境属性部分"></a>环境属性部分</h1><ul><li>操作环境(operation conditions)</li><li>阈值定义(threshold definitions)</li><li>默认环境属性(default attributes)</li><li>模板(templates)</li><li>比例缩放因子(k-factors)</li><li>I&#x2F;Opad属性(pad attributes)</li><li>线负载模型(wire-loads)</li></ul><h2 id="1，工作条件-operation-conditions"><a href="#1，工作条件-operation-conditions" class="headerlink" title="1，工作条件(operation conditions)"></a>1，工作条件(operation conditions)</h2><p>指定了工艺、温度、电压以及RC树模型，用于设计的综合和时序分析。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505141917579.png" alt="操作环境示意"></p><p>这里就是对于库基本的情况进行了说明。会与slow.lib内容不同。主要是对于温度、电压等操作环境进行说明。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505144141794.png" alt="工作条件"></p><p>这里的工作条件与我们之前了解的PVT环境联系到了一起。</p><h3 id="1-tree-type"><a href="#1-tree-type" class="headerlink" title="1)tree_type"></a>1)tree_type</h3><p>tree type属性定义了使用的环境互连模型，DC在计算互连延迟时使用这一属性值来选择合适的公式。</p><p>对于预布局估计，可以使用以下三种不同形式来表示互连RC树。请注意，每个互连线的总长度(以及电阻和电容估计值)在这三种情况下是相同的。  </p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505142752630.png" alt="image-20220505142752630"></p><p>Best-case tree：在最佳情况树中，假定负载引脚在物理上与驱动引脚相邻。因此，到负载引脚的路径中都没有互连电阻，来自其它扇出引脚的所有互连线电容和引脚电容仍然作为驱动引脚上的负载。  </p><p>Balanced tree：在这种情况下，假定每个负载引脚都在互连线的一部分上，并且每条到达负载引脚的路径上的总电阻和电容都相等。  </p><p>Worst-case tree ：在最差情况树中，假定所有负载引脚都集中在互连线的另一端。因此，每条到负载引脚的路径上都会有全部的互连线电阻和电容。  </p><h2 id="2，阈值定义-threshold-definitions"><a href="#2，阈值定义-threshold-definitions" class="headerlink" title="2，阈值定义(threshold definitions)"></a>2，阈值定义(threshold definitions)</h2><p>压摆值(slew)基于的是在库中指定的测量阈值点，大多数上一代的库(0.25um或更旧的库)都使用10％和90％作为压摆(或称过渡时间)的测量阈值点。  </p><p>压摆阈值点的选择对应的是波形的线性部分。随着技术的发展，实际波形最线性的部分通常在30％至70％之间。 因此，大多数新一代时序库都将压摆测量阈值点指定为Vdd的30％和70％。但是，由于之前测得的过渡时间在10％至90％之间，因此在填充库时，通常将测得的30％至70％的过渡时间加倍，这由<strong>压摆降额系数</strong>(slew derate factor)指定，通常指定为0.5。压摆测量阈值点为30％和70％且压摆降额系数为0.5，等效于测量阈值点为10％和90％。 阈值设置的示例如下：  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">slew_lower_threshold_pct_fall : <span class="number">30.0</span>;</span><br><span class="line">slew_upper_threshold_pct_fall : <span class="number">70.0</span>;</span><br><span class="line">slew_lower_threshold_pct_rise : <span class="number">30.0</span>;</span><br><span class="line">slew_upper_threshold_pct_rise : <span class="number">70.0</span>;</span><br><span class="line">input_threshold_pct_fall      : <span class="number">50.0</span>;输入上升/下降沿采样点</span><br><span class="line">input_threshold_pct_rise      : <span class="number">50.0</span>;</span><br><span class="line">output_threshold_pct_fall     : <span class="number">50.0</span>;输出上升/下降沿采样点</span><br><span class="line">output_threshold_pct_rise     : <span class="number">50.0</span>;</span><br><span class="line">slew_derate_from_library      : <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505145445468.png" alt="阈值设定"></p><p>上面的设置规定了要将表格中的过渡时间乘以0.5，以获得与阈值(30%-70%)设置相对应的过渡时间。这意味着表格中的值(以及相应的索引值)实际上是10%-90%阈值点的测量值。在标定过渡时间值时，首先在30%-70%处测量，然后再把测量值外推到10％至90％((70-30)&#x2F;(90-10)&#x3D; 0.5)。  </p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505151327674.png" alt="修正后如图所示"></p><p>未指定slew_derate_from_library(默认值为1.0)，这意味着库中的过渡时间不会降额(derate)  </p><h2 id="3，默认环境属性-default-attributes"><a href="#3，默认环境属性-default-attributes" class="headerlink" title="3，默认环境属性(default attributes)"></a>3，默认环境属性(default attributes)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* default attributes */</span></span><br><span class="line">default_leakage_power_density: <span class="number">0.0</span>;</span><br><span class="line">default_cell_leakage_power: <span class="number">0.0</span>;</span><br><span class="line">default_fanout_load: <span class="number">1.0</span>;</span><br><span class="line">default_output_pin_cap: <span class="number">0.0</span>;</span><br><span class="line">default_inout_pin_cap: <span class="number">0.0035</span>;</span><br><span class="line">default_input_pin_cap: <span class="number">0.0035</span>;</span><br><span class="line">default_max_transition: <span class="number">3.0</span>;</span><br></pre></td></tr></table></figure><h3 id="1-漏电功率-leakage-power"><a href="#1-漏电功率-leakage-power" class="headerlink" title="1)漏电功率(leakage_power)"></a>1)漏电功率(leakage_power)</h3><p>大多数标准单元的设计都仅在输出或状态发生变化时才消耗功率。单元通了电但没有任何行为时，所有功耗都归因于泄漏电流(leakage current)。泄漏可能是由于MOS器件的亚阈值电流引起的，也可能是由于通过栅极氧化物的隧穿电流引起的。在以前的CMOS工艺技术中，漏电功率可以忽略不计，并且在设计过程中并不是主要考虑因素。但是，随着技术的发展，漏电功率变得越来越大，与有功功率相比，漏电功率已经无法忽略不计了。</p><p>如上所述，漏电功率主要有两个来源：MOS器件中的亚阈值电流和栅氧化物隧穿。通过使用高阈值电压单元，可以降低亚阈值电流；然而，由于高阈值电压单元的速度较低而存在一个折中(rde-of)：高阈值电压单元的漏电较小，但速度较慢。同样，低阈值电压单元的漏电较大，但速度较高。无论是使用高阈值电压还是低阈值电压的单元，栅极氧化物隧穿带来的影响都差不多。因此，控制漏电功率的可能方法是使用高阈值电压的单元。类似于在高阈值电压和标准阈值电压单元之间进行选择，设计中使用的单元强度(strength)也是一种漏电和速度之间的折中。强度较高的单元具有较高的漏电功率，但速度较高。</p><p>MOS器件的亚阈值泄漏电流与温度具有很强的非线性特性，在大多数工艺技术中，随着器件温度从25°C升高到125°C，亚阈值泄漏电流可能会增加10倍至20倍。栅极氧化物隧穿带来的影响基本不随温度或器件阈值电压而改变，在100m及以上工艺技术中可以忽略的栅极氧化物隧穿已成为65nm或更精细技术在较低温度下漏电的主要原因。例如，对于65m或更精细的工艺技术，栅极氧化物隧穿漏电量可能等于室温下的亚阈值漏电量。而在高温下，亚阈值漏电仍然是导致漏电功率的主要因素。</p><h2 id="4，模板-templates"><a href="#4，模板-templates" class="headerlink" title="4，模板(templates)"></a>4，模板(templates)</h2><p>这里提供了很多查找表的模板。</p><h3 id="1-功耗查找表模板组-power-lut-template-group"><a href="#1-功耗查找表模板组-power-lut-template-group" class="headerlink" title="1)功耗查找表模板组(power lut template group)"></a>1)功耗查找表模板组(power lut template group)</h3><p>功耗查找表模板组(power lut template group)是库组中为其他功耗相关组所调用的查找表模板，通过该模板可以构成一维到三维的查找表结构，如下所示。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505190536108.png"></p><p>如上所示存在3个不同的变量：variable1、variable2和variable3，对应的变量参数值也存在3种：total_output_net_capacitance、equal_or_opposite_output_net_capacitance和input_transition_time。通过3个索引变量index1、index2和index3的值来确定最终的功耗结果。</p><p>举例如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">power_lut_template(energy_template_7x3x3) &#123;</span><br><span class="line">  variable_1 : input_transition_time;</span><br><span class="line">  variable_2 : total_output_net_capacitance;</span><br><span class="line">  variable_3 : equal_or_opposite_output_net_capacitance;</span><br><span class="line">  index_1 (<span class="string">&quot;1000, 1001, 1002, 1003, 1004, 1005, 1006&quot;</span>);</span><br><span class="line">  index_2 (<span class="string">&quot;1000, 1001, 1002&quot;</span>);</span><br><span class="line">  index_3 (<span class="string">&quot;1000, 1001, 1002&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="b-延时查找表模板组-lu-table-template-group"><a href="#b-延时查找表模板组-lu-table-template-group" class="headerlink" title="b)延时查找表模板组(lu_table_template_group)"></a>b)延时查找表模板组(lu_table_template_group)</h3><p>延时查找表模板组(lu_table_template_group)是库组中为其他延时相关组所调用的查找表模板，通过该模板可以构成一维到三维的查找表结构，如下所示。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505190943079.png"></p><p>与功耗查找表模板组结构类似，延时查找表模板组存在3个不同的变量：variable1、variable2和variable3，其中变量参数值根据所调用的延时相关组的不同而不同，主要包括以下变量参数值：input_voltage、output_voltagefanout_number、fanout_pin_capacitance、driver_slew、input_net_transition和total_output_net_capacitance等，通过3个索引变量index 1、index2和index3的值来确定最终的延时结果。</p><p>举例如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">power_lut_template(energy_template_7x7) &#123;</span><br><span class="line">  variable_1 : input_transition_time;</span><br><span class="line">  variable_2 : total_output_net_capacitance;</span><br><span class="line">  index_1 (&quot;1000, 1001, 1002, 1003, 1004, 1005, 1006&quot;);</span><br><span class="line">  index_2 (&quot;1000, 1001, 1002, 1003, 1004, 1005, 1006&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还有很多其他的模板，不一一列举</p><h2 id="5，比例缩放因子-k-factors"><a href="#5，比例缩放因子-k-factors" class="headerlink" title="5，比例缩放因子(k-factors)"></a>5，比例缩放因子(k-factors)</h2><p>库的表征是一个耗时的过程，针对各种工艺角(process corner)对库进行表征可能需要数周的时间，工艺变量的设置使得以特定工艺角为特征的库可以用于不同工艺角的时序计算。工艺的k-系数可用于完成从特征库工艺到目标工艺的延迟降额。如上所述，降额系数的使用在时序计算期间引入了不准确性，跨工艺条件进行降额尤其不准确，因此很少采用。总而言之，指定不同工艺变量值(例如1.0或任何其它值)的唯一功能就是在少数情况下允许跨工艺条件进行降额处理。</p><p>与作为物理量的温度和电压不同，工艺是不可量化的变量。就数字特征和验证而言，它可能是缓慢(slow)、典型(typical)或快速(fast)的工艺之一。  工作条件(nom_process、nom_temperature和nom_voltage)指定了对库进行表征的工艺、电压和温度， 也指定了使用该库中单元的条件。如果特征和工作条件不同，则需要对延迟计算过程中获得的时序值进行降额(derate)处理， 这可以通过使用库中指定的降额系数(k-系数)来实现 。使得时序分析的结果更接近真实值。</p><p>当延迟计算过程中工作条件的工艺、电压或温度与库中的标称条件不同时，可使用这些系数来进行计算。注意，k_volt系数为负，这意味着延迟随着电压的增加而减小，而k_temp因子为正，这意味着延迟通常随温度的升高而增加 。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505185813416.png"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505185846312.png"></p><p>形式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* k-factors */</span><br><span class="line"> k_process_cell_leakage_power: 0;</span><br><span class="line"> k_temp_cell_leakage_power: 0;</span><br><span class="line"> k_volt_cell_leakage_power: 0;</span><br><span class="line"> k_process_internal_power: 0;</span><br><span class="line"> k_temp_internal_power: 0;</span><br><span class="line"> k_volt_internal_power: 0;</span><br><span class="line"> k_process_rise_transition: 1;</span><br><span class="line"> k_temp_rise_transition: 0;</span><br><span class="line"> k_volt_rise_transition: 0;</span><br><span class="line"> k_process_fall_transition: 1;</span><br><span class="line"> k_temp_fall_transition: 0;</span><br><span class="line"> k_volt_fall_transition: 0;</span><br><span class="line"> k_process_setup_rise: 1;</span><br><span class="line"> k_temp_setup_rise: 0;</span><br><span class="line"> k_volt_setup_rise: 0;</span><br><span class="line"> k_process_setup_fall: 1;</span><br><span class="line"> k_temp_setup_fall: 0;</span><br><span class="line"> k_volt_setup_fall: 0;</span><br><span class="line"> k_process_hold_rise: 1;</span><br><span class="line"> k_temp_hold_rise: 0;</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><h2 id="6，I-x2F-Opad属性-pad-attributes"><a href="#6，I-x2F-Opad属性-pad-attributes" class="headerlink" title="6，I&#x2F;Opad属性(pad attributes)"></a>6，I&#x2F;Opad属性(pad attributes)</h2><p>定义I&#x2F;O引脚的电平属性，告诉你输入是COMS还是TTL，什么时候达到高电平、什么时候是低电平。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* pad attributes */</span><br><span class="line">output_voltage(GENERAL) &#123;</span><br><span class="line">  vol: 0.4;</span><br><span class="line">  voh: VDD - 0.4;</span><br><span class="line">  vomin: -0.5;</span><br><span class="line">  vomax: VDD + 0.5;</span><br><span class="line">&#125;</span><br><span class="line">input_voltage(CMOS) &#123;</span><br><span class="line">  vil: 0.3 * VDD;</span><br><span class="line">  vih: 0.7 * VDD;</span><br><span class="line">  vimin: -0.5;</span><br><span class="line">  vimax: VDD + 0.5;</span><br><span class="line">&#125;</span><br><span class="line">input_voltage(TTL) &#123;</span><br><span class="line">  vil: 0.8;</span><br><span class="line">  vih: 2;</span><br><span class="line">  vimin: -0.5;</span><br><span class="line">  vimax: VDD + 0.5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7，线负载模型-wire-loads"><a href="#7，线负载模型-wire-loads" class="headerlink" title="7，线负载模型(wire-loads)"></a>7，线负载模型(wire-loads)</h2><p>在进行布局规划(floorplanning)或布局(layout)之前，可以使用线负载模型(wireload models)来估计由互连线带来的电容、电阻以及面积开销。 线负载模型可用于根据扇出数量来估计网络的长度，线负载模型取决于块(block)的面积，具有不同面积的设计可以选择不同的线负载模型。线负载模型还可以将网络的估计长度映射(map)为电阻、电容以及由于布线而产生的相应面积开销。   形式如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* wire-loads */</span></span><br><span class="line">wire_load(<span class="string">&quot;smic18_wl10&quot;</span>) &#123;</span><br><span class="line">  resistance: <span class="number">8.5e-8</span>;</span><br><span class="line">  capacitance: <span class="number">1.5e-4</span>;</span><br><span class="line">  area: <span class="number">0.7</span>;</span><br><span class="line">  slope: <span class="number">66.667</span>;</span><br><span class="line">  fanout_length(<span class="number">1</span>,<span class="number">66.667</span>);</span><br><span class="line">&#125;</span><br><span class="line">wire_load(<span class="string">&quot;smic18_wl20&quot;</span>) &#123;</span><br><span class="line">  resistance: <span class="number">8.5e-8</span>;</span><br><span class="line">  capacitance: <span class="number">1.5e-4</span>;</span><br><span class="line">  area: <span class="number">0.7</span>;</span><br><span class="line">  slope: <span class="number">133.334</span>;</span><br><span class="line">  fanout_length(<span class="number">1</span>,<span class="number">133.334</span>);</span><br><span class="line">&#125;</span><br><span class="line">wire_load(<span class="string">&quot;smic18_wl30&quot;</span>) &#123;</span><br><span class="line">  resistance: <span class="number">8.5e-8</span>;</span><br><span class="line">  capacitance: <span class="number">1.5e-4</span>;</span><br><span class="line">  area: <span class="number">0.7</span>;</span><br><span class="line">  slope: <span class="number">200.001</span>;</span><br><span class="line">  fanout_length(<span class="number">1</span>,<span class="number">200.001</span>);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>其中参数wire load定义线负载模型的名称，参数resistance定义互连线单位电阻值，参数capacitance定义互连线单位电容值，参数area定义互连线单位长度的面积值，参数slope定义扩展斜率值，参数fanout length定义对应扇出大小的互连线长度。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505154443537.png"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505154453497.png"></p><p>至此，我们得到了互连线的电阻与电容。</p><h3 id="补充：tree-type与线负载模型的关系"><a href="#补充：tree-type与线负载模型的关系" class="headerlink" title="补充：tree-type与线负载模型的关系"></a>补充：tree-type与线负载模型的关系</h3><p>线负载模型(<code>WLM</code>)是根据连线的扇出来估算连线的RC寄生参数那么RC是如何分配呢？<br><strong>操作条件中有“tree-type’”的属性，该属性决定R和C的分配以计算时间延迟</strong>这也是tree-type与线负载模型的关系，也是笔者学习的时候不是很好理解的部分。</p><p>简单来说就是需要用线负载模型去计算一个R，C，那么RC是怎么影响延时的呢，就是看其在电路中的拓扑结构。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505182507290.png"></p><p>这里的图与上述tree_type部分介绍的实际上是一致的。</p><h1 id="单元描述部分"><a href="#单元描述部分" class="headerlink" title="单元描述部分"></a>单元描述部分</h1><ul><li>单元描述</li></ul><p>该部分提供了库里标准单元的描述。标准单元也可以在提供的doc下的文档中找到。文档标题如下</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505191436806.png"></p><p>这里使用几个特殊的标准单元进行学习。<code>DFFR</code>，以及<code>INV</code>。其余基本上是一致的。</p><h2 id="1，INV"><a href="#1，INV" class="headerlink" title="1，INV"></a>1，INV</h2><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505214910528.png"></p><p>lib中的描述如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cell (INVX20) &#123; </span><br><span class="line">  cell_footprint : inv;</span><br><span class="line">  area : 63.201600;</span><br><span class="line">  pin(A) &#123;</span><br><span class="line">    direction : input;</span><br><span class="line">    capacitance : 0.011338;</span><br><span class="line">  &#125;</span><br><span class="line">  pin(Y) &#123;</span><br><span class="line">    direction : output;</span><br><span class="line">    capacitance : 0.0;</span><br><span class="line">    function : &quot;(!A)&quot;;</span><br><span class="line">    internal_power() &#123;</span><br><span class="line">      ...(略)</span><br><span class="line">    &#125;</span><br><span class="line">    timing() &#123;</span><br><span class="line">      related_pin : &quot;A&quot;;</span><br><span class="line">      timing_sense : negative_unate;</span><br><span class="line">      cell_rise(delay_template_7x7) &#123;</span><br><span class="line">        index_1 (&quot;0.03, 0.1, 0.4, 0.9, 1.5, 2.2, 3&quot;);   /*input_net_transition*/</span><br><span class="line">        index_2 (&quot;0.007, 0.42, 0.77, 1.68, 2.94, 4.62, 6.23&quot;);/* total_output_net_capacitance */</span><br><span class="line">        values ( ...);/* delay */</span><br><span class="line">      &#125;</span><br><span class="line">      rise_transition(delay_template_7x7) &#123;</span><br><span class="line">        index_1 (&quot;0.03, 0.1, 0.4, 0.9, 1.5, 2.2, 3&quot;);</span><br><span class="line">        index_2 (&quot;0.007, 0.42, 0.77, 1.68, 2.94, 4.62, 6.23&quot;);</span><br><span class="line">        values (...)</span><br><span class="line">      &#125;</span><br><span class="line">      cell_fall(delay_template_7x7) &#123;</span><br><span class="line">        index_1 (&quot;0.03, 0.1, 0.4, 0.9, 1.5, 2.2, 3&quot;);</span><br><span class="line">        index_2 (&quot;0.007, 0.42, 0.77, 1.68, 2.94, 4.62, 6.23&quot;);</span><br><span class="line">        values (...);</span><br><span class="line">      &#125;</span><br><span class="line">      fall_transition(delay_template_7x7) &#123;</span><br><span class="line">        index_1 (&quot;0.03, 0.1, 0.4, 0.9, 1.5, 2.2, 3&quot;);</span><br><span class="line">        index_2 (&quot;0.007, 0.42, 0.77, 1.68, 2.94, 4.62, 6.23&quot;);</span><br><span class="line">        values ( ...);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    max_capacitance : 6.230000;</span><br><span class="line">  &#125;</span><br><span class="line">  cell_leakage_power : 504.392580;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-引脚电容"><a href="#1-引脚电容" class="headerlink" title="1)引脚电容"></a>1)引脚电容</h3><p>单元的每个输入和输出都可以在引脚（pin）上指定电容。在大多数情况下，仅为单元输入引脚指定电容，而不为输出引脚指定<br>电容，即大多数单元库中的输出引脚电容为0。  </p><h3 id="2-internal-power"><a href="#2-internal-power" class="headerlink" title="2)internal power"></a>2)internal power</h3><p>内部开关功率在单元库中被称为internal power，这是当单元的输入或输出处于活动状态时单元内部的功耗。对于组合逻辑单元，输入引脚的电平跳变会导致输出引脚的电平跳变，从而导致内部开关功耗。  </p><h3 id="3-时序模型"><a href="#3-时序模型" class="headerlink" title="3)时序模型"></a>3)时序模型</h3><p>逻辑单元的时序模型（timing model）旨在为设计中的各种单元实例（instance）提供准确的时序信息。通常会从单元的详细电路仿真中获得时序模型，用以对单元工作时的实际情况进行建模，且需要为逻辑单元的每个时序弧都建立一个时序模型。</p><p>表征反相器的两种延迟是：<br>Tr：输出上升沿延迟<br>Tf：输出下降沿延迟  </p><p>通过反相器的时序弧的延迟取决于两个因素  input_net_transition以及total_output_net_capacitance。</p><p>逻辑单元输出引脚的压摆（slew）主要取决于输出引脚电容：输出信号过渡时间会随着输出负载的增加而增加。 因此，在输入端压摆较大（输入信号过渡时间较长）的情况下，选择合适的单元类型及输出负载，可以改善输出端的压摆。  下图展示了通过调节逻辑单元的输出负载，可以改善或恶化单元输出信号过渡时间的情况。  </p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505221525284.png" alt="Slew changes going through a cell  "></p><p>一个简单的时序模型是 linear delay 模型，其中单元的延迟和输出转换时间表示为两个参数的线性函数：输入转换时间和输出负载电容。通过单元的延迟 D 的线性模型的一般形式如下所示<code>:D=D0+D1*S+D2*C</code>其中D0，D1，D2是常数，S是输入过渡时间，C是输出负载电容  </p><h2 id="2，DFFR"><a href="#2，DFFR" class="headerlink" title="2，DFFR"></a>2，DFFR</h2><p>先看文档描述如下图，可以看到有四种不同驱动强度的，对应这不同的size。我们选择DFFRX4的工艺库文件进行学习。这是一个带复位的寄存器。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505222103992.png"></p><p>我们对DFFRX4的lib内容进行学习，开始同样是cellname,area以及功耗。我们略过看时序的部分。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505223213311.png"></p><p>setup_rising指相关引脚D的上升和下降建立时间。hold_rising是对应的保持时间。这就是我们STA里说到的。这里会进行计算。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505223352898.png"></p><p>脉冲宽度检查 。对于CK引脚有了脉冲宽度的检查，也是对时钟另一种约束，类似于出现毛刺，或者是超高频，DFF就不可以正常工作，这里随着工艺会不断改变。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505223634753.png"></p><p>对于复位引脚recover与removal的时序要求如上图所示。接下来就是输出了。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505223752206.png"></p><p>首先是对功能的描述，其次就是对PIN(Q)功耗的查找表。我们重点关注时序信息。</p><p>非单边类型（non-unate）的时序弧 。(在非单边（non-unate）时序弧中，仅仅从一个输入引脚的跳变方向是无法确定输出引脚电平将如何跳变的，还要取决于其他输入引脚的状态。  )</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505225030281.png"></p><p>PIN(Q)与CK有关的传播延时。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505225202893.png"></p><p>对于Q还在引脚级别定义了功耗。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505225253967.png"></p><p>这里的时序弧类型是负单边（negative unate）类型 </p><p>如果输入引脚上的上升沿跳变导致输出引脚电平下降（或不变），而输入引脚上的下降沿跳变导致输出引脚电平上升（或不变），则时序弧为负单边（negative unate）类型 。当复位有效时候，输输出变为0的延时时间。注意这里只有下降，很好理解，当你复位的时候，要是Q是0的话，也就不需要进行动作了。同时定义了max_capacitance。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505225606750.png"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505225645466.png"></p><p>对于引脚QN的时序模型。与Q的模型很类似，这里不进行分析。</p><p>总结一下对于DFFR的时序模型。CK对于D查建立时间，保持时间。对复位查恢复撤离时间，对于Q计算传播延时，对于CK本身，查脉冲宽度。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505225811130.png"></p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220505225934898.png"></p><p>至此，前面总结了STA的相关知识，这里对于DC综合标准单元lib库进行了学习，后续将开始<strong>时钟</strong>的学习。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h1&gt;&lt;p&gt;Synopsys_工艺库格式是事实上的库标准。对库格式和延时计算方法的基本理解是成功综合的关键Synopsys工艺库可分为两大类：&lt;br&gt;逻</summary>
      
    
    
    
    <category term="DC" scheme="http://example.com/categories/DC/"/>
    
    
    <category term="DC" scheme="http://example.com/tags/DC/"/>
    
  </entry>
  
  <entry>
    <title>为什么要搭建个人博客</title>
    <link href="http://example.com/2022/05/02/hexo/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2022/05/02/hexo/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2022-05-02T15:53:46.000Z</published>
    <updated>2022-05-02T17:48:03.137Z</updated>
    
    <content type="html"><![CDATA[<p>最开始写博客就是想着在一个随时自己可以访问的平台记录下自己的学习笔记，很多时候做过了事情你要是不总结，觉得会忘记。而且你做过以后这件事以后，再回头看你做过的东西，总是会觉得有很多的地方需要改进，或者是又有了新的思路。于是乎就找到了<a href="https://blog.csdn.net/qq_41467882?type=blog">CSDN</a>。这个平台真的很简单，注册就可以开始写博客啦。</p><p>或许这就是初心吧，好记性不如烂笔头，把事情记录下来。算是一种对于学习的回顾，又可以帮助到其他一起学习的同学，又可以收获粉丝点赞，有时候还真的可以感受到快乐。或者你写了很久以后回头看，这些或许都是自己努力的痕迹吧。或许只有自己会在乎，但其实已经够了。写作有时候或许是另一种孤独~</p><p>慢慢的通过这个过程，开始尽可能的梳理自己的思路，使得自己明白的东西以文字+图片的形式展示出来。从开始陌生，后面也慢慢变得熟悉起来，偶尔可以写出自己很满意的文章呢。笔者是一个有着轻微强迫症的人，一点点的事情卡住就不会再接下来继续进行，或者是一个细节自己觉得没有做好，总是会强行要求自己尽可能的完善……要开始慢慢学着与自己和解啦~</p><p>到了后来，偶然看到Github好像可以搭建一个自己的博客，但是由于自己并不是做软件相关的，而且当时并不会使用Git。</p><p>但后来大致学会了Git的使用，最近又有一些自己的时间，就决定做一个博客。</p><p>做一个自己的博客有这几个好处</p><ul><li>相对的自由，可以DIY网页内容与格式</li><li>更加促进自己的学习，是一个学习的动力</li><li>有一个私密的空间，没有人会关注一个小博主的仓库里是什么的</li><li>多一个学习的机会，可以了解到更多本领域以外的</li></ul><p>于是就决定搭建啦~</p><p>最初开始的时候选择的是大致看了看网上的资料，决定使用<code>Hexo+Github</code>进行搭建，后续将<code>github</code>的库直接同步到<code>gitee</code>，这样就有两个平台了，一定程度上保证了数据的安全。</p><p>其次是要清楚自身的定位。首先自己并不是做前端设计的，对于软件代码也并不是接触很多，因此并不能大改，只能一定程度上的小修小补。其次是笔者准备搭建一个个人博客，也并不需要太过于花里胡哨的，影响观看。只需要有基本的功能，简介即可，不能舍本逐末。因此观看了一些<code>hexo-theme</code>选择了主题<a href="https://github.com/shen-yu/hexo-theme-ayer">ayer</a>。<a href="https://shen-yu.gitee.io/">点击即可预览</a>。</p><p>欢迎来看看<a href="https://tyxiumud.github.io/">我的博客</a></p><p>建议后续搭建可以选择next或者<a href="https://github.com/jerryc127/hexo-theme-butterfly">butterfly</a>等比较大的，这类主题使用的人比较多，后续魔改的空间很大。版本号，star数目，提交次数等都是可以进行参考的，而且建议选择比较大众的主题。博主后续有时间的也会对博客进行美化与调整。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最开始写博客就是想着在一个随时自己可以访问的平台记录下自己的学习笔记，很多时候做过了事情你要是不总结，觉得会忘记。而且你做过以后这件事以后，再回头看你做过的东西，总是会觉得有很多的地方需要改进，或者是又有了新的思路。于是乎就找到了&lt;a href=&quot;https://blog.</summary>
      
    
    
    
    <category term="个人博客搭建" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="碎碎念" scheme="http://example.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>hexo-github-ayer搭建博客总结</title>
    <link href="http://example.com/2022/05/02/hexo/hexo-github-ayer%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/05/02/hexo/hexo-github-ayer%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-02T15:33:51.000Z</published>
    <updated>2022-05-02T16:30:15.336Z</updated>
    
    <content type="html"><![CDATA[<p>个人博客搭建的最初想法在这里已经进行了分享，这里</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;个人博客搭建的最初想法在这里已经进行了分享，这里&lt;/p&gt;
</summary>
      
    
    
    
    <category term="个人博客搭建" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="Hexo" scheme="http://example.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo博文写作——文章头的基本配置</title>
    <link href="http://example.com/2022/05/02/hexo/hexo%E5%8D%9A%E6%96%87%E5%86%99%E4%BD%9C%E2%80%94%E2%80%94%E6%96%87%E7%AB%A0%E5%A4%B4%E7%9A%84%E9%85%8D%E7%BD%AE%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/05/02/hexo/hexo%E5%8D%9A%E6%96%87%E5%86%99%E4%BD%9C%E2%80%94%E2%80%94%E6%96%87%E7%AB%A0%E5%A4%B4%E7%9A%84%E9%85%8D%E7%BD%AE%E5%9F%BA%E7%A1%80/</id>
    <published>2022-05-02T03:44:12.000Z</published>
    <updated>2022-05-02T16:29:40.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="完整的例子"><a href="#完整的例子" class="headerlink" title="完整的例子"></a>完整的例子</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: articlename</span><br><span class="line">date: 2022-05-02 11:44:12</span><br><span class="line">tags:</span><br><span class="line">- 标签1</span><br><span class="line">- 标签2</span><br><span class="line">categories:</span><br><span class="line">- 一级目录</span><br><span class="line">- 二级目录</span><br><span class="line">password: mikemessi</span><br><span class="line">top: true</span><br><span class="line">no_toc: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h1 id="目录与标签的格式设置"><a href="#目录与标签的格式设置" class="headerlink" title="目录与标签的格式设置"></a>目录与标签的格式设置</h1><p>完成博客搭建后，开始进行博文的写作，需要注意文章的标题头的设置。包括文章的title、data、categories、tags等一些属性。其中title，data是自动生成的。</p><p>如下案例所示，我们打开bash命令行，输入如下命令<code>hexo new articlename</code> 即可在你的对应目录下生成一个<code>.md</code>格式的文件，这时候可以在对应目录下找到该文件。</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220502114423427.png" alt="image-20220502114423427"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: articlename</span><br><span class="line">date: 2022-05-02 11:44:12</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>打开后的内容需要我们添加<code>categories、tags</code>属性，目录可以设置二级目录，标签可以设置多个标签。具体设置如下所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: articlename</span><br><span class="line">date: 2022-05-02 11:44:12</span><br><span class="line">tags:</span><br><span class="line">- 标签1</span><br><span class="line">- 标签2</span><br><span class="line">categories:</span><br><span class="line">- 一级目录</span><br><span class="line">- 二级目录</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>以上命令就可以使得博客生成对应的目录标签。</p><p>写博文，需要博文尽可能的方便管理，思路清晰，对于整个体系的博文，放在一起使得文章有一个清楚的结构框架。整理自己的思路的同时使得读者更清楚的接收到信息。因此对于一个主题应该有着明确的边界，确定该主题下是在说什么。对于标签的使用应该简单明确，同时具有一定的代表性。</p><h1 id="文章加密"><a href="#文章加密" class="headerlink" title="文章加密"></a>文章加密</h1><p>运行<code>npm install --save hexo-blog-encrypt</code></p><p>配置_config.yml文件。设置如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Security</span><br><span class="line">encrypt: # hexo-blog-encrypt</span><br><span class="line">  abstract: 有东西被加密了, 请输入密码查看.</span><br><span class="line">  message: 您好, 这里需要密码.</span><br><span class="line">  tags:</span><br><span class="line">  - &#123;name: tagName, password: 密码A&#125;</span><br><span class="line">  - &#123;name: tagName, password: 密码B&#125;</span><br><span class="line">  template: &lt;div id=&quot;hexo-blog-encrypt&quot; data-wpm=&quot;&#123;&#123;hbeWrongPassMessage&#125;&#125;&quot; data-whm=&quot;&#123;&#123;hbeWrongHashMessage&#125;&#125;&quot;&gt;&lt;div class=&quot;hbe-input-container&quot;&gt;&lt;input type=&quot;password&quot; id=&quot;hbePass&quot; placeholder=&quot;&#123;&#123;hbeMessage&#125;&#125;&quot; /&gt;&lt;label&gt;&#123;&#123;hbeMessage&#125;&#125;&lt;/label&gt;&lt;div class=&quot;bottom-line&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script id=&quot;hbeData&quot; type=&quot;hbeData&quot; data-hmacdigest=&quot;&#123;&#123;hbeHmacDigest&#125;&#125;&quot;&gt;&#123;&#123;hbeEncryptedData&#125;&#125;&lt;/script&gt;&lt;/div&gt;</span><br><span class="line">  wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.</span><br><span class="line">  wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.</span><br></pre></td></tr></table></figure><p>然后就可以使用文章加密的功能。使用实例如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: articlename</span><br><span class="line">date: 2022-05-02 11:44:12</span><br><span class="line">password: mikemessi</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h1 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm uninstall hexo-generator-index --save</span><br><span class="line">$ npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure><p>设置文章置顶可以直接设置 <code>top: true</code>即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">password: mikemessi</span><br><span class="line">top: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h1 id="不添加文章目录"><a href="#不添加文章目录" class="headerlink" title="不添加文章目录"></a>不添加文章目录</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">no_toc: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;完整的例子&quot;&gt;&lt;a href=&quot;#完整的例子&quot; class=&quot;headerlink&quot; title=&quot;完整的例子&quot;&gt;&lt;/a&gt;完整的例子&lt;/h1&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;cod</summary>
      
    
    
    
    <category term="个人博客搭建" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="Hexo" scheme="http://example.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo博文写作——Typora的使用</title>
    <link href="http://example.com/2022/05/02/hexo/hexo%E5%8D%9A%E6%96%87%E5%86%99%E4%BD%9C-Typora%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2022/05/02/hexo/hexo%E5%8D%9A%E6%96%87%E5%86%99%E4%BD%9C-Typora%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-05-02T03:36:08.000Z</published>
    <updated>2022-05-02T06:59:38.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo博文写作——Typora的使用"><a href="#hexo博文写作——Typora的使用" class="headerlink" title="hexo博文写作——Typora的使用"></a>hexo博文写作——Typora的使用</h1><p>Typora是一款Markdown编辑器，可以使得你的编辑所见即所得。Typora更多的快捷键以及可以和图床<code>PicGo</code>进行联合使用(图床就是专门用来存放图片，允许你把图片对外连接的网上空间)。从而方便的进行文本编辑而不需要去关心图片的管理问题。其次使用简单，方便，保存都是在本地进行管理，可以保证数据的安全，页面简介简单，功能非常强大。</p><p>简单来说有以下的优点：</p><ul><li>快捷键多，文本编辑速度快</li><li>图片管理极为方便</li><li>功能强大，页面简介</li></ul><p>接下来介绍安装，常用快捷键的使用，图床的设置与相关问题</p><h1 id="安装地址"><a href="#安装地址" class="headerlink" title="安装地址"></a>安装地址</h1><p><a href="https://support.typora.io/">Typora支持地址</a></p><p>官网<a href="https://typora.io/">下载地址</a></p><h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>在Typora中，也可以使用快捷键<code>Ctrl+1（2，3，4，5，6）</code>表示相对应的标题。<code>Ctrl+0</code>表示段落。</p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>一般使用的字体如下</p><table><thead><tr><th>字体描述</th><th>快捷键</th></tr></thead><tbody><tr><td><strong>黑体</strong></td><td><code>Ctrl+B</code></td></tr><tr><td><u>下划线</u></td><td><code>Ctrl+U</code></td></tr><tr><td><del>删除线</del></td><td><code>Alt+Shift+5</code></td></tr><tr><td><em>斜体</em></td><td><code>Ctrl+Shift+I</code></td></tr></tbody></table><p>选中字体使用快捷键即可，也可以直接使用后输入文本。</p><h3 id="文本颜色与大小"><a href="#文本颜色与大小" class="headerlink" title="文本颜色与大小"></a>文本颜色与大小</h3><p>可以使用使用<code>&lt;font&gt; &lt;/font&gt;</code>标签来改变字体的颜色及大小。</p><p>如下：所示</p><p><code>&lt;font size=3 color=&quot;red&quot;&gt;字体颜色为红色，大小为3&lt;/font&gt;</code></p><p><code>&lt;font size=4 color=&quot;blue&quot;&gt;字体颜色为蓝色，大小为4&lt;/font&gt;</code></p><p><code>&lt;font size=6 color=&quot;violet&quot;&gt;字体颜色为紫罗兰，大小为6&lt;/font&gt;</code></p><p><font size=3 color="red">字体颜色为红色，大小为3</font></p><p><font size=4 color="blue">字体颜色为蓝色，大小为4</font></p><p><font size=6 color="violet">字体颜色为紫罗兰，大小为6</font></p><h3 id="文本高亮"><a href="#文本高亮" class="headerlink" title="文本高亮"></a>文本高亮</h3><p>使用&#x3D;&#x3D;需要高亮的文字&#x3D;&#x3D;</p><p>注意，这里的高亮需要打开<code>文件-&gt;偏好设置</code>进行设置。或使用快捷键<code>Ctrl+，</code>直接打开,设置如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220501225730007.png"></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>使用<code>Ctrl+T</code>进行表格</p><table><thead><tr><th>说明</th><th>快捷键</th></tr></thead><tbody><tr><td>创建表格</td><td><code>Ctrl+T</code></td></tr><tr><td>删除行</td><td><code>Ctrl+Shift+Backspace</code></td></tr><tr><td>添加行</td><td><code>Ctrl+Enter</code></td></tr></tbody></table><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>可以添加有序列表与无序列表</p><table><thead><tr><th>列表</th><th>快捷键</th></tr></thead><tbody><tr><td>有序列表</td><td><code>Ctrl + Shift + [</code></td></tr><tr><td>无序列表</td><td><code>Ctrl + Shift + ]</code></td></tr></tbody></table><p>演示：</p><ol><li>有序列表1</li><li>有序列表2</li></ol><ul><li>无序列表1</li><li>无序列表2</li></ul><h2 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h2><p>一般使用两种方式进行舒适，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以快速使用代码栏目，使用快捷键Ctrl+Shift+K来进行设置</span><br></pre></td></tr></table></figure><p>较为短快捷键  <code>Ctrl+shift+</code></p><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>使用三个<code>---</code>来表示分割线</p><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>使用快捷键 <code>Ctrl+Shift+Q</code></p></blockquote><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>复制网址后直接使用快捷键<code>Ctrl+K</code></p><p>点击<a href="https://tyxiumud.github.io/">我的博客</a>跳转</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>直接使用<code>[TOC]</code>在文章的开头即可</p><h1 id="图床的设置于相关问题"><a href="#图床的设置于相关问题" class="headerlink" title="图床的设置于相关问题"></a>图床的设置于相关问题</h1><h3 id="安装与配置问题"><a href="#安装与配置问题" class="headerlink" title="安装与配置问题"></a>安装与配置问题</h3><p>建议这里使用<code>github+PicGo+CDN</code>搭建自己的图床，简单好用，免费。具体设置如下</p><h4 id="1，下载PicGo"><a href="#1，下载PicGo" class="headerlink" title="1，下载PicGo"></a>1，下载<code>PicGo</code></h4><p>github地址：<a href="https://github.com/Molunerfinn/picgo/releases">https://github.com/Molunerfinn/picgo/releases</a></p><p>选择latest版本即可，下载对应的版本，笔者使用的如下</p><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220502002103441.png"></p><p>下载完成后安装即可。</p><h4 id="2，软件配置"><a href="#2，软件配置" class="headerlink" title="2，软件配置"></a>2，软件配置</h4><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220502002941857.png" alt="软件配置"></p><p>获取你github上的Token，填入即可，然后设定你的自定义域名如下</p><p><code>https://cdn.jsdelivr.net/gh/</code>+<code>tyxiumud/blog.img</code></p><p>我的仓库名称。这里仓库的建立于Token获取方式自行百度。</p><h4 id="3，在Typora中使用"><a href="#3，在Typora中使用" class="headerlink" title="3，在Typora中使用"></a>3，在Typora中使用</h4><p><img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220502003324053.png"></p><p>这里验证上传选项要是验证不通过也不用担心，编辑界面可以点击图片上传或者图片会自动上传到你的仓库。</p><h4 id="4，将文章图片整理保存-建议"><a href="#4，将文章图片整理保存-建议" class="headerlink" title="4，将文章图片整理保存(建议)"></a>4，将文章图片整理保存(建议)</h4><p>数据无价，本地的或许是最安全的，每次写完一篇笔记文章建议进行对其中的图片进行保存</p><p><code>C:\Users\username\AppData\Roaming\Typora\typora-user-images</code>可以找到对应的图片。<img src="https://cdn.jsdelivr.net/gh/tyxiumud/blog.img/image-20220502003907502.png" alt="image-20220502003907502"></p><p>将其自行整理保存即可。</p><h2 id="CSDN-转存失败问题解决"><a href="#CSDN-转存失败问题解决" class="headerlink" title="CSDN 转存失败问题解决"></a>CSDN 转存失败问题解决</h2><p>将Typora的文章转到CSDN时候会出现问题。使用如下脚本替换图片显示的方式即可。<a href="https://blog.csdn.net/weixin_43578492/article/details/117087023?spm=1001.2014.3001.8078">参考链接</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">name = &quot;文章名称&quot;</span><br><span class="line">old_path = name+&quot;.md&quot;</span><br><span class="line">new_path = name+&quot;csdn&quot;+&quot;.md&quot;</span><br><span class="line">old_file = open(old_path, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;)</span><br><span class="line">new_file = open(new_path, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line">old_line = old_file.readline()</span><br><span class="line">count = 0</span><br><span class="line"></span><br><span class="line">while old_line:</span><br><span class="line">    if &quot;![&quot; in old_line:</span><br><span class="line">        url = re.findall(&#x27;https://.*png|https://.*jpeg|https://.*jpg&#x27;, old_line)</span><br><span class="line">        img = &#x27;&lt;img src=&quot;&#x27; + url[0] + &#x27;&quot;/&gt;&#x27;</span><br><span class="line">        new_line = re.sub(&#x27;!\[.*\)&#x27;, img, old_line)</span><br><span class="line">        new_file.write(new_line)</span><br><span class="line">        print(old_line + &#x27;   ===&gt;   &#x27; + new_line)</span><br><span class="line">        count += 1</span><br><span class="line">    else:</span><br><span class="line">        new_file.write(old_line)</span><br><span class="line">    old_line = old_file.readline()</span><br><span class="line"></span><br><span class="line">old_file.close()</span><br><span class="line">new_file.close()</span><br><span class="line"></span><br><span class="line">print(&#x27;\n已成功替换&#x27; + str(count) + &#x27;处外链问题&#x27;)</span><br></pre></td></tr></table></figure><p>最后输出的文件复制到csdn即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hexo博文写作——Typora的使用&quot;&gt;&lt;a href=&quot;#hexo博文写作——Typora的使用&quot; class=&quot;headerlink&quot; title=&quot;hexo博文写作——Typora的使用&quot;&gt;&lt;/a&gt;hexo博文写作——Typora的使用&lt;/h1&gt;&lt;p&gt;Ty</summary>
      
    
    
    
    <category term="个人博客搭建" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="Typora" scheme="http://example.com/tags/Typora/"/>
    
  </entry>
  
  <entry>
    <title>用GVIM/VIM写Verilog——VIM配置分享</title>
    <link href="http://example.com/2022/04/30/GVIM/%E7%94%A8GVIM-VIM%E5%86%99Verilog%E2%80%94%E2%80%94VIM%E9%85%8D%E7%BD%AE%E5%88%86%E4%BA%AB/"/>
    <id>http://example.com/2022/04/30/GVIM/%E7%94%A8GVIM-VIM%E5%86%99Verilog%E2%80%94%E2%80%94VIM%E9%85%8D%E7%BD%AE%E5%88%86%E4%BA%AB/</id>
    <published>2022-04-30T15:47:25.000Z</published>
    <updated>2022-05-02T06:52:01.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用GVIM-x2F-VIM写Verilog——VIM配置分享"><a href="#用GVIM-x2F-VIM写Verilog——VIM配置分享" class="headerlink" title="用GVIM&#x2F;VIM写Verilog——VIM配置分享"></a>用GVIM&#x2F;VIM写Verilog——VIM配置分享</h1><blockquote></blockquote><p>使用VIM或GVIＭ最基本的配置，不包含任何插件相关的设置，VIM用于写verilog，非常欢迎大家在评论区分享讨论。<br/> 本文不进行插件的配置，不进行基本使用方式与使用技巧的说明，仅作为基本配置的分享交流</p><h3 id="用GVIM-x2F-VIM写Verilog——VIM配置分享-1"><a href="#用GVIM-x2F-VIM写Verilog——VIM配置分享-1" class="headerlink" title="用GVIM&#x2F;VIM写Verilog——VIM配置分享"></a>用GVIM&#x2F;VIM写Verilog——VIM配置分享</h3><h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set nocompatible &quot;不兼容vi</span><br><span class="line">syntax on  &quot;语法高亮度显示 </span><br><span class="line">set noerrorbells &quot; 不让vim发出讨厌的滴滴声 </span><br><span class="line">set shortmess=atI &quot; 启动的时候不显示那个援助索马里儿童的提示 </span><br><span class="line">set t_Co=256  &quot;开启256色支持</span><br><span class="line">set hlsearch  &quot;搜索设置高亮</span><br><span class="line">colorscheme desert &quot;配色方案</span><br><span class="line">set background=dark &quot;配置主题整体的色调，只有两个选择：dark和light（暗色调和亮色调）</span><br><span class="line">highlight Function cterm=bold,underline ctermbg=red ctermfg=green &quot;color set</span><br><span class="line">set nu  &quot;显示行号</span><br><span class="line">set relativenumber &quot;显示相对行号</span><br><span class="line">set cursorcolumn &quot;add cursor in column</span><br><span class="line">set cursorline &quot;add cursor in line </span><br><span class="line">&quot;set guifont=Monospace\ 16 &quot;gui style</span><br><span class="line">set guifont=Courier_new:h16</span><br><span class="line">set lines=35 columns=118 &quot;其中lines是窗口显示的行数，columns是窗口显示的列数</span><br><span class="line">winpos 200 100 &quot;后面两个参数指的自屏幕左上角像素值参考位置</span><br><span class="line">set tabstop=4 &quot;tab键相当于4个空格键</span><br><span class="line">set expandtab &quot;來將 tab 转成 space  combine with tabstop</span><br><span class="line">set shiftwidth=4 &quot;换行自动变为空格</span><br><span class="line">set autoindent &quot;设置自动缩进  自动缩进，当你第一行敲 tab + 文字 回车后 下一行自动给你加个 tab </span><br><span class="line">set backspace=2 &quot;enable backspace</span><br><span class="line">set novisualbell &quot;不要闪烁</span><br><span class="line">set laststatus=2 &quot;启动显示状态行</span><br><span class="line">set encoding=utf-8 &quot;文件编码</span><br><span class="line">set completeopt=menu,preview,longest &quot;自动补全相关的设置</span><br><span class="line">&quot;不要生成swap文件，当buffer被丢弃的时候隐藏它</span><br><span class="line">set local noswapfile</span><br><span class="line">set bufhidden=hide</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inoremap ( ()&amp;lt;ESC&amp;gt;i</span><br><span class="line">inoremap [ []&amp;lt;ESC&amp;gt;i</span><br><span class="line"></span><br><span class="line">&quot;ban up and also keys </span><br><span class="line">imap &amp;lt;Up&amp;gt; &amp;lt;Nop&amp;gt;</span><br><span class="line">imap &amp;lt;Down&amp;gt; &amp;lt;Nop&amp;gt;</span><br><span class="line">imap &amp;lt;Left&amp;gt; &amp;lt;Nop&amp;gt;</span><br><span class="line">imap &amp;lt;Right&amp;gt; &amp;lt;Nop&amp;gt;</span><br><span class="line">nmap &amp;lt;Up&amp;gt; &amp;lt;Nop&amp;gt;</span><br><span class="line">nmap &amp;lt;Down&amp;gt; &amp;lt;Nop&amp;gt;</span><br><span class="line">nmap &amp;lt;Left&amp;gt; &amp;lt;Nop&amp;gt;</span><br><span class="line">nmap &amp;lt;Right&amp;gt; &amp;lt;Nop&amp;gt;</span><br><span class="line"></span><br><span class="line">imap jk &amp;lt;Esc&amp;gt;  &quot;在编辑模式下使用jk替代ESC进入命令模式</span><br><span class="line">imap &amp;lt;C-L&amp;gt; &amp;lt;C-X&amp;gt;&amp;lt;C-L&amp;gt; “使用CTRL L 代替 CTRL X ＋CTRL L 就是整个句子的补全</span><br><span class="line">nmap ,l ^</span><br><span class="line">nmap ,r $</span><br><span class="line"></span><br><span class="line">&quot;进行版权声明的设置</span><br><span class="line">&quot;添加或更新头</span><br><span class="line">map &amp;lt;F3&amp;gt; :call TitleDet()&amp;lt;cr&amp;gt;&#x27;s</span><br><span class="line">function AddTitle()</span><br><span class="line">    call append(0,&quot;/*=============================================================================&quot;)</span><br><span class="line">    call append(1,&quot;#&quot;)</span><br><span class="line">    call append(2,&quot;# Author: meng  - email@vip.qq.com&quot;)</span><br><span class="line">    call append(3,&quot;#&quot;)</span><br><span class="line">    call append(4,&quot;# QQ : xxxxxxxxx &quot;)</span><br><span class="line">    call append(5,&quot;#&quot;)</span><br><span class="line">    call append(6,&quot;# Last modified: &quot;.strftime(&quot;%Y-%m-%d %H:%M&quot;))</span><br><span class="line">    call append(7,&quot;#&quot;)</span><br><span class="line">    call append(8,&quot;# Filename: &quot;.expand(&quot;%:t&quot;))</span><br><span class="line">    call append(9,&quot;#&quot;)</span><br><span class="line">    call append(10,&quot;# Description: &quot;)</span><br><span class="line">    call append(11,&quot;#&quot;)</span><br><span class="line">    call append(12,&quot;=============================================================================*/&quot;)</span><br><span class="line">    echohl WarningMsg | echo &quot;Successful in adding the copyright.&quot; | echohl None</span><br><span class="line">endf</span><br><span class="line">&quot;更新最近修改时间和文件名</span><br><span class="line">function UpdateTitle()</span><br><span class="line">    normal m&#x27;</span><br><span class="line">    execute &#x27;/# *Last modified:/s@:.*$@\=strftime(&quot;:\t%Y-%m-%d %H:%M&quot;)@&#x27;</span><br><span class="line">    normal &#x27;&#x27;</span><br><span class="line">    normal mk</span><br><span class="line">    execute &#x27;/# *Filename:/s@:.*$@\=&quot;:\t\t&quot;.expand(&quot;%:t&quot;)@&#x27;</span><br><span class="line">    execute &quot;noh&quot;</span><br><span class="line">    normal &#x27;k</span><br><span class="line">    echohl WarningMsg | echo &quot;Successful in updating the copy right.&quot; | echohl None</span><br><span class="line">endfunction</span><br><span class="line">&quot;判断前10行代码里面，是否有Last modified这个单词，</span><br><span class="line">&quot;如果没有的话，代表没有添加过作者信息，需要新添加；</span><br><span class="line">&quot;如果有的话，那么只需要更新即可</span><br><span class="line">function TitleDet()</span><br><span class="line">    let n=1</span><br><span class="line">    &quot;默认为添加</span><br><span class="line">    while n &amp;lt; 10</span><br><span class="line">        let line = getline(n)</span><br><span class="line">        if line =~ &#x27;^\#\s*\S*Last\smodified:\S*.*$&#x27;</span><br><span class="line">            call UpdateTitle()</span><br><span class="line">            return</span><br><span class="line">        endif</span><br><span class="line">        let n = n + 1</span><br><span class="line">    endwhile</span><br><span class="line">    call AddTitle()</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure><h1 id="几点说明"><a href="#几点说明" class="headerlink" title="几点说明"></a>几点说明</h1><h2 id="1，禁用方向键，使用-jk-代替ESC"><a href="#1，禁用方向键，使用-jk-代替ESC" class="headerlink" title="1，禁用方向键，使用 jk 代替ESC"></a>1，禁用方向键，使用 jk 代替ESC</h2><p>在VIN中操作，为了使得双手脱离键盘，但是方向键距离手指较远，ESC同样，因此禁用掉方向键，同时使用jk代替ESC进入命令模式。<br/> VIM中有三种模式：命令模式，输入模式，命令行模式，其<a href="https://www.cnblogs.com/helloweworld/p/3525905.html">map映射</a><br/> 在vim配置文件中经常会看到map、nmap、imap<br/> n ——表示在普通模式下生效。<br/> v ——表示在可视模式下生效。<br/> i ——表示在插入模式下效。<br/> 具体配置方式见上</p><h2 id="2，自动补全命令配置"><a href="#2，自动补全命令配置" class="headerlink" title="2，自动补全命令配置"></a>2，自动补全命令配置</h2><p>当我按下a的时候，弹出的提示框是包含所有a开头的提示，但是编辑器上只有a和光标，这个时候如果我需要再次使用b来进行过滤直接敲入b，编辑器上就是ab和光标，过滤出来的就是ab开头的单词。<br/> <img src="https://img-blog.csdnimg.cn/94cddb804f1047768c9935774bf4ecdd.png" alt="&lt;br/&gt; 该设置摘自[vim自动补全的问题](https://www.douban.com/group/topic/26633511/)&lt;br/&gt; 设置行命令补时候，直接使用Ctrl-l即可，不用使用Ctrl-x Ctrl-l"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">imap &amp;lt;C-L&amp;gt; &amp;lt;C-X&amp;gt;&amp;lt;C-L&amp;gt;</span><br></pre></td></tr></table></figure><h2 id="3，进行版权声明的设置"><a href="#3，进行版权声明的设置" class="headerlink" title="3，进行版权声明的设置"></a>3，进行版权声明的设置</h2><p>改声明摘自博客，可以继续进行完善，使用F3即可调用</p><h2 id="4，一些其他映射"><a href="#4，一些其他映射" class="headerlink" title="4，一些其他映射"></a>4，一些其他映射</h2><p>“调整格式以便对齐（例化后的）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:map &amp;lt;F6&amp;gt; :s/^ *\./        ./&amp;lt;cr&amp;gt;^f(i                              &amp;lt;ESC&amp;gt;f)i                               &amp;lt;ESC&amp;gt;^24ldw24ldwa  &amp;lt;ESC&amp;gt;hdwj</span><br></pre></td></tr></table></figure><p>GVIM配置自动调整将F6映射为后面一长串指令，具体指令可以自行尝试</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;用GVIM-x2F-VIM写Verilog——VIM配置分享&quot;&gt;&lt;a href=&quot;#用GVIM-x2F-VIM写Verilog——VIM配置分享&quot; class=&quot;headerlink&quot; title=&quot;用GVIM&amp;#x2F;VIM写Verilog——VIM配置分享&quot;</summary>
      
    
    
    
    <category term="文本编辑器" scheme="http://example.com/categories/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
    
    <category term="GVIM" scheme="http://example.com/tags/GVIM/"/>
    
  </entry>
  
  <entry>
    <title>IC设计EDA软件虚拟机环境配置与安装教程</title>
    <link href="http://example.com/2022/04/28/ic_eda/IC%E8%AE%BE%E8%AE%A1EDA%E8%BD%AF%E4%BB%B6%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2022/04/28/ic_eda/IC%E8%AE%BE%E8%AE%A1EDA%E8%BD%AF%E4%BB%B6%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</id>
    <published>2022-04-28T12:04:59.000Z</published>
    <updated>2022-05-28T12:04:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>IC学习的时候，需要搭建的EDA环境。以数字电路设计为例，需要进行代码编写，验证仿真，综合，形式验证，后端综合等，相关软件，本博文分享一篇EETOP论坛网友ZHZIC分享的安装方式与资源，笔者自行依据教程进行安装，可以运行相关数字设计所需要用的软件。<br>EDA虚拟机仅供个人学习使用，且为免费使用，切勿商用。如果商用，请购买正版工具。使用者禁止私自售卖该虚拟机，带来的侵权后果由使用者自行承担。</p></blockquote><p>先给我的环境。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1WfbL6dcHg7nKVTDGq9hOzQ </span><br><span class="line">提取码：nnsq </span><br></pre></td></tr></table></figure><p>目前已经集成了数字，模拟相关的基本工具，工艺库如下。</p><p>├── Cdence<br>│   ├── IC617<br>│   ├── IScape<br>│   ├── license<br>│   └── MMSIM151<br>├── iso<br>├── lib<br>│   ├── SMIC_018_MMRF_oa<br>│   └── tsmc180rf<br>├── Mentor<br>│   ├── calibre2018<br>│   └── license<br>├── Package<br>│   ├── cadence<br>│   └── synopsys2018<br>├── patch<br>└── Synopsys<br>    ├── Formality2018<br>    ├── ICC2018<br>    ├── installer<br>    ├── LC2018<br>    ├── PrimeTime2018<br>    ├── SCL_2018<br>    ├── SpyGlass2016<br>    ├── Starrc2018<br>    ├── syn2018<br>    ├── VCS2018<br>    └── Verdi2018</p><p>现在的资源太多了，自己去找，会找到很多，不知道有用没用的，下面的教程笔者经过尝试可以安装运行。教程步骤非常齐全，且论坛坛友评价也很不错。链接如下<br>1，博文的推荐与安装方式<br><a href="http://bbs.eetop.cn/thread-897274-1-1.html">EDA软件安装教程，包括RHEL7.8、cadence软件、calibre、s家软件</a><br>2，SpyGlass的安装<br><a href="http://bbs.eetop.cn/thread-627969-1-1.html">SpyGlass2016.06安装破解教程</a><br>3，笔者安装环境展示<br><img src="https://img-blog.csdnimg.cn/37ad1535831f489ea48962f716ca53cb.png" alt="测试文章图片1"><br><img src="https://img-blog.csdnimg.cn/289eb3a412b44e23b56004db646ff593.png"><br><img src="https://img-blog.csdnimg.cn/817f3c43bd024911a8dccedacc522621.png"></p><p>最后，根据教程，可以完成GVIM，SpyGalass,VCS，Verdi，DC，PT，FM，ICC等主要是数字相关的软件。有需要笔者可以提供安装好的虚拟机资源。后续笔者会提供各个软件使用的教程，主要是官方UG（User Guide）或者是SU（Student Guide）的lab学习总结或者是自行学习总结的小demo。<br>最后，感谢以上同学无私分享。</p><p>其他：<br>1，下面是自己在eetop开的帖子，有进一步问题可以进行参考。<a href="https://bbs.eetop.cn/thread-919520-1-1.html">全套数字模拟设计EDA环境。带模拟工艺库</a><br>VM版本笔者使用的链接如下，带破解安装教程。要是有可以使用自己的即可。最开始使用的时候选择我已移动虚拟机。否则无法使用。会导致破解失败！！！</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1H1gmtQf6GTGVczGQP1j_5g</span><br><span class="line">提取码：e61y</span><br></pre></td></tr></table></figure><p>2，模拟的工艺库配置参考链接如下<br><a href="https://blog.csdn.net/weixin_44115643/article/details/118930454">Cadence Virtuoso IC617的启动和新建工程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;IC学习的时候，需要搭建的EDA环境。以数字电路设计为例，需要进行代码编写，验证仿真，综合，形式验证，后端综合等，相关软件，本博文分享一篇EETOP论坛网友ZHZIC分享的安装方式与资源，笔者自行依据教程进行安装，可以运行相关数字设计所需要用的软件</summary>
      
    
    
    
    <category term="数字IC设计" scheme="http://example.com/categories/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="EDA环境搭建" scheme="http://example.com/categories/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1/EDA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="数字IC环境配置" scheme="http://example.com/tags/%E6%95%B0%E5%AD%97IC%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>RedHat Linux 7安装CentOS 7 yum源</title>
    <link href="http://example.com/2022/04/28/ic_eda/RedHat%20Linux%207%E5%AE%89%E8%A3%85CentOS%207%20yum%E6%BA%90/"/>
    <id>http://example.com/2022/04/28/ic_eda/RedHat%20Linux%207%E5%AE%89%E8%A3%85CentOS%207%20yum%E6%BA%90/</id>
    <published>2022-04-28T10:26:34.000Z</published>
    <updated>2022-05-02T06:50:17.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>使用yum进行安装软件的时候报错</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Loaded plugins: langpacks, product-id, search-disabled-repos, subscription-manager</span><br><span class="line">This system is not registered with an entitlement server. You can use subscription-manager to register.</span><br></pre></td></tr></table></figure><p>yum 是一个软件安装管理的机制，通常情况下安装软件需要连接到网络上，从网络上的软件库进行软件的下载及安装，但是 RHEL 系统只有注册的用户才能用 yum 机制进行线上安装，可以直接将将 RHEL7 的 yum 源换成 Centos7 的。就可以进行安装了。</p><h1 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h1><h2 id="0，进入-x2F-opt目录，进入root模式，新建yum目录"><a href="#0，进入-x2F-opt目录，进入root模式，新建yum目录" class="headerlink" title="0，进入&#x2F;opt目录，进入root模式，新建yum目录"></a>0，进入&#x2F;opt目录，进入root模式，新建yum目录</h2><p><img src="https://img-blog.csdnimg.cn/fc214cfdf56e44e38b824e4a39b57b2d.png" alt="在这里插入图片描述"></p><h2 id="1，查看自己redhat版本"><a href="#1，查看自己redhat版本" class="headerlink" title="1，查看自己redhat版本"></a>1，查看自己redhat版本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/redhat-release</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/892387f5b703417098a222cc6a378f11.png" alt="在这里插入图片描述"><br>要是版本一致后续的操作与博主一致，不一致的需要自行进行略微的改动。</p><h2 id="2，查看redhat-7-0系统本身所安装的那些yum-软件包并将其一一删除"><a href="#2，查看redhat-7-0系统本身所安装的那些yum-软件包并将其一一删除" class="headerlink" title="2，查看redhat 7.0系统本身所安装的那些yum 软件包并将其一一删除"></a>2，查看redhat 7.0系统本身所安装的那些yum 软件包并将其一一删除</h2><p>查看已经安装的软件包</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep yum</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/02855ac9303142b18b5cb480c69690a8.png" alt="在这里插入图片描述"><br>删除<br>将黑体换为以上安装的软件包，将其意义删除<br>rpm -e <strong>yum-rhn-plugin-2.0.1-10.el7.noarch</strong> –nodeps<br>也可以使用如下命令，将其一次删除完<br>rpm -e PackageKit-yum-1.1.10-2.el7.x86_64 yum-3.4.3-167.el7.noarch  –nodeps</p><p>可重新查看，检查是否已经去全部删除，确保已经完全删除</p><h2 id="3，确定自己的虚拟机可以上网"><a href="#3，确定自己的虚拟机可以上网" class="headerlink" title="3，确定自己的虚拟机可以上网"></a>3，确定自己的虚拟机可以上网</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/11e99542f04d455e86b35da8087324ea.png" alt="在这里插入图片描述"><br>使用<code>Ctrl+C</code>可以终止访问</p><h2 id="4，找到自己系统所对应的文件包版本更新"><a href="#4，找到自己系统所对应的文件包版本更新" class="headerlink" title="4，找到自己系统所对应的文件包版本更新"></a>4，找到自己系统所对应的文件包版本更新</h2><p>下载的网站为  <a href="http://mirrors.163.com/">http://mirrors.163.com/</a></p><p>进入找到你自己版本的对应文件，注意下载的需要与你上面删除的一致。CentOS几乎和RedHat是一样的，所以无需担心软件包是否可安装。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://mirrors.163.com/centos/7/os/x86_64/Packages/PackageKit-yum-1.1.10-2.el7.centos.x86_64.rpm</span><br><span class="line">wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-3.4.3-168.el7.centos.noarch.rpm</span><br><span class="line">wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-langpacks-0.4.2-7.el7.noarch.rpm</span><br><span class="line">wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-metadata-parser-1.1.4-10.el7.x86_64.rpm</span><br><span class="line">wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-rhn-plugin-2.0.1-10.el7.noarch.rpm</span><br><span class="line">wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-utils-1.1.31-54.el7_8.noarch.rpm</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5d451b63adeb432691a5da30834ed3d4.png" alt="在这里插入图片描述"></p><h2 id="5，查看已经下载的文件"><a href="#5，查看已经下载的文件" class="headerlink" title="5，查看已经下载的文件"></a>5，查看已经下载的文件</h2><p><img src="https://img-blog.csdnimg.cn/037eb47f34084444ad36ff2806b9bbcb.png" alt="在这里插入图片描述"></p><h2 id="6，安装软件包"><a href="#6，安装软件包" class="headerlink" title="6，安装软件包"></a>6，安装软件包</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh *.rpm --force --nodeps</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/3b2f31ed764048c2a508c2d6cf44a97e.png" alt="在这里插入图片描述"></p><h2 id="7，新建repo-配置文件"><a href="#7，新建repo-配置文件" class="headerlink" title="7，新建repo 配置文件"></a>7，新建repo 配置文件</h2><p>新建一个终端，进入超级用户模式，进入目录<code>cd /etc/yum.repos.d/</code><br>编辑文件<code>gedit CentOS-Base.repo</code>在弹出的文本框输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#CentOS-Base.repo</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The mirror system uses the connecting IP address of the client and the</span></span><br><span class="line"><span class="comment"># update status of each mirror to pick mirrors that are updated to and</span></span><br><span class="line"><span class="comment"># geographically close to the client.  You should use this for CentOS updates</span></span><br><span class="line"><span class="comment"># unless you are manually picking other mirrors.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If the mirrorlist= does not work for you, as a fall back you can try the</span></span><br><span class="line"><span class="comment"># remarked out baseurl= line instead.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">[base]</span><br><span class="line">name=CentOS-<span class="variable">$7</span> - Base - 163.com</span><br><span class="line"><span class="comment">#mirrorlist=http://mirrorlist.centos.org/?release=$7&amp;arch=$basearch&amp;repo=os</span></span><br><span class="line">baseurl=http://mirrors.163.com/centos/7/os/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line"><span class="comment">#released updates</span></span><br><span class="line">[updates]</span><br><span class="line">name=CentOS-<span class="variable">$7</span> - Updates - 163.com</span><br><span class="line"><span class="comment">#mirrorlist=http://mirrorlist.centos.org/?release=$7&amp;arch=$basearch&amp;repo=updates</span></span><br><span class="line">baseurl=http://mirrors.163.com/centos/7/updates/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line"><span class="comment">#additional packages that may be useful</span></span><br><span class="line">[extras]</span><br><span class="line">name=CentOS-<span class="variable">$7</span> - Extras - 163.com</span><br><span class="line"><span class="comment">#mirrorlist=http://mirrorlist.centos.org/?release=$7&amp;arch=$basearch&amp;repo=extras</span></span><br><span class="line">baseurl=http://mirrors.163.com/centos/7/extras/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line"><span class="comment">#additional packages that extend functionality of existing packages</span></span><br><span class="line">[centosplus]</span><br><span class="line">name=CentOS-<span class="variable">$7</span> - Plus - 163.com</span><br><span class="line">baseurl=http://mirrors.163.com/centos/7/centosplus/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7</span><br></pre></td></tr></table></figure><p>保存退出<img src="https://img-blog.csdnimg.cn/e6acbf67982a485ab52b1977bf7b438e.png" alt="在这里插入图片描述"></p><h2 id="8，清除缓存"><a href="#8，清除缓存" class="headerlink" title="8，清除缓存"></a>8，清除缓存</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum clean all</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/ffb0db9781964d198052ad1bd2a6195d.png" alt="在这里插入图片描述"></p><h2 id="9，尝试安装Gvim，测试可以正常使用"><a href="#9，尝试安装Gvim，测试可以正常使用" class="headerlink" title="9，尝试安装Gvim，测试可以正常使用"></a>9，尝试安装Gvim，测试可以正常使用</h2><p>使用如下<code>yum -y install gvim</code><br><img src="https://img-blog.csdnimg.cn/c8c7aed6189e4f7bae6826c41f4fa9e3.png" alt="在这里插入图片描述"><br>安装等待，完成时候会出现Complete！<br><img src="https://img-blog.csdnimg.cn/b01af2b383ec4347b7d42af05ec68f43.png"></p><p>打开一个终端，输入<code>gvim</code>键入<code>:q</code>退出<br><img src="https://img-blog.csdnimg.cn/cca38f3a3ca54914ad0c8155092778e9.png" alt="在这里插入图片描述"></p><h2 id="10，删除下载的安装包与yum目录"><a href="#10，删除下载的安装包与yum目录" class="headerlink" title="10，删除下载的安装包与yum目录"></a>10，删除下载的安装包与yum目录</h2><p><img src="https://img-blog.csdnimg.cn/60ab0fd1c4f246d59b5baf8f33a3f8fb.png" alt="在这里插入图片描述"></p><h1 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h1><p><a href="https://www.linuxidc.com/Linux/2017-04/142444.htm">RedHat Linux 7安装CentOS 7 yum源</a><br><a href="https://blog.csdn.net/u010194538/article/details/77855103">rpm安装软件时提示warning: *.rpm: Header V3 RSA&#x2F;SHA256 Signature, keykey ID c105b9de:</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;使用yum进行安装软件的时候报错&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr</summary>
      
    
    
    
    <category term="数字IC设计" scheme="http://example.com/categories/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="EDA环境搭建" scheme="http://example.com/categories/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1/EDA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="数字IC环境配置" scheme="http://example.com/tags/%E6%95%B0%E5%AD%97IC%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>sv_labs学习笔记——sv_lab5_下(System Verilog)</title>
    <link href="http://example.com/2022/01/07/sv_labs/sv_labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94sv_lab5_%E4%B8%8B(System%20Verilog)/"/>
    <id>http://example.com/2022/01/07/sv_labs/sv_labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94sv_lab5_%E4%B8%8B(System%20Verilog)/</id>
    <published>2022-01-07T07:33:38.000Z</published>
    <updated>2022-05-02T14:20:05.027Z</updated>
    
    <content type="html"><![CDATA[<blockquote></blockquote><p>本文延续前一篇<a href="https://blog.csdn.net/qq_41467882/article/details/122334222">sv_labs学习笔记——sv_lab5_上(System Verilog）</a>，进一步学习完善lab5的内容</p><h1 id="思路梳理"><a href="#思路梳理" class="headerlink" title="思路梳理"></a>思路梳理</h1><p>计划本博文实现Packet的介绍，Reciver的介绍以及scoreboard。我们在前一节完成了数据的发送，然后执行接收，最后进行数据的比对。</p><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><h2 id="Packet-sv"><a href="#Packet-sv" class="headerlink" title="Packet.sv"></a>Packet.sv</h2><p>packet与前面的基本保持一致。就是用本身的发送的Packet与接收的packet包进行比较。每次比较就是一包一包的比较。这里只是函数的定义，后续在scoreboard进行比较。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">`ifndef INC_PACKET_SV</span><br><span class="line">`define INC_PACKET_SV</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Packet</span>;</span></span><br><span class="line">  rand bit[<span class="number">3</span>:<span class="number">0</span>] sa, da;         <span class="comment">// random port selection</span></span><br><span class="line">  rand logic[<span class="number">7</span>:<span class="number">0</span>] payload[$];<span class="comment">// random payload array</span></span><br><span class="line">       <span class="built_in">string</span>   name;<span class="comment">// unique identifier</span></span><br><span class="line"></span><br><span class="line">  constraint Limit &#123;</span><br><span class="line">    sa inside &#123;[<span class="number">0</span>:<span class="number">15</span>]&#125;;</span><br><span class="line">    da inside &#123;[<span class="number">0</span>:<span class="number">15</span>]&#125;;</span><br><span class="line">    payload.size() inside &#123;[<span class="number">2</span>:<span class="number">4</span>]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> function <span class="title function_">new</span><span class="params">(<span class="built_in">string</span> name = <span class="string">&quot;Packet&quot;</span>)</span>;</span><br><span class="line">  <span class="keyword">extern</span> function bit <span class="title function_">compare</span><span class="params">(Packet pkt2cmp, ref <span class="built_in">string</span> message)</span>;</span><br><span class="line">  <span class="keyword">extern</span> function <span class="type">void</span> <span class="title function_">display</span><span class="params">(<span class="built_in">string</span> prefix = <span class="string">&quot;NOTE&quot;</span>)</span>;</span><br><span class="line">endclass</span><br><span class="line"></span><br><span class="line">function <span class="title function_">Packet::new</span><span class="params">(<span class="built_in">string</span> name)</span>;</span><br><span class="line">  this.name = name;</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">function bit <span class="title function_">Packet::compare</span><span class="params">(Packet pkt2cmp, ref <span class="built_in">string</span> message)</span>;</span><br><span class="line">  <span class="keyword">if</span> (payload.size() != pkt2cmp.payload.size()) begin</span><br><span class="line">    message = <span class="string">&quot;Payload Size Mismatch:\n&quot;</span>;</span><br><span class="line">    message = &#123; message, $psprintf(<span class="string">&quot;payload.size() = %0d, pkt2cmp.payload.size() = %0d\n&quot;</span>, payload.size(), pkt2cmp.payload.size()) &#125;;</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">  end</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(payload == pkt2cmp.payload)</span> ;</span><br><span class="line">    <span class="keyword">else</span> begin</span><br><span class="line">      message = <span class="string">&quot;Payload Content Mismatch:\n&quot;</span>;</span><br><span class="line">      message = &#123; message, $psprintf(<span class="string">&quot;Packet Sent:  %p\nPkt Received: %p&quot;</span>, payload, pkt2cmp.payload) &#125;;</span><br><span class="line">      <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">    end</span><br><span class="line">  message = <span class="string">&quot;Successfully Compared&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">function <span class="type">void</span> <span class="title function_">Packet::display</span><span class="params">(<span class="built_in">string</span> prefix)</span>;</span><br><span class="line">  $display(<span class="string">&quot;[%s]%t %s sa = %0d, da = %0d&quot;</span>, prefix, $realtime, name, sa, da);</span><br><span class="line">  foreach(payload[i])</span><br><span class="line">    $display(<span class="string">&quot;[%s]%t %s payload[%0d] = %0d&quot;</span>, prefix, $realtime, name, i, payload[i]);</span><br><span class="line">endfunction</span><br><span class="line">`endif</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ReceiverBase-sv"><a href="#ReceiverBase-sv" class="headerlink" title="ReceiverBase.sv"></a>ReceiverBase.sv</h2><p>ReceiverBase就是lab4前面的。基本上没有什么改变。该class会将接口的数据放到pkt2cmp中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">`ifndef INC_RECEIVERBASE_SV</span><br><span class="line">`define INC_RECEIVERBASE_SV</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiverBase</span>;</span></span><br><span class="line">  virtual router_io.TB rtr_io;<span class="comment">// interface signals</span></span><br><span class="line">  <span class="built_in">string</span>   name;<span class="comment">// unique identifier</span></span><br><span class="line">  bit[<span class="number">3</span>:<span class="number">0</span>] da;<span class="comment">// output port to monitor</span></span><br><span class="line">  logic[<span class="number">7</span>:<span class="number">0</span>] pkt2cmp_payload[$];<span class="comment">// actual payload array</span></span><br><span class="line">  Packet   pkt2cmp;<span class="comment">// actual Packet object</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> function <span class="title function_">new</span><span class="params">(<span class="built_in">string</span> name = <span class="string">&quot;ReceiverBase&quot;</span>, virtual router_io.TB rtr_io)</span>;</span><br><span class="line">  <span class="keyword">extern</span> virtual task <span class="title function_">recv</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">extern</span> virtual task <span class="title function_">get_payload</span><span class="params">()</span>;</span><br><span class="line">endclass</span><br><span class="line"></span><br><span class="line">function <span class="title function_">ReceiverBase::new</span><span class="params">(<span class="built_in">string</span> name, virtual router_io.TB rtr_io)</span>;</span><br><span class="line">  <span class="keyword">if</span> (TRACE_ON) $display(<span class="string">&quot;[TRACE]%t %s:%m&quot;</span>, $realtime, name);</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.rtr_io = rtr_io;</span><br><span class="line">  this.pkt2cmp = new();</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">task <span class="title function_">ReceiverBase::recv</span><span class="params">()</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> pkt_cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (TRACE_ON) $display(<span class="string">&quot;[TRACE]%t %s:%m&quot;</span>, $realtime, this.name);</span><br><span class="line">  this.get_payload();</span><br><span class="line">  this.pkt2cmp.da = da;</span><br><span class="line">  this.pkt2cmp.payload = this.pkt2cmp_payload;</span><br><span class="line">  this.pkt2cmp.name = $psprintf(<span class="string">&quot;rcvdPkt[%0d]&quot;</span>, pkt_cnt++);</span><br><span class="line">endtask</span><br><span class="line"></span><br><span class="line">task <span class="title function_">ReceiverBase::get_payload</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">if</span> (TRACE_ON) $display(<span class="string">&quot;[TRACE]%t %s:%m&quot;</span>, $realtime, this.name);</span><br><span class="line">  this.pkt2cmp_payload.delete();</span><br><span class="line">  fork</span><br><span class="line">    begin: wd_timer_fork</span><br><span class="line">    fork: frameo_wd_timer</span><br><span class="line">      @(negedge this.rtr_io.cb.frameo_n[da]);</span><br><span class="line">      begin</span><br><span class="line">        <span class="title function_">repeat</span><span class="params">(<span class="number">10000</span>)</span> @<span class="params">(rtr_io.cb)</span>;</span><br><span class="line">        $display(<span class="string">&quot;\n%m\n[ERROR]%t Frame signal timed out!\n&quot;</span>, $realtime);</span><br><span class="line">        $finish;</span><br><span class="line">      end</span><br><span class="line">    join_any: frameo_wd_timer</span><br><span class="line">    disable fork;</span><br><span class="line">    end: wd_timer_fork</span><br><span class="line">  join</span><br><span class="line">  forever begin</span><br><span class="line">    logic[<span class="number">7</span>:<span class="number">0</span>] datum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&amp;lt;<span class="number">8</span>; ) begin</span><br><span class="line">      <span class="title function_">if</span> <span class="params">(!this.rtr_io.cb.valido_n[da])</span></span><br><span class="line">        datum[i++] = this.rtr_io.cb.dout[da];</span><br><span class="line">      <span class="keyword">if</span> (this.rtr_io.cb.frameo_n[da])</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">8</span>) begin</span><br><span class="line">          this.pkt2cmp_payload.push_back(datum);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        end</span><br><span class="line">        <span class="keyword">else</span> begin</span><br><span class="line">          $display(<span class="string">&quot;\n%m\n[ERROR]%t Packet payload not byte aligned!\n&quot;</span>, $realtime);</span><br><span class="line">          $finish;</span><br><span class="line">        end</span><br><span class="line">      @(this.rtr_io.cb);</span><br><span class="line">    end</span><br><span class="line">    this.pkt2cmp_payload.push_back(datum);</span><br><span class="line">  end</span><br><span class="line">endtask</span><br><span class="line">`endif</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Receiver-sv"><a href="#Receiver-sv" class="headerlink" title="Receiver.sv"></a>Receiver.sv</h2><p>每一次发送结束，将发送的信息送到out_box，然后准备使用scoreboard进行比较。所有的receiver都将接收到的数据放入一个mailbox中。这里放入的顺序是依次放入的。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">`ifndef INC_RECEIVER_SV</span><br><span class="line">`define INC_RECEIVER_SV</span><br><span class="line">`include <span class="string">&quot;ReceiverBase.sv&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> <span class="title">extends</span> <span class="title">ReceiverBase</span>;</span></span><br><span class="line">  pkt_mbox out_box;<span class="comment">// Scoreboard mailbox</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> function <span class="title function_">new</span><span class="params">(<span class="built_in">string</span> name = <span class="string">&quot;Receiver&quot;</span>, <span class="type">int</span> port_id, pkt_mbox out_box, virtual router_io.TB rtr_io)</span>;</span><br><span class="line">  <span class="keyword">extern</span> virtual task <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">endclass: Receiver</span><br><span class="line"></span><br><span class="line">function <span class="title function_">Receiver::new</span><span class="params">(<span class="built_in">string</span> name, <span class="type">int</span> port_id, pkt_mbox out_box, virtual router_io.TB rtr_io)</span>;</span><br><span class="line">  super.new(name, rtr_io);</span><br><span class="line">  <span class="keyword">if</span> (TRACE_ON) $display(<span class="string">&quot;[TRACE]%t %s:%m&quot;</span>, $realtime, this.name);</span><br><span class="line">  this.da = port_id;</span><br><span class="line">  this.out_box = out_box;</span><br><span class="line"></span><br><span class="line">endfunction: new</span><br><span class="line"></span><br><span class="line">task Receiver::start();</span><br><span class="line">  <span class="keyword">if</span> (TRACE_ON) $display(<span class="string">&quot;[TRACE]%t %s:%m&quot;</span>, $realtime, this.name);</span><br><span class="line">  fork</span><br><span class="line">forever begin</span><br><span class="line">  this.recv();</span><br><span class="line">  begin</span><br><span class="line">  Packet pkt = new pkt2cmp;<span class="comment">//使用new进行对象的复制</span></span><br><span class="line">this.out_box.put(pkt);</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line">  join_none</span><br><span class="line"></span><br><span class="line">endtask: start</span><br><span class="line">`endif</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Scoreboard-sv"><a href="#Scoreboard-sv" class="headerlink" title="Scoreboard.sv"></a>Scoreboard.sv</h2><p>只有一个checker，怎么能使得可以监测对比所有的数据呢？这里是一但receiver_mbox有数据，就将数据放到pkt2cmp里，准备比较。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">`ifndef INC_SCOREBOARD_SV</span><br><span class="line">`define INC_SCOREBOARD_SV</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scoreboard</span>;</span></span><br><span class="line">  <span class="built_in">string</span>  name;<span class="comment">// unique identifier</span></span><br><span class="line">  event   DONE;<span class="comment">// flag to indicate goal reached</span></span><br><span class="line">  Packet  refPkt[$];<span class="comment">// reference Packet array</span></span><br><span class="line">  Packet  pkt2send;<span class="comment">// Packet object from Drivers</span></span><br><span class="line">  Packet  pkt2cmp;<span class="comment">// Packet object from Receivers</span></span><br><span class="line">  pkt_mbox driver_mbox;<span class="comment">// mailbox for Packet objects from Drivers</span></span><br><span class="line">  pkt_mbox receiver_mbox;<span class="comment">// mailbox for Packet objects from Receivers</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> function <span class="title function_">new</span><span class="params">(<span class="built_in">string</span> name = <span class="string">&quot;Scoreboard&quot;</span>, pkt_mbox driver_mbox = null, receiver_mbox = null)</span>;</span><br><span class="line">  <span class="keyword">extern</span> virtual task <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">extern</span> virtual task <span class="title function_">check</span><span class="params">()</span>;</span><br><span class="line">endclass: Scoreboard</span><br><span class="line"></span><br><span class="line">function <span class="title function_">Scoreboard::new</span><span class="params">(<span class="built_in">string</span> name, pkt_mbox driver_mbox, receiver_mbox)</span>;</span><br><span class="line">  <span class="keyword">if</span> (TRACE_ON) $display(<span class="string">&quot;[TRACE]%t %s:%m&quot;</span>, $realtime, name);</span><br><span class="line">  this.name = name;</span><br><span class="line">  <span class="keyword">if</span> (driver_mbox == null) driver_mbox = new();</span><br><span class="line">  this.driver_mbox = driver_mbox;</span><br><span class="line">  <span class="keyword">if</span> (receiver_mbox == null) receiver_mbox = new();</span><br><span class="line">  this.receiver_mbox = receiver_mbox;</span><br><span class="line">endfunction: new</span><br><span class="line"></span><br><span class="line">task Scoreboard::start();</span><br><span class="line">  <span class="keyword">if</span> (TRACE_ON) $display(<span class="string">&quot;[TRACE]%t %s:%m&quot;</span>, $realtime, this.name);</span><br><span class="line">  fork</span><br><span class="line">    forever begin</span><br><span class="line">      this.receiver_mbox.get(this.pkt2cmp);<span class="comment">//将recv收集到的数据拿出一个放入pkt2cmp里，准备比较</span></span><br><span class="line">      <span class="keyword">while</span> (this.driver_mbox.num()) begin <span class="comment">//num的值是大于0的整数，其在这里表示条件语句的‘1’，为真。所以就执行语句</span></span><br><span class="line">        Packet pkt;</span><br><span class="line">        this.driver_mbox.get(pkt);</span><br><span class="line">        this.refPkt.push_back(pkt);<span class="comment">//向队列中放packet数据</span></span><br><span class="line">      end</span><br><span class="line">      this.check();</span><br><span class="line">    end</span><br><span class="line">  join_none<span class="comment">//为了不在rest.sv中阻塞下面的进程，使用join_none不同于Generator的start函数</span></span><br><span class="line">endtask: start</span><br><span class="line"></span><br><span class="line">task <span class="title function_">Scoreboard::check</span><span class="params">()</span>;</span><br><span class="line">  <span class="type">int</span>    index[$];</span><br><span class="line">  <span class="built_in">string</span> message;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span>  pkts_checked = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (TRACE_ON) $display(<span class="string">&quot;[TRACE]%t %s:%m&quot;</span>, $realtime, this.name);</span><br><span class="line">  index = this.refPkt.find_first_index() with (item.da == this.pkt2cmp.da);<span class="comment">//返回一个队列，item是队列里的那些packet。有可能refPkt里有很多包，因此需要同时</span></span><br><span class="line">  <span class="keyword">if</span> (index.size() &amp;lt;= <span class="number">0</span>) begin</span><br><span class="line">    $display(<span class="string">&quot;\n%m\n[ERROR]%t %s not found in Reference Queue\n&quot;</span>, $realtime, pkt2cmp.name);</span><br><span class="line">    this.pkt2cmp.display(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">    $finish;</span><br><span class="line">  end</span><br><span class="line">  this.pkt2send = refPkt[index[<span class="number">0</span>]]; <span class="comment">//将队列中的元素（Packet）取出，放到pkt2send </span></span><br><span class="line">  this.refPkt.delete(index[<span class="number">0</span>]);<span class="comment">//将Packet从队列中删除</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!this.pkt2send.compare(this.pkt2cmp, message)) begin</span><br><span class="line">    $display(<span class="string">&quot;\n%m\n[ERROR]%t Packet #%0d %s\n&quot;</span>, $realtime, pkts_checked, message);</span><br><span class="line">    this.pkt2send.display(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">    this.pkt2cmp.display(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">    $finish;</span><br><span class="line">  end</span><br><span class="line">  $display(<span class="string">&quot;[NOTE]%t Packet #%0d %s!!!!!!&quot;</span>, $realtime, pkts_checked++, message);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (pkts_checked &gt;= run_for_n_packets)</span><br><span class="line">    -&gt;this.DONE;</span><br><span class="line">endtask: check</span><br><span class="line">`endif</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文延续前一篇&lt;a href=&quot;https://blog.csdn.net/qq_41467882/article/details/122334222&quot;&gt;sv_labs学习笔记——sv_lab5_上(System Ver</summary>
      
    
    
    
    <category term="数字IC设计" scheme="http://example.com/categories/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="System Verilog labs学习笔记" scheme="http://example.com/categories/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1/System-Verilog-labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="sv_labs" scheme="http://example.com/tags/sv-labs/"/>
    
  </entry>
  
  <entry>
    <title>sv_labs学习笔记——sv_lab5_上(System Verilog）</title>
    <link href="http://example.com/2022/01/07/sv_labs/sv_labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94sv_lab5_%E4%B8%8A(System%20Verilog)/"/>
    <id>http://example.com/2022/01/07/sv_labs/sv_labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94sv_lab5_%E4%B8%8A(System%20Verilog)/</id>
    <published>2022-01-07T06:15:16.000Z</published>
    <updated>2022-05-02T14:20:06.759Z</updated>
    
    <content type="html"><![CDATA[<blockquote></blockquote><p>本节将介绍lab5的第一部分，主要总结一般设计学习与思考的方式与需要着重学习的点，同时以lab5作为参考，分析数据流流向，验证组件的通信与抽象化，实现的整体思路。</p><h1 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h1><p>首先明确实验目标。我们在lab4中根据实验指导，已经实现了指定端口的数据发送与检测。在该节lab中，我们将实现16路通道同时发送数据，同时实现对16组输出chanel的监测。将验证组件以class的形式进行进一步的封装。进一步完善我们的验证结构。</p><h1 id="思路梳理"><a href="#思路梳理" class="headerlink" title="思路梳理"></a>思路梳理</h1><p>我们明确了设计的目标，可以明显感觉lab5相比较于前面的更为抽象。我们根据最基本的验证组件框架，结合rest.sv代码，来梳理数据流向，程序运行大致的顺序。更细节的部分会放在设计的模块分析中进行解释梳理。 需要理解基本的两个概念，mailbox、semaphore。简单来说，mailbox用于线程间的数据交互。semaphore实现同一个资源的访问控制。详细参考笔者的<a href="https://blog.csdn.net/qq_41467882/article/details/122351441">System Verilog 线程间的通信</a> 首先是数据的产生，由Generator产生数据，数据产生的形式是Package的形式，放入out_box送入Driver，Driver将根据sa，由对应的drvr发送数据，同时打包数据送到scoreboard的driver_mbox，将由scoreboard进行数据比对，然后rcvr接收送到scoreboard的receiver_mbox，进行数据的比对。具体比对的方式将在后续代码中进行说明。 这里需要注意思考的点有</p><p>该博文将分析数据的产生，发送，以及整体的验证结构。下一篇分析数据的监测，数据的比对。</p><h1 id="sim-do文件"><a href="#sim-do文件" class="headerlink" title="sim.do文件"></a>sim.do文件</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> rtl ../../rtl/router.v </span><br><span class="line"><span class="built_in">set</span> svtb &#123;./router_test_top.sv ./router_io.sv ./test.sv&#125;</span><br><span class="line">vlib work</span><br><span class="line">vmap work work</span><br><span class="line">vlog $rtl</span><br><span class="line">vlog -sv ./router_test_top.sv ./router_io.sv ./test.sv</span><br><span class="line">vsim -t ns -novopt +notimingchecks -l router_test_top.<span class="built_in">log</span> work.router_test_top</span><br><span class="line">run -all</span><br></pre></td></tr></table></figure><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><p>首先看测试顶层，顶层将接口，测试程序进行实例化。这些都是与前面一样的，这里不进行解释。这里重要的是对测试程序进行分析。分析会为了确保代码的完整度，将代码全部展示。</p><h2 id="router-test-top-sv"><a href="#router-test-top-sv" class="headerlink" title="router_test_top.sv"></a>router_test_top.sv</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">`timescale <span class="number">1</span>ns/<span class="number">100</span>ps</span><br><span class="line">module router_test_top;</span><br><span class="line">  parameter simulation_cycle = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  bit SystemClock;<span class="comment">//bit 是二值逻辑。只有0、1，初始值默认是0</span></span><br><span class="line">  router_io <span class="title function_">top_io</span><span class="params">(SystemClock)</span>;</span><br><span class="line">  test <span class="title function_">t</span><span class="params">(top_io)</span>;</span><br><span class="line">  router <span class="title function_">dut</span><span class="params">(</span></span><br><span class="line"><span class="params">    .reset_n(top_io.reset_n),</span></span><br><span class="line"><span class="params">    .clock(top_io.clock),</span></span><br><span class="line"><span class="params">    .din(top_io.din),</span></span><br><span class="line"><span class="params">    .frame_n(top_io.frame_n),</span></span><br><span class="line"><span class="params">    .valid_n(top_io.valid_n),</span></span><br><span class="line"><span class="params">    .dout(top_io.dout),</span></span><br><span class="line"><span class="params">    .valido_n(top_io.valido_n),</span></span><br><span class="line"><span class="params">    .busy_n(top_io.busy_n),</span></span><br><span class="line"><span class="params">    .frameo_n(top_io.frameo_n)</span></span><br><span class="line"><span class="params">  )</span>;</span><br><span class="line"></span><br><span class="line">  initial begin</span><br><span class="line">    $timeformat(<span class="number">-9</span>, <span class="number">1</span>, <span class="string">&quot;ns&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    SystemClock = <span class="number">0</span>;</span><br><span class="line">    forever begin</span><br><span class="line">      #(simulation_cycle/<span class="number">2</span>)</span><br><span class="line">        SystemClock = ~SystemClock;</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h2 id="router-test-h"><a href="#router-test-h" class="headerlink" title="router_test.h"></a>router_test.h</h2><p>mailbox是一种通信机制，它使得数据可以在进程间传递和通信，数据被一个进程发送到另一个mailbox中，而另外一个进程可以从中可以获得。 mailbox #(type &#x3D; dynamic_type) 其中dynamic_type代表一个特殊的类型，它能够执行运行时的类型检查（缺省情况）。详细参考笔者的<a href="https://blog.csdn.net/qq_41467882/article/details/122351441">System Verilog 线程间的通信</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef class Packet;</span><br><span class="line">typedef mailbox #(Packet) pkt_mbox;</span><br></pre></td></tr></table></figure><h2 id="router-io-sv"><a href="#router-io-sv" class="headerlink" title="router_io.sv"></a>router_io.sv</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">`timescale <span class="number">1</span>ns/<span class="number">100</span>ps</span><br><span class="line">interface <span class="title function_">router_io</span><span class="params">(input bit clock)</span>;</span><br><span class="line">  logicreset_n;</span><br><span class="line">  logic [<span class="number">15</span>:<span class="number">0</span>]din;</span><br><span class="line">  logic [<span class="number">15</span>:<span class="number">0</span>]frame_n;</span><br><span class="line">  logic [<span class="number">15</span>:<span class="number">0</span>]valid_n;</span><br><span class="line">  logic [<span class="number">15</span>:<span class="number">0</span>]dout;</span><br><span class="line">  logic [<span class="number">15</span>:<span class="number">0</span>]valido_n;</span><br><span class="line">  logic [<span class="number">15</span>:<span class="number">0</span>]busy_n;</span><br><span class="line">  logic [<span class="number">15</span>:<span class="number">0</span>]frameo_n;</span><br><span class="line"></span><br><span class="line">  clocking cb @(posedge clock);</span><br><span class="line">    <span class="comment">//default input #1 output #1;</span></span><br><span class="line">    output reset_n;</span><br><span class="line">    output din;</span><br><span class="line">    output frame_n;</span><br><span class="line">    output valid_n;</span><br><span class="line">    input dout;</span><br><span class="line">    input valido_n;</span><br><span class="line">    input busy_n;</span><br><span class="line">    input frameo_n;</span><br><span class="line">  endclocking</span><br><span class="line"></span><br><span class="line">  modport <span class="title function_">TB</span><span class="params">(clocking cb, output reset_n)</span>;</span><br><span class="line">endinterface</span><br></pre></td></tr></table></figure><h2 id="test-sv"><a href="#test-sv" class="headerlink" title="test.sv"></a>test.sv</h2><p>测试程序semaphore，Driver，Receiver实例化16份，将Generator，Scoreboard实例化一份 。这里是将gen生成的所有对应的数据(out_box)送到每一个实例化的drvr[]中mailbox中，每一个drvr[]复制一份后放到drvr自身的mailbox中。drvr完成发送，将发送的数据放入driver_mbox，就完成了发送</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">`timescale <span class="number">1</span>ns/<span class="number">100</span>ps</span><br><span class="line">program automatic <span class="title function_">test</span><span class="params">(router_io.TB rtr_io)</span>;</span><br><span class="line">  `include <span class="string">&quot;Packet.sv&quot;</span></span><br><span class="line">  <span class="type">int</span> run_for_n_packets;      <span class="comment">// number of packets to test</span></span><br><span class="line">  <span class="type">int</span> TRACE_ON = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  `include <span class="string">&quot;router_test.h&quot;</span></span><br><span class="line">  `include <span class="string">&quot;Driver.sv&quot;</span></span><br><span class="line">  `include <span class="string">&quot;Receiver.sv&quot;</span></span><br><span class="line">  `include <span class="string">&quot;Generator.sv&quot;</span></span><br><span class="line">  `include <span class="string">&quot;Scoreboard.sv&quot;</span></span><br><span class="line"></span><br><span class="line">  semaphore sem[];                    <span class="comment">//声明动态数组</span></span><br><span class="line">  Driver drvr[];                         <span class="comment">// driver</span></span><br><span class="line">  Receiver rcvr[];                     <span class="comment">// receiver</span></span><br><span class="line">  Generator gen;                        <span class="comment">// generator</span></span><br><span class="line">  Scoreboard sb;                         <span class="comment">// scoreboard</span></span><br><span class="line"></span><br><span class="line">  initial begin  </span><br><span class="line">    run_for_n_packets = <span class="number">200</span>;</span><br><span class="line">sem = new[<span class="number">16</span>];  <span class="comment">//分配16个元素（16个句柄）</span></span><br><span class="line">drvr = new[<span class="number">16</span>];</span><br><span class="line">rcvr = new[<span class="number">16</span>];</span><br><span class="line">gen = new(<span class="string">&quot;gen&quot;</span>);</span><br><span class="line">sb = new(<span class="string">&quot;sb&quot;</span>);</span><br><span class="line"></span><br><span class="line">foreach (sem[i])</span><br><span class="line">  sem[i] = new(<span class="number">1</span>);<span class="comment">//为每一个semaphore分配一个钥匙</span></span><br><span class="line">foreach (drvr[i])</span><br><span class="line">  drvr[i] = new($sformatf(<span class="string">&quot;drvr[%0d]&quot;</span>,i), i, sem, gen.out_box[i], sb.driver_mbox, rtr_io);</span><br><span class="line">foreach (rcvr[i])</span><br><span class="line">  rcvr[i] = new($sformatf(<span class="string">&quot;rcvr[%0d]&quot;</span>,i), i, sb.receiver_mbox, rtr_io);</span><br><span class="line"><span class="comment">//以上过程均没有消耗时间，因此是在仿真0时刻就已经完成了。完成组件之间的通信与</span></span><br><span class="line">reset();</span><br><span class="line">gen.start();</span><br><span class="line">sb.start();</span><br><span class="line">foreach (drvr[i]) </span><br><span class="line">drvr[i].start();</span><br><span class="line">foreach (rcvr[i]) </span><br><span class="line">rcvr[i].start();<span class="comment">//start函数都是不耗时间的，因此在执行上也是在复位结束后在同一个时刻执行的。可以自行查看打印信息</span></span><br><span class="line">wait(sb.DONE.triggered);<span class="comment">//等待scoreboard结束事件被触发</span></span><br><span class="line">  end</span><br><span class="line">  </span><br><span class="line">  task <span class="title function_">reset</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">if</span> (TRACE_ON) $display(<span class="string">&quot;[TRACE]%t :%m&quot;</span>, $realtime);</span><br><span class="line">    rtr_io.reset_n = <span class="number">1&#x27;b</span>0;</span><br><span class="line">    rtr_io.cb.frame_n &amp;lt;= <span class="string">&#x27;1;</span></span><br><span class="line"><span class="string">    rtr_io.cb.valid_n &amp;lt;= &#x27;</span><span class="number">1</span>;</span><br><span class="line">    #<span class="number">2</span> rtr_io.cb.reset_n &amp;lt;= <span class="number">1&#x27;b</span>1;</span><br><span class="line">    repeat(<span class="number">15</span>) @(rtr_io.cb);</span><br><span class="line">  endtask: reset</span><br><span class="line"></span><br><span class="line">endprogram: test</span><br></pre></td></tr></table></figure><h2 id="Generator-sv"><a href="#Generator-sv" class="headerlink" title="Generator.sv"></a>Generator.sv</h2><p>out_box[]将传入对应drvr，由其进行发送，这也是数据产生的逻辑。一共有16组out_box。每一组分别送到对应的drvr发送出去。每一组sa相同的放入同一个out_box。</p><h3 id="m"><a href="#m" class="headerlink" title="%m"></a>%m</h3><p><code>%m</code> 将打印目录结构</p><h3 id="new-操作符复制"><a href="#new-操作符复制" class="headerlink" title="new 操作符复制"></a>new 操作符复制</h3><p><code>Packet pkt = new this.pkt2send;//将pkt2send复制一份到pkt</code> 该句涉及到了 通过new来实现浅拷贝。参看绿皮书第五章5.15<br/> 使用new操作符复制一个对象使用new复制一个对象简单而且可靠，它创建了一个新的对象，并且复制了现有对象的所有变量。这是一种简易复制（shallow copy），类似于原对象的一个影印本，原对象的值被盲目地抄写到目的对象中。如果类中包含一个指向另一个类的句柄，那么，只有最高一级的对象被new操作符复制，下层的对象都不会被复制。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">`ifndef INC_GENERATOR_SV</span><br><span class="line">`define INC_GENERATOR_SV</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span>;</span></span><br><span class="line">  <span class="built_in">string</span>  name;<span class="comment">// unique identifier</span></span><br><span class="line">  Packet  pkt2send;<span class="comment">// stimulus Packet object</span></span><br><span class="line">  pkt_mbox out_box[];<span class="comment">// mailbox to Drivers</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> function <span class="title function_">new</span><span class="params">(<span class="built_in">string</span> name = <span class="string">&quot;Generator&quot;</span>)</span>;</span><br><span class="line">  <span class="keyword">extern</span> virtual task <span class="title function_">gen</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">extern</span> virtual task <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">endclass: Generator</span><br><span class="line"></span><br><span class="line">function <span class="title function_">Generator::new</span><span class="params">(<span class="built_in">string</span> name)</span>;</span><br><span class="line">  <span class="keyword">if</span> (TRACE_ON) $display(<span class="string">&quot;[TRACE]%t %s:%m&quot;</span>, $realtime, name);</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.pkt2send = new();</span><br><span class="line">  this.out_box = new[<span class="number">16</span>];<span class="comment">//分配16个元素（16个句柄）</span></span><br><span class="line">  foreach(this.out_box[i])</span><br><span class="line">    this.out_box[i] = new();<span class="comment">//将每一个mailbox new</span></span><br><span class="line">endfunction: new</span><br><span class="line"></span><br><span class="line">task Generator::gen();</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> pkts_generated = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (TRACE_ON) $display(<span class="string">&quot;[TRACE]%t %s:%m&quot;</span>, $realtime, this.name);</span><br><span class="line">  this.pkt2send.name = $psprintf(<span class="string">&quot;Packet[%0d]&quot;</span>, pkts_generated++);</span><br><span class="line">  <span class="keyword">if</span> (!this.pkt2send.randomize()) begin</span><br><span class="line">    $display(<span class="string">&quot;\n%m\n[ERROR]%t Randomization Failed!\n&quot;</span>, $realtime);</span><br><span class="line">    $finish;</span><br><span class="line">  end</span><br><span class="line">endtask: gen</span><br><span class="line"></span><br><span class="line">task <span class="title function_">Generator::start</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">if</span> (TRACE_ON) $display(<span class="string">&quot;[TRACE]%t %s:%m&quot;</span>, $realtime, this.name);</span><br><span class="line">  fork</span><br><span class="line">    <span class="title function_">for</span> <span class="params">(<span class="type">int</span> i=<span class="number">0</span>; i&amp;lt;run_for_n_packets || run_for_n_packets &amp;lt;= <span class="number">0</span>; i++)</span> begin</span><br><span class="line">      this.<span class="title function_">gen</span><span class="params">()</span>;</span><br><span class="line">      begin</span><br><span class="line">        Packet pkt = new this.pkt2send;<span class="comment">//将pkt2send复制一份到pkt</span></span><br><span class="line">        <span class="comment">//this.out_box[pkt.sa].put(this.pkt2send);</span></span><br><span class="line">        this.out_box[pkt.sa].put(pkt);<span class="comment">//根据数据本身的sa送到对应的out_box中</span></span><br><span class="line">      end</span><br><span class="line">    end</span><br><span class="line">  join_none<span class="comment">//为了不在rest.sv中阻塞下面的进程，使用join_none。但是这里修改为join也是可以的，因为这里没有延时语句</span></span><br><span class="line">endtask: start</span><br><span class="line">`endif</span><br></pre></td></tr></table></figure><h2 id="DriverBase-sv"><a href="#DriverBase-sv" class="headerlink" title="DriverBase.sv"></a>DriverBase.sv</h2><p>基本的基类，扩展类参考<a href="https://blog.csdn.net/buzhiquxiang/article/details/104291313">这里</a>。 DriverBase的作用就是发送pkt2send中的数据到对应的da端口，同前面的实现是一样的。将数据送到接口。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`ifndef INC_DRIVERBASE_SV</span><br><span class="line">`define INC_DRIVERBASE_SV</span><br><span class="line">class DriverBase;</span><br><span class="line">  virtual router_io.TB rtr_io;// interface signal</span><br><span class="line">  string    name;// unique identifier</span><br><span class="line">  bit[3:0]  sa, da;// source and destination addresses</span><br><span class="line">  logic[7:0]  payload[$];// Packet payload</span><br><span class="line">  Packet    pkt2send;// stimulus Packet object</span><br><span class="line"></span><br><span class="line">  extern function new(string name = &quot;DriverBase&quot;, virtual router_io.TB rtr_io);</span><br><span class="line">  extern virtual task send();</span><br><span class="line">  extern virtual task send_addrs();</span><br><span class="line">  extern virtual task send_pad();</span><br><span class="line">  extern virtual task send_payload();</span><br><span class="line">endclass</span><br><span class="line"></span><br><span class="line">function DriverBase::new(string name, virtual router_io.TB rtr_io);</span><br><span class="line">  if (TRACE_ON) $display(&quot;[TRACE]%t %s:%m&quot;, $realtime, name);</span><br><span class="line">  this.name   = name;</span><br><span class="line">  this.rtr_io = rtr_io;</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">task DriverBase::send();</span><br><span class="line">  if (TRACE_ON) $display(&quot;[TRACE]%t %s:%m&quot;, $realtime, this.name);</span><br><span class="line">  this.send_addrs();</span><br><span class="line">  this.send_pad();</span><br><span class="line">  this.send_payload();</span><br><span class="line">endtask</span><br><span class="line"></span><br><span class="line">task DriverBase::send_addrs();</span><br><span class="line">  if (TRACE_ON) $display(&quot;[TRACE]%t %s:%m&quot;, $realtime, this.name);</span><br><span class="line">  this.rtr_io.cb.frame_n[this.sa] &amp;lt;= 1&#x27;b0;</span><br><span class="line">  for(int i=0; i&amp;lt;4; i++) begin</span><br><span class="line">    this.rtr_io.cb.din[this.sa] &amp;lt;= this.da[i];</span><br><span class="line">    @(this.rtr_io.cb);</span><br><span class="line">  end</span><br><span class="line">endtask</span><br><span class="line"></span><br><span class="line">task DriverBase::send_pad();</span><br><span class="line">  if (TRACE_ON) $display(&quot;[TRACE]%t %s:%m&quot;, $realtime, this.name);</span><br><span class="line">  this.rtr_io.cb.din[this.sa] &amp;lt;= 1&#x27;b1;</span><br><span class="line">  this.rtr_io.cb.valid_n[this.sa] &amp;lt;= 1&#x27;b1;</span><br><span class="line">  repeat(5) @(this.rtr_io.cb);</span><br><span class="line">endtask</span><br><span class="line"></span><br><span class="line">task DriverBase::send_payload();</span><br><span class="line">  if (TRACE_ON) $display(&quot;[TRACE]%t %s:%m&quot;, $realtime, this.name);</span><br><span class="line">  foreach(this.payload[index]) begin</span><br><span class="line">    for(int i=0; i&amp;lt;8; i++) begin</span><br><span class="line">      this.rtr_io.cb.din[this.sa] &amp;lt;= this.payload[index][i];</span><br><span class="line">      this.rtr_io.cb.valid_n[this.sa] &amp;lt;= 1&#x27;b0;</span><br><span class="line">      this.rtr_io.cb.frame_n[this.sa] &amp;lt;= ((index == (this.payload.size() - 1)) &amp;amp;&amp;amp; (i == 7));</span><br><span class="line">      @(this.rtr_io.cb);</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">  this.rtr_io.cb.valid_n[this.sa] &amp;lt;= 1&#x27;b1;</span><br><span class="line">endtask</span><br><span class="line">`endif</span><br></pre></td></tr></table></figure><h2 id="Driver-sv"><a href="#Driver-sv" class="headerlink" title="Driver.sv"></a>Driver.sv</h2><p>将顶层产生的数据复制到实例化每一个drvr内部。然后sem都传进来。每一个实例化的Driver都可以发送数据并且有一个自己的ID。假设ID为3，则只能发送sa&#x3D;3的数据。 <code>this.in_box.get(this.pkt2send);</code>这里的将传入的诗句取出来一份放到pkt2send中。准备接下来判断sa发送口是不是当前的端口。 <code>if (this.pkt2send.sa != this.sa) continue;</code> 需要注意这里的continue。当比较数据的sa与当前端口不一致的时候，continue，就是退出当前循环，开始下一次循环。相当于这个数据</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">`ifndef INC_DRIVER_DV</span><br><span class="line">`define INC_DRIVER_DV</span><br><span class="line">`include <span class="string">&quot;DriverBase.sv&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="title">extends</span> <span class="title">DriverBase</span>;</span></span><br><span class="line">  pkt_mbox in_box;<span class="comment">// Generator mailbox</span></span><br><span class="line">  pkt_mbox out_box;<span class="comment">// Scoreboard mailbox</span></span><br><span class="line">  semaphore sem[];<span class="comment">// output port arbitration</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">extern</span> function <span class="title function_">new</span><span class="params">(<span class="built_in">string</span> name = <span class="string">&quot;Driver&quot;</span>, <span class="type">int</span> port_id, semaphore sem[], pkt_mbox in_box, out_box, virtual router_io.TB rtr_io)</span>;</span><br><span class="line">  <span class="keyword">extern</span> virtual task <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">endclass</span><br><span class="line"></span><br><span class="line">function <span class="title function_">Driver::new</span><span class="params">(<span class="built_in">string</span> name, <span class="type">int</span> port_id, semaphore sem[], pkt_mbox in_box, out_box, virtual router_io.TB rtr_io)</span>;</span><br><span class="line">  super.new(name, rtr_io);</span><br><span class="line">  <span class="keyword">if</span> (TRACE_ON) $display(<span class="string">&quot;[TRACE]%t %s:%m&quot;</span>, $realtime, this.name);</span><br><span class="line">  this.sa = port_id;<span class="comment">//一共有16个ID，这些个ID对应着16个SA，也就是说，一个SA，有一个发送激励。SA对应的DRIVER标号是相同的。sa是1，则使用对应的实例化的发送数据</span></span><br><span class="line">  this.sem = sem;<span class="comment">//将测试顶层的sem传入内部</span></span><br><span class="line">  this.in_box = in_box;<span class="comment">//将顶层产生的数据复制到实例化每一个drvr内部</span></span><br><span class="line">  this.out_box = out_box;</span><br><span class="line">endfunction: new</span><br><span class="line"></span><br><span class="line">task Driver::start();</span><br><span class="line">  <span class="keyword">if</span> (TRACE_ON) $display(<span class="string">&quot;[TRACE]%t %s:%m&quot;</span>, $realtime, this.name);</span><br><span class="line">  fork</span><br><span class="line">    forever begin</span><br><span class="line">  this.in_box.get(this.pkt2send);<span class="comment">//从已经复制过的数据中获取packet内容</span></span><br><span class="line">  <span class="keyword">if</span> (this.pkt2send.sa != this.sa) <span class="keyword">continue</span>;<span class="comment">//从in_box中获取相关的发送信息。包括从哪里来，到那里去，包含多少个相关的该信息。要是Driver的ID与之不同，则放过去进行下一次判断，反之呢，就退出接收下一个信息。</span></span><br><span class="line">  <span class="comment">//其实这里也并不需要判断，因为放进来的信箱的里数据sa本身与当前发送的ID就是对应的。见Generator</span></span><br><span class="line">  this.da = this.pkt2send.da;</span><br><span class="line">  this.payload = this.pkt2send.payload;</span><br><span class="line">  this.sem[this.da].get(<span class="number">1</span>);<span class="comment">//这里防止有多个SA发送同一个DA。进行保护。当多个sa向一个da发数据的时候会进行阻塞，就形成了保护。</span></span><br><span class="line">  this.send();</span><br><span class="line">  this.out_box.put(this.pkt2send);<span class="comment">//将发送的数据放入out_box中</span></span><br><span class="line">  this.sem[this.da].put(<span class="number">1</span>);</span><br><span class="line">end</span><br><span class="line">  join_none</span><br><span class="line">endtask: start</span><br><span class="line">`endif</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;本节将介绍lab5的第一部分，主要总结一般设计学习与思考的方式与需要着重学习的点，同时以lab5作为参考，分析数据流流向，验证组件的通信与抽象化，实现的整体思路。&lt;/p&gt;
&lt;h1 id=&quot;实验目标&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="数字IC设计" scheme="http://example.com/categories/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="System Verilog labs学习笔记" scheme="http://example.com/categories/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1/System-Verilog-labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="sv_labs" scheme="http://example.com/tags/sv-labs/"/>
    
  </entry>
  
  <entry>
    <title>sv_labs学习笔记——sv_lab4(System Verilog)</title>
    <link href="http://example.com/2021/12/04/sv_labs/sv_labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94sv_lab4(System%20Verilog)/"/>
    <id>http://example.com/2021/12/04/sv_labs/sv_labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94sv_lab4(System%20Verilog)/</id>
    <published>2021-12-04T10:04:40.000Z</published>
    <updated>2022-05-02T14:20:45.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lab4-OOP-encapsulation"><a href="#lab4-OOP-encapsulation" class="headerlink" title="lab4 OOP encapsulation"></a>lab4 OOP encapsulation</h1><h2 id="实验概述"><a href="#实验概述" class="headerlink" title="实验概述"></a>实验概述</h2><p>OOP encapsulation意为面向对象封装。Lab4做的事情就是将一些成组的信息封装成一个Packet类。然后调用类来实现lab3同样的功能。实现框图如下</p><img src="https://img-blog.csdnimg.cn/6f0c77a8261d44788f73e3f1eac441de.png" /><p>可以看到。该实验对gen(),发送以及收集的数据的方式进行处理。将其封装为packat形式。其余部分lab3保持一致。这里其实是一个简单的面对对象编程的体验。使用<code>include &quot;Packet.sv&quot;</code>将其包在program中。然后对其进行方法变量进行使用。</p><h2 id="任务代码解析"><a href="#任务代码解析" class="headerlink" title="任务代码解析"></a>任务代码解析</h2><p>先实现Packet.sv文件然后再对test程序进行修改</p><h3 id="Packat实现与理解"><a href="#Packat实现与理解" class="headerlink" title="Packat实现与理解"></a>Packat实现与理解</h3><p>同样，这里对于compare进行了简单的修改。同学可以对比原solution里的写法与这里写法的区别，主要是对<code>compare</code>进行了一点点的顺序上的调整。代码如下。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`ifndef INC_PACKET_SV</span><br><span class="line">`define INC_PACKET_SV</span><br><span class="line">class Packet;</span><br><span class="line">    rand bit[3:0] sa, da;</span><br><span class="line">    rand logic[7:0] payload[$];</span><br><span class="line">    string   name;</span><br><span class="line">    </span><br><span class="line">    constraint valid &#123;</span><br><span class="line">sa inside &#123; [0:15] &#125;;</span><br><span class="line">da inside &#123; [0:15] &#125;;</span><br><span class="line">payload.size() inside &#123; [2:8] &#125;;</span><br><span class="line">&#125;</span><br><span class="line">    extern function new(string name = &quot;Packet&quot;);//这里传入默认参数为Packet</span><br><span class="line">    extern function bit compare(Packet pkt2cmp, ref string message);// need a package</span><br><span class="line">    extern function void display(string prefix = &quot;NOTE&quot;);</span><br><span class="line">endclass: Packet</span><br><span class="line"></span><br><span class="line">function Packet::new(string name);</span><br><span class="line">    this.name = name;</span><br><span class="line">endfunction: new</span><br><span class="line"></span><br><span class="line">function bit Packet::compare(Packet pkt2cmp, ref string message);</span><br><span class="line">    if(payload.size() != pkt2cmp.payload.size()) begin//传进来包的payload.size与类变量的进行对比</span><br><span class="line">        message = &quot;Payload size Mismatch:\n&quot;;</span><br><span class="line">        message = &#123; message, $sformatf(&quot;payload.size() = %0d, pkt2cmp.payload.size() = %0d\n&quot;, payload.size(), pkt2cmp.payload.size()) &#125;;</span><br><span class="line">        return (0);</span><br><span class="line">    end</span><br><span class="line">    if(payload == pkt2cmp.payload) ;</span><br><span class="line">    else begin</span><br><span class="line">        message = &quot;Payload Content Mismatch:\n&quot;;</span><br><span class="line">        message = &#123; message, $sformatf(&quot;Packet Sent:   %p\nPkt Received:   %p&quot;, payload, pkt2cmp.payload) &#125;;</span><br><span class="line">        return (0);</span><br><span class="line">    end</span><br><span class="line">        message = &quot;Successfully Compared&quot;;</span><br><span class="line">        return(1);</span><br><span class="line">endfunction: compare</span><br><span class="line"></span><br><span class="line">function void Packet::display(string prefix);</span><br><span class="line">    $display(&quot;[%s]%t %s sa = %0d, da = %0d&quot;, prefix, $realtime, name, sa, da);</span><br><span class="line">    foreach(payload[i])</span><br><span class="line">        $display(&quot;[%s]%t %s payload[%0d] = %0d&quot;, prefix, $realtime, name, i, payload[i]);</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure><p>我们先看包中的具体成员，其包含的变量成员组成如下。</p><h4 id="语法点解析"><a href="#语法点解析" class="headerlink" title="语法点解析"></a>语法点解析</h4><h5 id="randomize"><a href="#randomize" class="headerlink" title="randomize()"></a>randomize()</h5><p>一个对象中的变量使用randomize()类方法进行随机化。每一个类都有一个内建的randomize()虚拟方法，它的声明原型如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">virtual function int randomize();</span><br></pre></td></tr></table></figure><p>randomize()方法是一个虚拟函数，它为对象中的所有活跃随机变量产生随机值，产生的随机值应该符合活跃的约束。<br/> 如果randomize()方法成功地设置了所有的随机变量和对象的有效值，那么它返回1；否则返回0。</p><h5 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h5><p>SV允许在一个块外声明例子。使用关键词extern。实例如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Transaction;</span><br><span class="line">extern function void display ();</span><br><span class="line">endclass</span><br><span class="line"></span><br><span class="line">function void Transaction::display ();</span><br><span class="line">$display (&quot;...&quot;);</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure><h5 id="96-ifndef-宏定义的使用"><a href="#96-ifndef-宏定义的使用" class="headerlink" title="&#96;ifndef 宏定义的使用"></a>&#96;ifndef 宏定义的使用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`ifndef/`define/`endif使用的目的是为了防止重复编译。举一个例子。&lt;br/&gt; a.sv 包含了两个文件b.sv，c.sv。同时b.sv，c.sv各自包含了d.sv。这个时候编译a.sv时，就会重复编译d.sv。加上`ifndef/`define/`endif就不会引入上述问题。</span><br></pre></td></tr></table></figure><h5 id="this-name-x3D-name"><a href="#this-name-x3D-name" class="headerlink" title="this.name &#x3D; name;"></a>this.name &#x3D; name;</h5><p>将传进来的参数赋值给一个类里的变量</p><p> 当你使用一个变量名的时候, Systemverilog将先在当前作用域内寻找,接着在上一级作用域内寻找,直到找到该变量为止。这也是 Verilog所采用的算法。但是如果你在类的很深的底层作用域,却想明确地引用类一级的对象呢?这种风格的代码在构造函数里最常见,因为这时候程序员使用相同的类变量名和参数名。关键词this可以实现该功能。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Scoping;</span><br><span class="line">string oname;</span><br><span class="line">function new ( string oname ) ;</span><br><span class="line">this.oname = oname // 类变量oname=局部变量oname</span><br><span class="line">endfunction</span><br><span class="line">endclass</span><br></pre></td></tr></table></figure><h5 id="sformatf"><a href="#sformatf" class="headerlink" title="$sformatf"></a>$sformatf</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$sformatf(&quot;payload.size() = %0d, pkt2cmp.payload.size() = %0d\n&quot;, payload.size(), pkt2cmp.payload.size())</span><br></pre></td></tr></table></figure><p>$sformatf返回值是一个字符串。会将传入的内容进行整理，返回一个字符串性质。</p><h5 id="随机约束"><a href="#随机约束" class="headerlink" title="随机约束"></a>随机约束</h5><p>随机和约束时两个概念，参考绿皮书第六章，随机化</p><table><thead><tr><th>随机</th><th>约束</th></tr></thead><tbody><tr><td>rand bit[3:0] sa, da;定义了一个随机变量，使用rand修符，表示每次随机化这个类时，都会赋予这个变量一个值。</td><td>使用约束对随机的值进行处理 关键词为 constraint</td></tr></tbody></table><h3 id="主程序的实现与理解"><a href="#主程序的实现与理解" class="headerlink" title="主程序的实现与理解"></a>主程序的实现与理解</h3><p>首先简单分析下。改测试部分主要是通过例化两个Packet。一个为pkt2send。用于存储发送的地址与数据。然后讲其送到DUT，然后讲接收到的数据存入pkt2cmp 。将其中的数据与发送的数据及其相关信息比对，其余逻辑见注释。<br/> 这里省略了与lab3内容一致的代码，主要修改的地方在gen(),recv()以及check。相关的注释放在代码中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">`include <span class="string">&quot;Packet.sv&quot;</span></span><br><span class="line">program automatic <span class="title function_">test</span><span class="params">(router_io.TB rtr_io)</span>;</span><br><span class="line">    <span class="type">int</span> run_for_n_packets;</span><br><span class="line">    bit[<span class="number">3</span>:<span class="number">0</span>] sa;</span><br><span class="line">    bit[<span class="number">3</span>:<span class="number">0</span>] da;</span><br><span class="line">    logic[<span class="number">7</span>:<span class="number">0</span>] payload[$];</span><br><span class="line">    logic[<span class="number">7</span>:<span class="number">0</span>] pkt2cmp_payload[$];      <span class="comment">// actual packet data array</span></span><br><span class="line"></span><br><span class="line">    Packet pkt2send = new();</span><br><span class="line"><span class="comment">//使用类似于类。new()函数为两个包开辟空间，该packet 用于发送，用在了gen()函数里。同时在check()函数中也用到了</span></span><br><span class="line">    Packet pkt2cmp  = new();</span><br><span class="line">initial begin</span><br><span class="line">    ...<span class="comment">//与lab3内容一致</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">task <span class="title function_">reset</span><span class="params">()</span>;</span><br><span class="line">    ...<span class="comment">//与lab3内容一致</span></span><br><span class="line">endtask: reset</span><br><span class="line"></span><br><span class="line">task <span class="title function_">gen</span><span class="params">()</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> pkts_generated = <span class="number">0</span>;<span class="comment">//静态变量</span></span><br><span class="line">pkt2send.name = $sformatf(<span class="string">&quot;Packet[%0d]&quot;</span>, pkts_generated++);</span><br><span class="line">    <span class="keyword">if</span>(!pkt2send.randomize()) begin <span class="comment">//调用函数，检查初始化状态是否成功。call function randomize. meanwhile check it&#x27;s work situation </span></span><br><span class="line">    $display(<span class="string">&quot;\n%m\n [ERROR] %t: Randomize Error!!&quot;</span>, $realtime);</span><br><span class="line">        $finish;</span><br><span class="line">end </span><br><span class="line">    sa = pkt2send.sa; <span class="comment">//将随机的结果传输给sa</span></span><br><span class="line">    da = pkt2send.da; </span><br><span class="line">    $display(<span class="string">&quot;this package from sa = %0d ,and da = %0d&quot;</span>,sa,da);</span><br><span class="line">    payload = pkt2send.payload;</span><br><span class="line">endtask: gen</span><br><span class="line"></span><br><span class="line">task <span class="title function_">send</span><span class="params">()</span>;</span><br><span class="line">...<span class="comment">//与lab3内容一致</span></span><br><span class="line">endtask: send</span><br><span class="line"></span><br><span class="line">task <span class="title function_">recv</span><span class="params">()</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> pkt_cnt = <span class="number">0</span>;</span><br><span class="line">    get_payload();</span><br><span class="line">    pkt2cmp.da = da;<span class="comment">//将收到的地址送到接收的包变量中</span></span><br><span class="line">    pkt2cmp.payload = pkt2cmp_payload;<span class="comment">//将收到的数据送到接收的包变量中</span></span><br><span class="line">    pkt2cmp.name = $sformatf(<span class="string">&quot;rcvdPkt[%0d]&quot;</span>, pkt_cnt++);</span><br><span class="line">endtask : recv </span><br><span class="line"></span><br><span class="line">task <span class="title function_">get_payload</span><span class="params">()</span>;</span><br><span class="line">...<span class="comment">//与lab3内容一致</span></span><br><span class="line">endtask: get_payload</span><br><span class="line"></span><br><span class="line">task <span class="title function_">check</span><span class="params">()</span>;</span><br><span class="line">    <span class="built_in">string</span> message;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> pkts_checked = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!pkt2send.compare(pkt2cmp, message)) begin <span class="comment">// need two package,need to use payload data compare with introduce package data. will print two package some information about address,data.</span></span><br><span class="line"><span class="comment">//将pkt2cmp传入pkt2send.compare()函数。将原类的变量与送进了的进行比较。判断是否比较成功。这里的string 的参数时用到了ref参数，可以在函数内改变message的值</span></span><br><span class="line">        $display(<span class="string">&quot;\n%m\n[ERROR]%t Packet #%0d %s\n&quot;</span>, $realtime, pkts_checked, message);</span><br><span class="line">        pkt2send.display();</span><br><span class="line">    pkt2cmp.display();</span><br><span class="line">        $finish;</span><br><span class="line">    end</span><br><span class="line">    $display(<span class="string">&quot;[NOTE]%t Packet #%0d %s&quot;</span>, $realtime, pkts_checked++, message);</span><br><span class="line">endtask: check</span><br><span class="line">endprogram: test</span><br></pre></td></tr></table></figure><h4 id="语法点解析-1"><a href="#语法点解析-1" class="headerlink" title="语法点解析"></a>语法点解析</h4><h5 id="96-include"><a href="#96-include" class="headerlink" title="&#96;include"></a>&#96;include</h5><p>所谓”文件包含”处理是一个源文件可以将另外一个源文件的全部内容包含进来，即将另外的文件包含到本文件之中。可以将一些常用的宏定义命令或任务(task)组成一个文件，然后用&#96;include命令将这些宏定义包含到自己所写的源文件中，相当于工业上的标准元件拿来使用。</p><h5 id="ref-的理解"><a href="#ref-的理解" class="headerlink" title="ref 的理解"></a>ref 的理解</h5><p>点击这里<a href="https://blog.csdn.net/qq_41467882/article/details/121684326">ref</a>。简单解释就是函数内改变message，message变量的值会改变。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/qq_41467882/article/details/121506899">面向对象的基本概念（opp编程——类的基础使用）</a></li><li><a href="https://blog.csdn.net/qq_41467882/article/details/121699357">SystemVerilog中package(包)的基本使用</a></li><li><a href="https://blog.csdn.net/qq_41467882/article/details/121704198">虚方法（get）</a></li><li><a href="https://blog.csdn.net/qq_41467882/article/details/121255322">函数与任务</a></li><li><a href="https://blog.csdn.net/qq_41467882/article/details/121684326">system verilog中的参数传递——ref，input，output</a></li><li><a href="https://www.wenjiangs.com/doc/6dcs7ojg">randomize()的基本介绍</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lab4-OOP-encapsulation&quot;&gt;&lt;a href=&quot;#lab4-OOP-encapsulation&quot; class=&quot;headerlink&quot; title=&quot;lab4 OOP encapsulation&quot;&gt;&lt;/a&gt;lab4 OOP encapsulati</summary>
      
    
    
    
    <category term="数字IC设计" scheme="http://example.com/categories/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="System Verilog labs学习笔记" scheme="http://example.com/categories/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1/System-Verilog-labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="sv_labs" scheme="http://example.com/tags/sv-labs/"/>
    
  </entry>
  
  <entry>
    <title>sv_labs学习笔记——sv_lab3(System Verilog)</title>
    <link href="http://example.com/2021/12/01/sv_labs/sv_labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94sv_lab3(System%20Verilog)/"/>
    <id>http://example.com/2021/12/01/sv_labs/sv_labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94sv_lab3(System%20Verilog)/</id>
    <published>2021-12-01T10:59:00.000Z</published>
    <updated>2022-05-02T14:15:07.258Z</updated>
    
    <content type="html"><![CDATA[<blockquote></blockquote><p>这里我们在前两个lab的基础上继续完善，搭建一个数据接受的功能。在lab2 中我们实现了相关发送信息的打印，选择发送接受的端口，完善发送时序，在这一小节中将实现对端口发送数据的回收，然后进行比较发送的数据与预期是否一致。</p><h2 id="lab3实验概述"><a href="#lab3实验概述" class="headerlink" title="lab3实验概述"></a>lab3实验概述</h2><p>该部分主要梳理本次lab需要完成的任务以及博文的基本内容。需要实现的任务如下：依旧在之前的基础上，对主程序补充。我们需要实现一个<code>get_payload()</code>，<code>recv()</code>这两个task，收集DUT的输出数据，然后实现一个task<code>check()</code>对发送数据与DUT接受到的数据进行比对。实现的总体框图如下所示</p> <img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/e4a1676f4afc44f3970fdf4adebf13bb.png"/><p>本博文将首先分析initial块里的任务的执行顺序，然后对与新创建的几个任务的实现进行解释。最后同样对于一些语法函数进行解释。组后给出添加相关打印信息的版本，方便理解。</p><p>回顾下输出的接口时序。</p><p> <img src="https://img-blog.csdnimg.cn/bc8c31d460eb4fc8ba9d4b5e69237967.png" alt="&lt;br/&gt; 默认`vaildo_n`以及`framo_n`高电平。拉低`frameo_n`。下一个`cycle`拉低`valido_n`。`valido_n`为低电平时对应输出dout有效，反之。只有`frameo_n`为低，则表示输出有效。输出的数据是否有效，则看`vaildo_n`的信号即可。为低有效。否则数据无效。"></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>该实验同样只是对于test.sv里的测试程序进行里修改。首先来分析对于initial块的修改。 我们看到新增加的内容为新定义了一个队列，用于存放接受到的数据。除此之外，将实现发送功能的任务send()与实现接受功能的任务rece()包在了fork join中。执行一次发送接受之后，进行检查两者数据是否一致。如下图。 <img alt="请添加图片描述" src="https://img-blog.csdnimg.cn/8066afe1e16f4626a490883c719954e1.png"/></p><p>简单理解fork…join就是其作用域下是一个程序的并行执行。关于fork…join的更多细节与使用案例<a href="https://blog.csdn.net/qq_41467882/article/details/121678760">点击这里</a>。</p><h3 id="任务实现方式解析"><a href="#任务实现方式解析" class="headerlink" title="任务实现方式解析"></a>任务实现方式解析</h3><p>该部分对使用的任务进行分析。</p><h4 id="接收命令-task-recv"><a href="#接收命令-task-recv" class="headerlink" title="接收命令 task recv();"></a>接收命令 task recv();</h4><p>recv()任务调用任务get_payload。其中对于fork…join点击这里。这是一个关于线程控制的简单使用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task recv();</span><br><span class="line">    get_payload();</span><br><span class="line">endtask : recv </span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="等待接收命令-（fork-join-块）"><a href="#等待接收命令-（fork-join-块）" class="headerlink" title="等待接收命令 （fork join 块）"></a>等待接收命令 （fork join 块）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task get_payload();</span><br><span class="line">    pkt2cmp_payload.delete();//清除之前缓存的数据</span><br><span class="line">    fork begin : wd_timer_fork</span><br><span class="line">            fork : frameo_wd_timer  </span><br><span class="line">                @(negedge rtr_io.cb.frameo_n[da]);  //这里是第一个线程(thread)</span><br><span class="line">begin  //begin...end这里是第二个线程start</span><br><span class="line">                    repeat(100) @(rtr_io.cb);</span><br><span class="line">                  $display(&quot;\n%m\n[ERROR]%t Frame signal timed out!\n&quot;, $realtime);</span><br><span class="line">                    $finish;</span><br><span class="line">                end //begin...end这里是第二个线程end</span><br><span class="line">            join_any : frameo_wd_timer</span><br><span class="line">            disable fork;//等待失败，或者是等到下降沿，推出fork join。执行下面的内容</span><br><span class="line">         end : wd_timer_fork</span><br><span class="line">    join  </span><br></pre></td></tr></table></figure><p>上边这一段程序主要防止在执行的过程中，由于输出段始终没有出现frameo_n的对应位的下降沿信号则等待100时钟周期，然后输出错误信息，结束仿真。若是先等待到frameo_n的下降沿，推出进程，开始允许后面的程序。</p><h5 id="接收数据并存储-（forever循环）"><a href="#接收数据并存储-（forever循环）" class="headerlink" title="接收数据并存储 （forever循环）"></a>接收数据并存储 （forever循环）</h5><p>注意，forever这里笔者添加了一些begin end块，相比原selotion里的代码逻辑相对更好理解。建议自己写代码时也同样进行添加，增强可读性。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    forever begin</span><br><span class="line">        logic[7:0] datum;</span><br><span class="line">        for(int i=0; i&amp;lt;8; i=i)  begin </span><br><span class="line">            if(!rtr_io.cb.valido_n[da]) begin   </span><br><span class="line">                datum[i++] = rtr_io.cb.dout[da];</span><br><span class="line">                if(rtr_io.cb.frameo_n[da]) begin  </span><br><span class="line">                    if(i==8) begin //判断i是否为8。可能拉高的时间不对，就有可能引起这个问题。</span><br><span class="line">                      pkt2cmp_payload.push_back(datum);//将数据写入队列中</span><br><span class="line">                      return;      //返回。跳出forever</span><br><span class="line">                  end</span><br><span class="line">                  else begin</span><br><span class="line">                      $display(&quot;\n%m\n[ERROR]%t Packet payload not byte aligned!\n&quot;, $realtime);</span><br><span class="line">                      $finish;</span><br><span class="line">                  end</span><br><span class="line">                end</span><br><span class="line">            end</span><br><span class="line">            @(rtr_io.cb);</span><br><span class="line">        end</span><br><span class="line">        pkt2cmp_payload.push_back(datum);</span><br><span class="line">    end</span><br><span class="line">endtask: get_payload</span><br></pre></td></tr></table></figure><p>重点理解begin end块的划分。将原代码逻辑进行梳理，然后重点理解对frameo_n的判断。</p><p><code>if(!rtr_io.cb.valido_n[da]) 建议直接写成if(rtr_io.cb.valido_n[da] == 1’b0) if(rtr_io.cb.frameo_n[da])建议写为if(rtr_io.cb.frameo_n[da] == 1&#39;b1)，这两者是等价的，后者可读性更好。</code></p><h4 id="比较任务-task-check"><a href="#比较任务-task-check" class="headerlink" title="比较任务 task check();"></a>比较任务 task check();</h4><p>得到接收到的数据之后进行比较，这里check调用了函数compare。函数compare返回一个返回值。要是返回值等于0。则比较失败，输出相关信息，反之比较成功，打印相关信息。不进行过多介绍。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task check();</span><br><span class="line">    string message;</span><br><span class="line">    static int pkts_checked = 0;</span><br><span class="line">    if (!compare(message)) begin</span><br><span class="line">      $display(&quot;\n%m\n[ERROR]%t Packet #%0d %s\n&quot;, $realtime, pkts_checked, message);</span><br><span class="line">      $finish;</span><br><span class="line">    end</span><br><span class="line">    $display(&quot;[NOTE]%t Packet #%0d %s&quot;, $realtime, pkts_checked++, message);</span><br><span class="line">endtask: check</span><br></pre></td></tr></table></figure><h5 id="比较函数-（compare）"><a href="#比较函数-（compare）" class="headerlink" title="比较函数 （compare）"></a>比较函数 （compare）</h5><p>比较函数的比较方式就是1）先比较长度（2）再比较内容。在任何一个方面比较失败，均返回0，表示比对不匹配。输出相关信息。笔者对原solution文件提供的进行了一点点的修改。很简单，这里不进行赘述。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function bit compare(ref string message);</span><br><span class="line">    if(payload.size() != pkt2cmp_payload.size()) begin</span><br><span class="line">        message = &quot;Payload size Mismatch:\n&quot;;</span><br><span class="line">        message = &#123; message, $sformatf(&quot;payload.size() = %0d, pkt2cmp_payload.size() = %0d\n&quot;, payload.size(), pkt2cmp_payload.size()) &#125;;</span><br><span class="line">        return (0);   </span><br><span class="line">    end</span><br><span class="line">    else if(payload == pkt2cmp_payload) begin </span><br><span class="line">        message = &quot;Successfully Compared&quot;;</span><br><span class="line">        return(1);</span><br><span class="line">    end </span><br><span class="line">    else begin</span><br><span class="line">        message = &quot;Payload Content Mismatch:\n&quot;;</span><br><span class="line">        message = &#123; message, $sformatf(&quot;Packet Sent:   %p\nPkt Received:   %p&quot;, payload, pkt2cmp_payload) &#125;;</span><br><span class="line">        return (0);</span><br><span class="line">    end</span><br><span class="line">endfunction: compare</span><br></pre></td></tr></table></figure><p>下面这段话就是返回一个字符串。字符串的内容就是将括号里的内容进行整理返回。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$sformatf(&quot;payload.size() = %0d, pkt2cmp_payload.size() = %0d\n&quot;, payload.size(), pkt2cmp_payload.size()) </span><br></pre></td></tr></table></figure><h2 id="添加打印信息版本"><a href="#添加打印信息版本" class="headerlink" title="添加打印信息版本"></a>添加打印信息版本</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>其中循环次数为3，随机化了发送接收的地址。除去新增加的模块，其他同前面的基本一致。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">program automatic test(router_io.TB rtr_io);</span><br><span class="line">    int run_for_n_packets;</span><br><span class="line">    bit[3:0] sa;</span><br><span class="line">    bit[3:0] da;</span><br><span class="line">    logic[7:0] payload[$];</span><br><span class="line">    logic[7:0] pkt2cmp_payload[$];      // actual packet data array</span><br><span class="line"></span><br><span class="line">    integer repeat_times = 1;</span><br><span class="line">initial begin</span><br><span class="line">    $vcdpluson;</span><br><span class="line">    reset();</span><br><span class="line">    run_for_n_packets = 3;</span><br><span class="line">    repeat(run_for_n_packets) begin</span><br><span class="line">        $display(&quot;repeat time is %0d&quot;,repeat_times);</span><br><span class="line">        repeat_times = repeat_times + 1;</span><br><span class="line">        gen();</span><br><span class="line">        $display(&quot;payload is &quot;,payload);</span><br><span class="line">        fork  </span><br><span class="line">            send();</span><br><span class="line">            recv();</span><br><span class="line">        join</span><br><span class="line">        check();</span><br><span class="line">    end</span><br><span class="line">    repeat(10) @(rtr_io.cb);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">task reset();</span><br><span class="line">    rtr_io.reset_n = 1&#x27;b0;</span><br><span class="line">    rtr_io.cb.frame_n &amp;lt;= &#x27;1;</span><br><span class="line">    rtr_io.cb.valid_n &amp;lt;= &#x27;1;</span><br><span class="line">    ##2 rtr_io.cb.reset_n &amp;lt;= 1&#x27;b1;</span><br><span class="line">    repeat(15) @(rtr_io.cb);</span><br><span class="line">endtask: reset</span><br><span class="line"></span><br><span class="line">task gen();</span><br><span class="line">    //sa = 3;</span><br><span class="line">    //da = 7;</span><br><span class="line">    sa = $urandom();</span><br><span class="line">    da = $urandom();</span><br><span class="line">    $display(&quot;this package from sa = %0d ,and da = %0d&quot;,sa,da);</span><br><span class="line">    payload.delete(); //clear previous data</span><br><span class="line">    repeat($urandom_range(9,2))</span><br><span class="line">    payload.push_back($urandom());</span><br><span class="line">endtask: gen</span><br><span class="line"></span><br><span class="line">task send();</span><br><span class="line">    send_addrs();</span><br><span class="line">    send_pad();</span><br><span class="line">    send_payload();</span><br><span class="line">endtask: send</span><br><span class="line"> </span><br><span class="line">task send_addrs();</span><br><span class="line">    rtr_io.cb.frame_n[sa] &amp;lt;= 1&#x27;b0; //start of packet</span><br><span class="line">    for(int i = 0; i&amp;lt;4; i++) begin</span><br><span class="line">        rtr_io.cb.din[sa] &amp;lt;= da[i]; //i&#x27;th bit of da</span><br><span class="line">        @(rtr_io.cb);</span><br><span class="line">    end</span><br><span class="line">endtask: send_addrs</span><br><span class="line"></span><br><span class="line">task send_pad();</span><br><span class="line">    rtr_io.cb.frame_n[sa] &amp;lt;= 1&#x27;b0;</span><br><span class="line">    rtr_io.cb.valid_n[sa] &amp;lt;= 1&#x27;b1;</span><br><span class="line">    rtr_io.cb.din[sa] &amp;lt;= 1&#x27;b1;</span><br><span class="line">    repeat(5) @(rtr_io.cb);</span><br><span class="line">endtask: send_pad</span><br><span class="line"></span><br><span class="line">task send_payload();</span><br><span class="line">    foreach(payload[index]) begin </span><br><span class="line">      //$display(&quot;index is %0d,payload[index] is %0h &quot;,index,payload[index]);</span><br><span class="line">      for(int i=0; i&amp;lt;8; i++) begin</span><br><span class="line">            rtr_io.cb.din[sa] &amp;lt;= payload[index][i];</span><br><span class="line">        rtr_io.cb.valid_n[sa] &amp;lt;= 1&#x27;b0; //driving a valid bit</span><br><span class="line">        rtr_io.cb.frame_n[sa] &amp;lt;= ((i == 7) &amp;amp;&amp;amp; (index == (payload.size() - 1)));</span><br><span class="line">    @(rtr_io.cb);</span><br><span class="line">      end</span><br><span class="line">    end</span><br><span class="line">    rtr_io.cb.valid_n[sa] &amp;lt;= 1&#x27;b1;</span><br><span class="line">endtask: send_payload</span><br><span class="line"></span><br><span class="line">task recv();</span><br><span class="line">    get_payload();</span><br><span class="line">endtask : recv </span><br><span class="line"></span><br><span class="line">task get_payload();</span><br><span class="line">    pkt2cmp_payload.delete();</span><br><span class="line">    fork begin : wd_timer_fork</span><br><span class="line">            fork : frameo_wd_timer  </span><br><span class="line">                @(negedge rtr_io.cb.frameo_n[da]); </span><br><span class="line">                begin </span><br><span class="line">                    repeat(100) @(rtr_io.cb);</span><br><span class="line">                  $display(&quot;\n%m\n[ERROR]%t Frame signal timed out!\n&quot;, $realtime);</span><br><span class="line">                    $finish;</span><br><span class="line">                end </span><br><span class="line">            join_any : frameo_wd_timer</span><br><span class="line">            disable fork;</span><br><span class="line">         end : wd_timer_fork</span><br><span class="line">    join</span><br><span class="line">    </span><br><span class="line">    forever begin</span><br><span class="line">        logic[7:0] datum;</span><br><span class="line">        for(int i=0; i&amp;lt;8; i=i)  begin </span><br><span class="line">            if(!rtr_io.cb.valido_n[da]) begin </span><br><span class="line">                datum[i++] = rtr_io.cb.dout[da];</span><br><span class="line">                //$display(&quot;i is %0d &quot;,i);</span><br><span class="line">                if(rtr_io.cb.frameo_n[da]) begin  </span><br><span class="line">                    if(i==8) begin //byte alligned</span><br><span class="line">                      pkt2cmp_payload.push_back(datum);</span><br><span class="line">                        $display(&quot;palce 1 push_back data is %0h&quot;,datum);</span><br><span class="line">                      return;      </span><br><span class="line">                  end</span><br><span class="line">                  else begin</span><br><span class="line">                      $display(&quot;\n%m\n[ERROR]%t Packet payload not byte aligned!\n&quot;, $realtime);</span><br><span class="line">                      $finish;</span><br><span class="line">                  end</span><br><span class="line">                end</span><br><span class="line">            end</span><br><span class="line">            @(rtr_io.cb);</span><br><span class="line">        end</span><br><span class="line">        $display(&quot;palce 2 push_back data is %0h&quot;,datum);</span><br><span class="line">        pkt2cmp_payload.push_back(datum);</span><br><span class="line">    end</span><br><span class="line">endtask: get_payload</span><br><span class="line"></span><br><span class="line">function bit compare(ref string message);</span><br><span class="line">    if(payload.size() != pkt2cmp_payload.size()) begin</span><br><span class="line">        message = &quot;Payload size Mismatch:\n&quot;;</span><br><span class="line">        message = &#123; message, $sformatf(&quot;payload.size() = %0d, pkt2cmp_payload.size() = %0d\n&quot;, payload.size(), pkt2cmp_payload.size()) &#125;;</span><br><span class="line">        return (0);   </span><br><span class="line">    end</span><br><span class="line">    if(payload == pkt2cmp_payload);</span><br><span class="line">        else begin</span><br><span class="line">            message = &quot;Payload Content Mismatch:\n&quot;;</span><br><span class="line">            message = &#123; message, $sformatf(&quot;Packet Sent:   %p\nPkt Received:   %p&quot;, payload, pkt2cmp_payload) &#125;;</span><br><span class="line">            return (0);</span><br><span class="line">        end</span><br><span class="line">    message = &quot;Successfully Compared&quot;;</span><br><span class="line">    return(1);</span><br><span class="line">endfunction: compare</span><br><span class="line"></span><br><span class="line">task check();</span><br><span class="line">    string message;</span><br><span class="line">    static int pkts_checked = 0;</span><br><span class="line">    if (!compare(message)) begin</span><br><span class="line">      $display(&quot;\n%m\n[ERROR]%t Packet #%0d %s\n&quot;, $realtime, pkts_checked, message);</span><br><span class="line">      $finish;</span><br><span class="line">    end</span><br><span class="line">    $display(&quot;[NOTE]%t Packet #%0d %s&quot;, $realtime, pkts_checked++, message);</span><br><span class="line">endtask: check</span><br><span class="line">endprogram: test</span><br></pre></td></tr></table></figure><h3 id="打印信息"><a href="#打印信息" class="headerlink" title="打印信息"></a>打印信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this package from sa = 6 ,and da = 12</span><br><span class="line">payload is &#x27;&#123;&#x27;he2, &#x27;hb, &#x27;hdf, &#x27;h40, &#x27;hf7, &#x27;ha6, &#x27;h1b&#125; </span><br><span class="line">palce 2 push_back data is e2</span><br><span class="line">palce 2 push_back data is b</span><br><span class="line">palce 2 push_back data is df</span><br><span class="line">palce 2 push_back data is 40</span><br><span class="line">palce 2 push_back data is f7</span><br><span class="line">palce 2 push_back data is a6</span><br><span class="line">palce 1 push_back data is 1b</span><br><span class="line">[NOTE]  8350.0ns Packet #0 Successfully Compared</span><br><span class="line">repeat time is 2</span><br><span class="line">this package from sa = 10 ,and da = 14</span><br><span class="line">payload is &#x27;&#123;&#x27;h7d, &#x27;h72, &#x27;h96, &#x27;h31, &#x27;hc4, &#x27;haa, &#x27;hc4&#125; </span><br><span class="line">palce 2 push_back data is 7d</span><br><span class="line">palce 2 push_back data is 72</span><br><span class="line">palce 2 push_back data is 96</span><br><span class="line">palce 2 push_back data is 31</span><br><span class="line">palce 2 push_back data is c4</span><br><span class="line">palce 2 push_back data is aa</span><br><span class="line">palce 1 push_back data is c4</span><br><span class="line">[NOTE] 15050.0ns Packet #1 Successfully Compared</span><br><span class="line">repeat time is 3</span><br><span class="line">this package from sa = 15 ,and da = 4</span><br><span class="line">payload is &#x27;&#123;&#x27;h88, &#x27;hf1, &#x27;h2c, &#x27;hce, &#x27;h5, &#x27;hcb, &#x27;h8c, &#x27;h1a, &#x27;h37&#125; </span><br><span class="line">palce 2 push_back data is 88</span><br><span class="line">palce 2 push_back data is f1</span><br><span class="line">palce 2 push_back data is 2c</span><br><span class="line">palce 2 push_back data is ce</span><br><span class="line">palce 2 push_back data is 5</span><br><span class="line">palce 2 push_back data is cb</span><br><span class="line">palce 2 push_back data is 8c</span><br><span class="line">palce 2 push_back data is 1a</span><br><span class="line">palce 1 push_back data is 37</span><br><span class="line">[NOTE] 23350.0ns Packet #2 Successfully Compared</span><br><span class="line">$finish at simulation time  24350.0ns</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="for循环的其他两个写法"><a href="#for循环的其他两个写法" class="headerlink" title="for循环的其他两个写法"></a>for循环的其他两个写法</h3><h4 id="写法一："><a href="#写法一：" class="headerlink" title="写法一："></a>写法一：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">forever begin</span><br><span class="line">    logic[7:0] datum;</span><br><span class="line">    for(int i=0; i&amp;lt;8; i=i)  begin </span><br><span class="line">        if(!rtr_io.cb.valido_n[da]) begin </span><br><span class="line">            datum[i] = rtr_io.cb.dout[da];</span><br><span class="line">            i++;</span><br><span class="line">            if(rtr_io.cb.frameo_n[da]) begin  </span><br><span class="line">                if(i==8) begin //byte alligned</span><br><span class="line">                  pkt2cmp_payload.push_back(datum);</span><br><span class="line">                    $display(&quot;palce 1 push_back data is %0h&quot;,datum);</span><br><span class="line">                  return;      </span><br><span class="line">              end</span><br><span class="line">              else begin</span><br><span class="line">                  $display(&quot;\n%m\n[ERROR]%t Packet payload not byte aligned!\n&quot;, $realtime);</span><br><span class="line">                  $finish;</span><br><span class="line">              end</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">        @(rtr_io.cb);</span><br><span class="line">    end</span><br><span class="line">    $display(&quot;palce 2 push_back data is %0h&quot;,datum);</span><br><span class="line">    pkt2cmp_payload.push_back(datum);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>写法一是正确的。<strong>说明i是先赋值，再进行＋1操作的</strong>。</p><h4 id="写法二："><a href="#写法二：" class="headerlink" title="写法二："></a>写法二：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">forever begin</span><br><span class="line">    logic[7:0] datum;</span><br><span class="line">    for(int i=0; i&amp;lt;8; i++)  begin </span><br><span class="line">        if(!rtr_io.cb.valido_n[da]) begin </span><br><span class="line">            datum[i] = rtr_io.cb.dout[da];</span><br><span class="line">            if(rtr_io.cb.frameo_n[da]) begin  </span><br><span class="line">                if(i==7) begin //byte alligned</span><br><span class="line">                  pkt2cmp_payload.push_back(datum);</span><br><span class="line">                    $display(&quot;palce 1 push_back data is %0h&quot;,datum);</span><br><span class="line">                  return;      </span><br><span class="line">              end</span><br><span class="line">              else begin</span><br><span class="line">                  $display(&quot;\n%m\n[ERROR]%t Packet payload not byte aligned!\n&quot;, $realtime);</span><br><span class="line">                  $finish;</span><br><span class="line">              end</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">        @(rtr_io.cb);</span><br><span class="line">    end</span><br><span class="line">    $display(&quot;palce 2 push_back data is %0h&quot;,datum);</span><br><span class="line">    pkt2cmp_payload.push_back(datum);</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>写法二是错误的，笔者不是很清楚这里的逻辑。理论上分析应该是对的，但是仿真打印信息是报错的。算是个遗留问题吧。</p><h3 id="for循环的基本使用"><a href="#for循环的基本使用" class="headerlink" title="for循环的基本使用"></a>for循环的基本使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for ( init; condition; increment )</span><br><span class="line">&#123;</span><br><span class="line">   statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是 for 循环的控制流：</p><p>init 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。接下来，会判断condition。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。在执行完 for 循环主体后，控制流会跳回上面的 increment 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。</p><h3 id="参数ref的理解"><a href="#参数ref的理解" class="headerlink" title="参数ref的理解"></a>参数ref的理解</h3><p><a href="https://blog.csdn.net/qq_41467882/article/details/121684326">system verilog中的参数传递——ref，input，output</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里我们在前两个lab的基础上继续完善，搭建一个数据接受的功能。在lab2 中我们实现了相关发送信息的打印，选择发送接受的端口，完善发送时序，在这一小节中将实现对端口发送数据的回收，然后进行比较发送的数据与预期是否一致。</summary>
      
    
    
    
    <category term="数字IC设计" scheme="http://example.com/categories/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="System Verilog labs学习笔记" scheme="http://example.com/categories/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1/System-Verilog-labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="sv_labs" scheme="http://example.com/tags/sv-labs/"/>
    
  </entry>
  
  <entry>
    <title>sv_labs学习笔记——sv_lab2(System Verilog)</title>
    <link href="http://example.com/2021/11/26/sv_labs/sv_labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94sv_lab2(System%20Verilog)/"/>
    <id>http://example.com/2021/11/26/sv_labs/sv_labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94sv_lab2(System%20Verilog)/</id>
    <published>2021-11-26T13:00:35.000Z</published>
    <updated>2022-05-02T14:13:55.731Z</updated>
    
    <content type="html"><![CDATA[<blockquote></blockquote><p>该博文在lab1的基础上，根据说明以及solution里的文件，实现了接口发送时序。简单对代码进行分析。分析的内容在文章的注释区中。对于不是很清楚的语法进行解释。最后在原文件的基础上给出增加了相关打印信息的版本。</p><h1 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h1><h2 id="DUT接口时序简述"><a href="#DUT接口时序简述" class="headerlink" title="DUT接口时序简述"></a>DUT接口时序简述</h2><p>我们首先了解下接口的时序。首先是输入信号，然后是输出接口的信号。</p><p><img src="https://img-blog.csdnimg.cn/68a20e8f29904a0b904f31dc6a35a41b.png" alt="&lt;br/&gt; 简单叙述下时序的一些要点。首先是输入信号，我们看到先是发送地址，需要在发送的时候拉低`frame_n`，然后在发送一个地址，4bit，这个时候不关心`vaild_n`信号。但是建议为高。然后发送pad，需要5个`cycle`。这时信号din以及`vaild_n`都是高，但是`frame_n`为低。接下来发送数据din信号开始发送数据，发送nbit的数据。在`D&lt;sub&gt;n-1&lt;/sub&gt;`的时候拉高`frame_n`信号。`din`有效时，`vaild_n`为低。就是输入的波形时序了。这里的A为`Destination Address`。就是目的地址，波形中就是在输出的那一根信号可以看到输出的波形。然后时输出时序。默认`vaildo_n`以及`framo_n`高电平。拉低`frameo_n`。下一个`cycle`拉低`valido_n`。`valido_n`为低电平时对应输出dout有效，反之。只有`frameo_n`为低，则表示输出有效。输出的数据是否有效，则看`vaildo_n`的信号即可。以上就是输入输出的时序波形了。注意这里的`sa`，`da`表示16个并行输入输出的某一个端口。"></p><h2 id="需要完成的任务"><a href="#需要完成的任务" class="headerlink" title="需要完成的任务"></a>需要完成的任务</h2><p>在本节lab2中，在lab1的基础上，产生激励。就是模拟发送的时序。实现的框图见下图 <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/f949c56cc9f7497295c9b54cb589e7f4.png"/></p><p>可以看到，在之前的基础上，添加了几个简单的功能模拟发送时序。接下来具体看实现的代码。最后，博主提供了添加打印信息的版本。打印了一些比较重要的信息。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>lab2的coding只需要将之前的lab1复制过来。在linux环境下执行<code>make mycopy</code>即可。可以大概看看Makefile文件。这里对make的使用不进行解释。同时我们只需要对test.sv进行修改即可。<br>与前面的相比，增加了这么几个变化。首先是新增加了四个变量，其中sa作为发送激励的端口。da作为数据发送出去的接口。（前面有看过router功能是一个0-15输入数据，送到0-15输出）<br>其中定义了一个payload。是一个队列，队列中的元素为一个<code>8bit</code>的数。用来对需要发送的数据进行缓存。详细的使用见绿皮书2.4队列一节。这里简单解释下。就是用来存储元素，其声明方式是使用<code>[$]</code>。队列元素的编号从<code>0-$</code>。使用时可以使用方法对其中的元素进行增加或删除。最后定义了一个元素，<code>run_for_n_packets</code>，用来判断需要进行几次发送。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">program automatic <span class="title function_">test</span><span class="params">(router_io.TB rtr_io)</span>;</span><br><span class="line">    bit[<span class="number">3</span>:<span class="number">0</span>] sa;</span><br><span class="line">    bit[<span class="number">3</span>:<span class="number">0</span>] da;</span><br><span class="line">    logic[<span class="number">7</span>:<span class="number">0</span>] payload[$];</span><br><span class="line">    <span class="type">int</span> run_for_n_packets;</span><br><span class="line">    </span><br><span class="line">initial begin </span><br><span class="line"><span class="comment">//$vcdpluson;//用于存储波形的方法，在使用questa-sim进行仿真的时候不需要</span></span><br><span class="line">    reset();</span><br><span class="line">    run_for_n_packets = <span class="number">3</span>;</span><br><span class="line">    repeat(run_for_n_packets) begin</span><br><span class="line">        <span class="title function_">gen</span><span class="params">()</span>;<span class="comment">//产生发送数据</span></span><br><span class="line">        send();<span class="comment">//产生激励，与时序保持一致</span></span><br><span class="line">    end</span><br><span class="line">    <span class="title function_">repeat</span><span class="params">(<span class="number">10</span>)</span> @<span class="params">(rtr_io.cb)</span>;<span class="comment">//每次发送结束间隔一定的时钟周期</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">task <span class="title function_">reset</span><span class="params">()</span>;</span><br><span class="line">  rtr_io.reset_n = <span class="number">1&#x27;b</span>0;</span><br><span class="line">  rtr_io.cb.frame_n &amp;lt;= <span class="string">&#x27;1;</span></span><br><span class="line"><span class="string">  rtr_io.cb.valid_n &amp;lt;= &#x27;</span><span class="number">1</span>;</span><br><span class="line">  ##<span class="number">2</span> rtr_io.cb.reset_n &amp;lt;= <span class="number">1&#x27;b</span>1;</span><br><span class="line">  repeat(<span class="number">15</span>) @(rtr_io.cb);</span><br><span class="line">endtask: reset</span><br><span class="line"></span><br><span class="line">task <span class="title function_">gen</span><span class="params">()</span>;<span class="comment">//该task定义了发送接收的端口。</span></span><br><span class="line">  sa = <span class="number">3</span>;<span class="comment">//发送的端口为3</span></span><br><span class="line">  da = <span class="number">7</span>;<span class="comment">//接收数据的端口为7</span></span><br><span class="line">  payload.delete(); <span class="comment">//clear previous data 删除原始数据，推荐使用</span></span><br><span class="line">  repeat($urandom_range(<span class="number">9</span>,<span class="number">2</span>))<span class="comment">//重复2-9次，该函数后续进行说明</span></span><br><span class="line">    payload.push_back($urandom);<span class="comment">//在队列中写入数据，一次只能写队列的一个元素，就是8bit，这里返回的是一个32bit的数。会截取低八位。该函数后续进行介绍。</span></span><br><span class="line">endtask: gen</span><br><span class="line"></span><br><span class="line">task <span class="title function_">send</span><span class="params">()</span>;<span class="comment">//这个任务将分为三个任务，注意对于任务拆分的思想！！！</span></span><br><span class="line"><span class="comment">//我们看到，发送的时序分为三段，第一段发送地址，然后发送pad，最后实现数据的发送。这里均进行了模拟。且并没有揉在一起。简化简洁。</span></span><br><span class="line">  send_addrs();</span><br><span class="line">  send_pad();</span><br><span class="line">  send_payload();</span><br><span class="line">endtask: send</span><br><span class="line"> </span><br><span class="line">task <span class="title function_">send_addrs</span><span class="params">()</span>;<span class="comment">//发送的前一个时钟上升沿将frame_n拉低，frame_n有16个bit。拉低的哪一位就是需要发送的数据了。</span></span><br><span class="line">  rtr_io.cb.frame_n[sa] &amp;lt;= <span class="number">1&#x27;b</span>0; <span class="comment">//start of packet</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&amp;lt;<span class="number">4</span>; i++) begin</span><br><span class="line">    rtr_io.cb.din[sa] &amp;lt;= da[i]; <span class="comment">//i&#x27;th bit of da同时在这个相同的时钟沿将接收地址发送出去</span></span><br><span class="line">    @(rtr_io.cb);然后改变推进一个时钟周期。同时进行循环四次。</span><br><span class="line">  end</span><br><span class="line">endtask: send_addrs</span><br><span class="line"></span><br><span class="line">task <span class="title function_">send_pad</span><span class="params">()</span>;<span class="comment">//发送pad时序需要将din，valid_n拉高，frame_n保持为低即可。维持5个cycle</span></span><br><span class="line">  rtr_io.cb.frame_n[sa] &amp;lt;= <span class="number">1&#x27;b</span>0;</span><br><span class="line">  rtr_io.cb.valid_n[sa] &amp;lt;= <span class="number">1&#x27;b</span>1;</span><br><span class="line">  rtr_io.cb.din[sa] &amp;lt;= <span class="number">1&#x27;b</span>1;</span><br><span class="line">  repeat(<span class="number">5</span>) @(rtr_io.cb);</span><br><span class="line">endtask: send_pad</span><br><span class="line"></span><br><span class="line">task <span class="title function_">send_payload</span><span class="params">()</span>;<span class="comment">//将准备好的数据进行发送</span></span><br><span class="line">  foreach(payload[index])<span class="comment">//循环次数为队列元素的个数</span></span><br><span class="line">  $display(index,payload[index]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&amp;lt;<span class="number">8</span>; i++) begin</span><br><span class="line">        rtr_io.cb.din[sa] &amp;lt;= payload[index][i];<span class="comment">//注意这里发送的高低位，先发送的是地位</span></span><br><span class="line">      rtr_io.cb.valid_n[sa] &amp;lt;= <span class="number">1&#x27;b</span>0; <span class="comment">//driving a valid bit</span></span><br><span class="line">      rtr_io.cb.frame_n[sa] &amp;lt;= ((i == <span class="number">7</span>) &amp;amp;&amp;amp; (index == (payload.size() - <span class="number">1</span>)));<span class="comment">//frame_n根据时序，在适当的时候拉高。</span></span><br><span class="line">  @(rtr_io.cb);</span><br><span class="line">    end</span><br><span class="line">  rtr_io.cb.valid_n[sa] &amp;lt;= <span class="number">1&#x27;b</span>1;<span class="comment">//当完成发送的时候，valid_n也拉高，相比较于frame_n后延时一个cycle</span></span><br><span class="line">endtask: send_payload</span><br><span class="line">endprogram: test</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="相关语法解释"><a href="#相关语法解释" class="headerlink" title="相关语法解释"></a>相关语法解释</h2><h3 id="urandom-range"><a href="#urandom-range" class="headerlink" title="$urandom_range(,)"></a>$urandom_range(,)</h3><p>函数的作用是：返回指定范围内的无符号整数。</p><h3 id="urandom"><a href="#urandom" class="headerlink" title="$urandom"></a>$urandom</h3><p>系统函数<code>$urandom</code>提供了一种生成伪随机数的机制。这个函数每次调用时返回一个新的32位随机数。数字为无符号。<br>使用的语法为<code>$urandom [ (int seed ) ]</code><br>。其中seed作为一个随机种子是可选的。seed是一个可选参数，用于确定生成的随机数序列。种子可以是任何积分表达式。随机数发生器（<code>RNG</code>）应生成相同的序列每次使用同一种子时的随机数。<code>RNG</code>是确定性的。每次程序执行时，它都会循环执行相同的随机序列。通过在<code>$urandom</code>函数中植入外部随机变量，可以使该序列不确定变量，例如一天中的时间。<code>$random</code>，系统随机化调用函数，返回32bit有符号数。<br>同样看下面这个实例来理解给个函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">module <span class="title function_">urandom</span><span class="params">()</span>;</span><br><span class="line">bit [<span class="number">64</span>:<span class="number">1</span>] addr;</span><br><span class="line">bit [ <span class="number">3</span>:<span class="number">0</span>] number;</span><br><span class="line">initial begin </span><br><span class="line">addr[<span class="number">32</span>:<span class="number">1</span>] = $urandom(); <span class="comment">// Initialize the generator// get 32-bit random number</span></span><br><span class="line">$display(<span class="string">&quot;message 1 :addr is %0h,number is %0h&quot;</span>,addr,number);</span><br><span class="line">addr = &#123;$urandom, $urandom&#125;; <span class="comment">// 64-bit random number</span></span><br><span class="line">number= $urandom &amp;amp; <span class="number">15</span>; <span class="comment">// 4-bit random  number</span></span><br><span class="line">$display(<span class="string">&quot;message 2 :addr is %0h,number is %0h&quot;</span>,addr,number);</span><br><span class="line">end   </span><br><span class="line">endmodule </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果如下。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">message <span class="number">1</span> :addr is eb5aa3b8,number is <span class="number">0</span></span><br><span class="line">message <span class="number">2</span> :addr is <span class="number">17750</span>c269d0db966,number is <span class="number">6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>无论运行多少次，结果都是一样的，有兴趣可以自己尝试。或者使用repeat()函数，就不会产生一样的随机结果。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">module <span class="title function_">urandom</span><span class="params">()</span>;</span><br><span class="line">bit [<span class="number">64</span>:<span class="number">1</span>] addr;</span><br><span class="line">bit [ <span class="number">3</span>:<span class="number">0</span>] number;</span><br><span class="line">initial begin </span><br><span class="line"><span class="title function_">repeat</span><span class="params">(<span class="number">3</span>)</span> begin </span><br><span class="line">addr[32:1] = $urandom(); <span class="comment">// Initialize the generator// get 32-bit random number</span></span><br><span class="line">$display(<span class="string">&quot;message 1 :addr is %0h&quot;</span>,addr);</span><br><span class="line">addr = &#123;$urandom, $urandom&#125;; <span class="comment">// 64-bit random number</span></span><br><span class="line">number= $urandom % <span class="number">15</span>; <span class="comment">// 4-bit random  number</span></span><br><span class="line">$display(<span class="string">&quot;message 2 :addr is %0h,number is %0h&quot;</span>,addr,number);</span><br><span class="line">end</span><br><span class="line">end   </span><br><span class="line">endmodule </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>仿真结果如下,但是你再进行仿真，这个结果还是不会变。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">message <span class="number">1</span> :addr is eb5aa3b8</span><br><span class="line">message <span class="number">2</span> :addr is <span class="number">17750</span>c269d0db966,number is <span class="number">2</span></span><br><span class="line">message <span class="number">1</span> :addr is <span class="number">17750</span>c26510e08c6</span><br><span class="line">message <span class="number">2</span> :addr is <span class="number">83956e463</span>bd10f72,number is <span class="number">7</span></span><br><span class="line">message <span class="number">1</span> :addr is <span class="number">83956e46</span>fa374467</span><br><span class="line">message <span class="number">2</span> :addr is <span class="number">3386553</span>a46f91c6a,number is <span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>这里简单解释，foreach(array[i])就是将其中的变量进行遍历。直接看输出会更清楚。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">module <span class="title function_">tb_foreach</span><span class="params">()</span>;</span><br><span class="line"><span class="built_in">string</span> words [<span class="number">2</span>] = <span class="string">&#x27;&#123; &quot;hello&quot;, &quot;world&quot; &#125;;</span></span><br><span class="line"><span class="string">int prod [1:8] [1:3];</span></span><br><span class="line"><span class="string">initial begin </span></span><br><span class="line"><span class="string">foreach( words[j] ) begin</span></span><br><span class="line"><span class="string">$display(&quot;j is %0d,words index is j  is %0s&quot;,j,words[j]); // print each index and value</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">foreach( prod[k,m] ) begin </span></span><br><span class="line"><span class="string">prod[k][m] = k * m; // initialize</span></span><br><span class="line"><span class="string">$display(&quot;current k is %0d,current m is %0d,the value in prod[k,j] is %0d&quot;,k,m,prod[k][m]); </span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">end </span></span><br><span class="line"><span class="string">endmodule </span></span><br></pre></td></tr></table></figure><p>对应的输出为</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># j is 0,words index is j  is hello</span></span><br><span class="line"><span class="meta"># j is 1,words index is j  is world</span></span><br><span class="line"><span class="meta"># current k is 1,current m is 1,the value in prod[k,j] is 1</span></span><br><span class="line"><span class="meta"># current k is 1,current m is 2,the value in prod[k,j] is 2</span></span><br><span class="line"><span class="meta"># current k is 1,current m is 3,the value in prod[k,j] is 3</span></span><br><span class="line"><span class="meta"># current k is 2,current m is 1,the value in prod[k,j] is 2</span></span><br><span class="line">......</span><br><span class="line"><span class="meta"># current k is 7,current m is 3,the value in prod[k,j] is 21</span></span><br><span class="line"><span class="meta"># current k is 8,current m is 1,the value in prod[k,j] is 8</span></span><br><span class="line"><span class="meta"># current k is 8,current m is 2,the value in prod[k,j] is 16</span></span><br><span class="line"><span class="meta"># current k is 8,current m is 3,the value in prod[k,j] is 24</span></span><br></pre></td></tr></table></figure><h2 id="添加信息打印版本"><a href="#添加信息打印版本" class="headerlink" title="添加信息打印版本"></a>添加信息打印版本</h2><p>简单补充后的代码如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">program automatic <span class="title function_">test</span><span class="params">(router_io.TB rtr_io)</span>;</span><br><span class="line">    bit[<span class="number">3</span>:<span class="number">0</span>] sa;</span><br><span class="line">    bit[<span class="number">3</span>:<span class="number">0</span>] da;</span><br><span class="line">    logic[<span class="number">7</span>:<span class="number">0</span>] payload[$];</span><br><span class="line">    <span class="type">int</span> run_for_n_packets;</span><br><span class="line"></span><br><span class="line">    integer repeat_times = <span class="number">1</span>;</span><br><span class="line">initial begin</span><br><span class="line">    $vcdpluson;</span><br><span class="line">    reset();</span><br><span class="line">    run_for_n_packets = <span class="number">3</span>;</span><br><span class="line">    repeat(run_for_n_packets) begin</span><br><span class="line">        $display(<span class="string">&quot;repeat time is %0d&quot;</span>,repeat_times);</span><br><span class="line">        repeat_times = repeat_times + <span class="number">1</span>;</span><br><span class="line">        gen();</span><br><span class="line">        $display(<span class="string">&quot;payload is &quot;</span>,payload);</span><br><span class="line">        send();</span><br><span class="line">    end</span><br><span class="line">    <span class="title function_">repeat</span><span class="params">(<span class="number">10</span>)</span> @<span class="params">(rtr_io.cb)</span>;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">task <span class="title function_">reset</span><span class="params">()</span>;</span><br><span class="line">  rtr_io.reset_n = <span class="number">1&#x27;b</span>0;</span><br><span class="line">  rtr_io.cb.frame_n &amp;lt;= <span class="string">&#x27;1;</span></span><br><span class="line"><span class="string">  rtr_io.cb.valid_n &amp;lt;= &#x27;</span><span class="number">1</span>;</span><br><span class="line">  ##<span class="number">2</span> rtr_io.cb.reset_n &amp;lt;= <span class="number">1&#x27;b</span>1;</span><br><span class="line">  repeat(<span class="number">15</span>) @(rtr_io.cb);</span><br><span class="line">endtask: reset</span><br><span class="line"></span><br><span class="line">task <span class="title function_">gen</span><span class="params">()</span>;</span><br><span class="line">  sa = <span class="number">3</span>;</span><br><span class="line">  da = <span class="number">7</span>;</span><br><span class="line">  payload.delete(); <span class="comment">//clear previous data</span></span><br><span class="line">  repeat($urandom_range(<span class="number">9</span>,<span class="number">2</span>))</span><br><span class="line">    payload.push_back($urandom());</span><br><span class="line">endtask: gen</span><br><span class="line"></span><br><span class="line">task <span class="title function_">send</span><span class="params">()</span>;</span><br><span class="line">  send_addrs();</span><br><span class="line">  send_pad();</span><br><span class="line">  send_payload();</span><br><span class="line">endtask: send</span><br><span class="line"> </span><br><span class="line">task <span class="title function_">send_addrs</span><span class="params">()</span>;</span><br><span class="line">  rtr_io.cb.frame_n[sa] &amp;lt;= <span class="number">1&#x27;b</span>0; <span class="comment">//start of packet</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&amp;lt;<span class="number">4</span>; i++) begin</span><br><span class="line">    rtr_io.cb.din[sa] &amp;lt;= da[i]; <span class="comment">//i&#x27;th bit of da</span></span><br><span class="line">    @(rtr_io.cb);</span><br><span class="line">  end</span><br><span class="line">endtask: send_addrs</span><br><span class="line"></span><br><span class="line">task <span class="title function_">send_pad</span><span class="params">()</span>;</span><br><span class="line">  rtr_io.cb.frame_n[sa] &amp;lt;= <span class="number">1&#x27;b</span>0;</span><br><span class="line">  rtr_io.cb.valid_n[sa] &amp;lt;= <span class="number">1&#x27;b</span>1;</span><br><span class="line">  rtr_io.cb.din[sa] &amp;lt;= <span class="number">1&#x27;b</span>1;</span><br><span class="line">  repeat(<span class="number">5</span>) @(rtr_io.cb);</span><br><span class="line">endtask: send_pad</span><br><span class="line"></span><br><span class="line">task <span class="title function_">send_payload</span><span class="params">()</span>;</span><br><span class="line">  foreach(payload[index]) begin </span><br><span class="line">    $display(<span class="string">&quot;index is %0d,payload[index] is %0h &quot;</span>,index,payload[index]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&amp;lt;<span class="number">8</span>; i++) begin</span><br><span class="line">        rtr_io.cb.din[sa] &amp;lt;= payload[index][i];</span><br><span class="line">      rtr_io.cb.valid_n[sa] &amp;lt;= <span class="number">1&#x27;b</span>0; <span class="comment">//driving a valid bit</span></span><br><span class="line">      rtr_io.cb.frame_n[sa] &amp;lt;= ((i == <span class="number">7</span>) &amp;amp;&amp;amp; (index == (payload.size() - <span class="number">1</span>)));</span><br><span class="line">  @(rtr_io.cb);</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">  rtr_io.cb.valid_n[sa] &amp;lt;= <span class="number">1&#x27;b</span>1;</span><br><span class="line">endtask: send_payload</span><br><span class="line"></span><br><span class="line">endprogram: test</span><br></pre></td></tr></table></figure><p>打印的信息为</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">repeat time is <span class="number">1</span></span><br><span class="line">payload is <span class="string">&#x27;&#123;&#x27;</span>h3c, <span class="string">&#x27;h7d, &#x27;</span>he2, <span class="string">&#x27;hb, &#x27;</span>hdf, <span class="string">&#x27;h40, &#x27;</span>hf7, <span class="string">&#x27;ha6&#125; </span></span><br><span class="line"><span class="string">index is 0,payload[index] is 3c </span></span><br><span class="line"><span class="string">index is 1,payload[index] is 7d </span></span><br><span class="line"><span class="string">index is 2,payload[index] is e2 </span></span><br><span class="line"><span class="string">index is 3,payload[index] is b </span></span><br><span class="line"><span class="string">index is 4,payload[index] is df </span></span><br><span class="line"><span class="string">index is 5,payload[index] is 40 </span></span><br><span class="line"><span class="string">index is 6,payload[index] is f7 </span></span><br><span class="line"><span class="string">index is 7,payload[index] is a6 </span></span><br><span class="line"><span class="string">repeat time is 2</span></span><br><span class="line"><span class="string">payload is &#x27;</span>&#123;<span class="string">&#x27;hb5, &#x27;</span>hfa, <span class="string">&#x27;h4e, &#x27;</span>h15, <span class="string">&#x27;h7d&#125; </span></span><br><span class="line"><span class="string">index is 0,payload[index] is b5 </span></span><br><span class="line"><span class="string">index is 1,payload[index] is fa </span></span><br><span class="line"><span class="string">index is 2,payload[index] is 4e </span></span><br><span class="line"><span class="string">index is 3,payload[index] is 15 </span></span><br><span class="line"><span class="string">index is 4,payload[index] is 7d </span></span><br><span class="line"><span class="string">repeat time is 3</span></span><br><span class="line"><span class="string">payload is &#x27;</span>&#123;<span class="string">&#x27;h96, &#x27;</span>h31, <span class="string">&#x27;hc4, &#x27;</span>haa&#125; </span><br><span class="line">index is <span class="number">0</span>,payload[index] is <span class="number">96</span> </span><br><span class="line">index is <span class="number">1</span>,payload[index] is <span class="number">31</span> </span><br><span class="line">index is <span class="number">2</span>,payload[index] is c4 </span><br><span class="line">index is <span class="number">3</span>,payload[index] is aa </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;该博文在lab1的基础上，根据说明以及solution里的文件，实现了接口发送时序。简单对代码进行分析。分析的内容在文章的注释区中。对于不是很清楚的语法进行解释。最后在原文件的基础上给出增加了相关打印信息的版本。&lt;/p&gt;</summary>
      
    
    
    
    <category term="数字IC设计" scheme="http://example.com/categories/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="System Verilog labs学习笔记" scheme="http://example.com/categories/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1/System-Verilog-labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="sv_labs" scheme="http://example.com/tags/sv-labs/"/>
    
  </entry>
  
  <entry>
    <title>sv_labs学习笔记--专栏说明&amp;博文目录</title>
    <link href="http://example.com/2021/11/25/sv_labs/sv_labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E4%B8%93%E6%A0%8F%E8%AF%B4%E6%98%8E&amp;%E5%8D%9A%E6%96%87%E7%9B%AE%E5%BD%95/"/>
    <id>http://example.com/2021/11/25/sv_labs/sv_labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E4%B8%93%E6%A0%8F%E8%AF%B4%E6%98%8E&amp;%E5%8D%9A%E6%96%87%E7%9B%AE%E5%BD%95/</id>
    <published>2021-11-25T11:50:47.000Z</published>
    <updated>2022-05-02T14:05:10.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栏目说明"><a href="#栏目说明" class="headerlink" title="栏目说明"></a>栏目说明</h1><p>专栏主要提供sv_labs学习过程中笔者认为比较重要的点以及相关延申。本文假设读者已经具有相关语言的背景。不会过分纠结语言本身，但会重点对于一些语言进行理解。语言的理解见笔者的另外一个专栏<a href="https://blog.csdn.net/qq_41467882/category_11469097.html">System Verilog自学笔记</a>。</p><p>网上的资料也很多，本文会在其他参考中给出部分的资料清单。</p><p>本系列的重点会放在一些比较细的语法使用，具体语法意义的理解上，环境的搭建，笔者自己的学习理解等。 道阻且长…愿本系列博文能对您的学习有所帮助。算是总结自己学习的过程，也算是一种分享。有问题欢迎留言指出。万分感谢~</p><h1 id="博文目录"><a href="#博文目录" class="headerlink" title="博文目录"></a>博文目录</h1><p><a href="https://blog.csdn.net/qq_41467882/article/details/121544980">sv_labs学习笔记——sv_lab1(System Verilog)</a><br><a href="https://blog.csdn.net/qq_41467882/article/details/121565861">sv_labs学习笔记——sv_lab2(System Verilog)</a><br><a href="https://blog.csdn.net/qq_41467882/article/details/121658459">sv_labs学习笔记——sv_lab3(System Verilog)</a><br><a href="https://blog.csdn.net/qq_41467882/article/details/121719398">sv_labs学习笔记——sv_lab4(System Verilog)</a><br><a href="https://blog.csdn.net/qq_41467882/article/details/122334222">sv_labs学习笔记——sv_lab5_上(System Verilog)</a><br><a href="https://blog.csdn.net/qq_41467882/article/details/122363659">sv_labs学习笔记——sv_lab5_下(System Verilog)</a></p><h1 id="资源分享"><a href="#资源分享" class="headerlink" title="资源分享"></a>资源分享</h1><h2 id="环境配置资源"><a href="#环境配置资源" class="headerlink" title="环境配置资源"></a>环境配置资源</h2><h3 id="linux环境"><a href="#linux环境" class="headerlink" title="linux环境"></a>linux环境</h3><p>关于虚拟机自己要是不想配置环境，可以使用大佬分享已经配置好的。笔者是自行配置的虚拟机，地址如下。感觉使用已经配置好的少了些许自行配置的乐趣，失去了灵魂。因此分享一个好用的安装教程<a href="https://blog.csdn.net/qq_41467882/article/details/121230693">IC虚拟机环境分享</a></p><h3 id="windows环境"><a href="#windows环境" class="headerlink" title="windows环境"></a>windows环境</h3><p>也可以使用windows环境进行编译，使用questsim 即可。他是modelsim的升级版，使用起来基本上没有什么区别。很好上手。链接如下，内容为<strong>questsim 10.6.c</strong>的安装包，内涵破解文件。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">链接：https:<span class="comment">//pan.baidu.com/s/1J6p4xgbuq2188GuXe3y8Uw </span></span><br><span class="line">提取码：f96j </span><br><span class="line">--来自百度网盘超级会员V3的分享</span><br></pre></td></tr></table></figure><h2 id="sv-labs资源与实验指导手册"><a href="#sv-labs资源与实验指导手册" class="headerlink" title="sv_labs资源与实验指导手册"></a>sv_labs资源与实验指导手册</h2><p><a href="https://bbs.eetop.cn/thread-916593-1-1.html">sv_labs资源与实验指导手册</a> 自行注册一个eetop的论讨账号博主感觉是很有必要的。里面的学习资源超级多！！！</p><h1 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h1><p>1，QuestaSim的使用。博文队长-Leader的<a href="https://blog.csdn.net/k331922164/article/details/50001035">Modelsim&#x2F;QuestaSim教程——DO文件篇</a>真的很棒，里边的可能用不全，使用里面的一些脚本可以实现我们自己简单，定制的<code>.do</code>文件。</p><p>2，路桑的系列博文，主要是对于实验手册的相关翻译理解。 </p><p><a href="https://blog.csdn.net/liubin1222/article/details/81169314">IC验证培训——实战SV验证学习（lab1）</a><br><a href="https://blog.csdn.net/liubin1222/article/details/81169915?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link">IC验证培训——实战SV验证学习（lab2）</a><br><a href="https://blog.csdn.net/liubin1222/article/details/81180659?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link">IC验证培训——实战SV验证学习（lab3）</a><br><a href="https://blog.csdn.net/liubin1222/article/details/81180989?spm=1001.2101.3001.6650.17&utm_medium=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-17.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-17.no_search_link">IC验证培训——实战SV验证学习（lab4）</a><br><a href="https://blog.csdn.net/liubin1222/article/details/81237808?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.no_search_link">IC验证培训——实战SV验证学习（lab5）</a><br><a href="https://blog.csdn.net/liubin1222/article/details/81286740?spm=1001.2101.3001.6650.10&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-10.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-10.no_search_link">IC验证培训——实战SV验证学习（lab6）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;栏目说明&quot;&gt;&lt;a href=&quot;#栏目说明&quot; class=&quot;headerlink&quot; title=&quot;栏目说明&quot;&gt;&lt;/a&gt;栏目说明&lt;/h1&gt;&lt;p&gt;专栏主要提供sv_labs学习过程中笔者认为比较重要的点以及相关延申。本文假设读者已经具有相关语言的背景。不会过分纠结语言本</summary>
      
    
    
    
    <category term="数字IC设计" scheme="http://example.com/categories/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="System Verilog labs学习笔记" scheme="http://example.com/categories/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1/System-Verilog-labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="sv_labs" scheme="http://example.com/tags/sv-labs/"/>
    
  </entry>
  
  <entry>
    <title>sv_labs学习笔记——sv_lab1(System Verilog)</title>
    <link href="http://example.com/2021/11/25/sv_labs/sv_labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94sv_lab1(System%20Verilog)/"/>
    <id>http://example.com/2021/11/25/sv_labs/sv_labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94sv_lab1(System%20Verilog)/</id>
    <published>2021-11-25T11:14:21.000Z</published>
    <updated>2022-05-02T14:22:40.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>首先明确实验的DUT(Design Under Test)的大致功能，然后我们再进一步进行下面的实验内容。如下图是DUT的一个基本的示意图。带仿真的是一个router(路由器)，接口相关的信息图下所示。通过发送激励来观察输出是否与预期保持一致。看起来接口命名还是很清楚的，后续有需要再对DUT进行进一步的解释（因为验证我们并不一定要非常清楚这个模块的功能，但是我们需要明白接口的基本协议，也就是接口的时序，我们会在后续有关lab中给出时序图）。基本功能就是将任意一个输入口的数据送到任意一路的输出。对于该笔记,则重点放在对于相关学习过程中的容易疏漏的知识点以及相关的延申。 <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/fc43fc70e96445a6a782a24bb7568458.png"/></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//router的接口信息</span><br><span class="line">module router(</span><br><span class="line">reset_n, clock, frame_n, valid_n, din, dout, busy_n, valido_n, frameo_n);</span><br><span class="line">input reset_n, clock;</span><br><span class="line">input [15:0] din, frame_n, valid_n;</span><br><span class="line">output [15:0] dout, valido_n, busy_n, frameo_n;</span><br></pre></td></tr></table></figure><p>本系类所有的测试都是如下图所示的实现逻辑。 <img src="https://img-blog.csdnimg.cn/a4446deae434465b8cb92b7672629e15.png" alt="&lt;br/&gt; 因此对于测试环境的修改只需要修改测试环境即可。"></p><hr><h1 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h1><h2 id="功能简述"><a href="#功能简述" class="headerlink" title="功能简述"></a>功能简述</h2><p>该部分的lab就是搭建一个简单的环境，对于DUT进行一次复位操作。编写了三个.sv文件，其中有接口，测试程序以及顶层测试文件。router_test_top作为测试顶层，例化了待测试模块，接口模块，测试模块。 这里展示我们该lab需要去实现的内容以及框图。 <img src="https://img-blog.csdnimg.cn/5de057ad0a3a4a6f8e45f77907ba5300.png" alt="&lt;br/&gt; 我们知道，实现一个sv的测试平台，简单来讲需要产生激励，然后发送激励到接口，接口连接DUT与测试平台，最后在收集数据进行比较。我们这里第一步完成接口(router_io.sv)的创建，一个简单的测试程序(test.sv)的编写，以及测试环境顶层(router_test_top.sv)的搭建。该测试程序完成了对待测试模块的复位。"></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="仿真精度"><a href="#仿真精度" class="headerlink" title="仿真精度"></a>仿真精度</h3><p>&#96;&#96;timescale 1ns&#x2F;100ps&#96; 仿真时间单位&#x2F;时间精度。这个可以理解为尺子。尺子可以量的最小的1cm，但是精度是1mm。</p><h3 id="理解repeat-15-rtr-io-cb"><a href="#理解repeat-15-rtr-io-cb" class="headerlink" title="理解repeat(15) @(rtr_io.cb);"></a>理解repeat(15) @(rtr_io.cb);</h3><p>首先是概念的理解。这里给出一个实例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clocking dram @(posedge phi1);</span><br><span class="line">inout data;</span><br><span class="line">output negedge #1 address;</span><br><span class="line">endclocking</span><br></pre></td></tr></table></figure><p>时钟的上升沿表示为 <code>@(dram); 等于 @(posedge phi1)</code> 测试平台可以使用@rtr_io.cb来等待时钟，而省略了时钟的边沿。这里其实可以理解@rtr_io.cb的作用为向前推进仿真时间到一个时钟的上升沿。 我们可以进行下面几个测试实例来理解该功能。这里的<strong>系统时钟周期为100ns，时间单位为1ns，时钟无shew，默认时钟起始电平为低</strong> 测试程序首先修改为如下，先将仿真时间向前推进五个时钟周期,然后对相关变量进行赋值，注意这里的赋值方式。对于异步，进行阻塞赋值，同步的信号，或者是想要进行同步的信号，使用非阻塞赋值。 文件<strong>test.sv</strong>如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/`timescale 1ns/100ps</span><br><span class="line">program automatic test(router_io.TB rtr_io);</span><br><span class="line">  initial begin</span><br><span class="line">    //$vcdpluson; //don&#x27;t need in questasim enviroment</span><br><span class="line">reset();</span><br><span class="line">  end</span><br><span class="line">task reset();</span><br><span class="line">  repeat(5) @(rtr_io.cb);</span><br><span class="line">  rtr_io.reset_n = 1&#x27;b0;</span><br><span class="line">  rtr_io.cb.frame_n &amp;lt;= &#x27;1;</span><br><span class="line">  rtr_io.cb.valid_n &amp;lt;= &#x27;1;</span><br><span class="line">  #95 rtr_io.cb.reset_n &amp;lt;= 1&#x27;b1;</span><br><span class="line">  repeat(5) @(rtr_io.cb);//将仿真时间向前推进一个时钟上升沿。这里重复十次</span><br><span class="line">endtask: reset</span><br><span class="line">endprogram: test</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/a5f8a6e80444446a9f9f8e9b24b8e54d.png" alt="&lt;br/&gt; 分析波形来看，首先时钟推进了5个上升沿。这之前所有接口的变量均为X态。信号都是logic类型，它是4值变量，初始态为x。当第五个上升沿到来之后，开始对信号进行赋值。执行`rtr_io.reset_n = 1&#39;b0;`由于恰好是上沿，执行`rtr_io.cb.frame_n &lt;= &#39;1;rtr_io.cb.valid_n &lt;= &#39;1;`然后延时45ns，由于这时不是上升沿，不会执行赋值，然后仿真再向前推进5个时钟周期，在第一个上升沿对reset_n进行拉高操作。一共有十个上升沿。&lt;br/&gt; 接下来将赋值延时时间修改为105ns&lt;br/&gt; 得到的仿真图如下&lt;br/&gt; &lt;img alt=&quot;在这里插入图片描述&quot; src=&quot;https://img-blog.csdnimg.cn/e1ec68f42b0c44c7b18f07cf60f862b3.png&quot;&gt;&lt;br/&gt; 可以看到，reset_n如我们所预期的，并没有在第六个上升沿拉高，而是在第七个，这时候一共有11个上升沿。&lt;br/&gt; 据此可以得到，在仿真进行的时候，`@(rtr_io.cb)`用来推进仿真的时间，推进方式为上升沿推进。若是在次期间有信号需要在边沿操作，则会等待，在上升沿进行执行。&lt;br/&gt; 注意将顶层代码时钟的初始电平改变，可能得到的波形会不同。"></img></p><h3 id="理解-timeformat"><a href="#理解-timeformat" class="headerlink" title="理解$timeformat"></a>理解$timeformat</h3><p><code>$timeformat(-9, 1, “ns”, 10);</code>timeformat的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$timeformat(units_number, precision_number, suffix_string, minimum_field_wdith);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$timeformat不会更改`timescale设置的的时间单位与精度，它只是更改了$write、$display、$strobe、$monitor、$fwrite、$fdisplay、$fstrobe、$fmonitor等任务在%t格式下显示时间的方式。</span><br></pre></td></tr></table></figure><h3 id="理解Input-and-output-skews"><a href="#理解Input-and-output-skews" class="headerlink" title="理解Input and output skews"></a>理解Input and output skews</h3><p>lab1中添加了输入输出延时<code>default input #1ns output #1ns;</code> <img src="https://img-blog.csdnimg.cn/71f0e76144c04950902da22b931c53c6.png" alt="&lt;br/&gt; 根据[博文 IC验证培训——实战SV验证学习（lab1）](https://blog.csdn.net/liubin1222/article/details/81169314)，路桑 的解释为"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input  #1ns 指的是采样时间相对时钟上升沿提前1ns，但不在波形上显示。用来模拟真实电路中的建立时间。  </span><br><span class="line">output #1ns指的是驱动时间相对时钟上升沿推后1ns，会在波形上显示出来。用来模拟真实电路中的传播延时。</span><br></pre></td></tr></table></figure><p>在添加后执行<code>sim.do</code>文件，我们发现<code>reset_n</code>相对时钟上升沿推后1ns，得到的仿真图如下 <img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/05256553d0d540a2b697810c18b7571f.png"/></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>给出顶层代码</p><p>文件<strong>router_test_top.sv</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">module router_test_top;</span><br><span class="line">  parameter simulation_cycle = <span class="number">100</span>;</span><br><span class="line">  bit SystemClock; </span><br><span class="line">  router_io <span class="title function_">top_io</span><span class="params">(SystemClock)</span>;</span><br><span class="line">  test <span class="title function_">t</span><span class="params">(top_io)</span>;</span><br><span class="line">  router <span class="title function_">dut</span><span class="params">(</span></span><br><span class="line"><span class="params">    .reset_n(top_io.reset_n),</span></span><br><span class="line"><span class="params">    .clock(top_io.clock),</span></span><br><span class="line"><span class="params">    .din(top_io.din),</span></span><br><span class="line"><span class="params">    .frame_n(top_io.frame_n),</span></span><br><span class="line"><span class="params">    .valid_n(top_io.valid_n),</span></span><br><span class="line"><span class="params">    .dout(top_io.dout),</span></span><br><span class="line"><span class="params">    .valido_n(top_io.valido_n),</span></span><br><span class="line"><span class="params">    .busy_n(top_io.busy_n),</span></span><br><span class="line"><span class="params">    .frameo_n(top_io.frameo_n)</span></span><br><span class="line"><span class="params">  )</span>;</span><br><span class="line">  initial begin</span><br><span class="line">$timeformat(<span class="number">-9</span>, <span class="number">1</span>, <span class="string">&quot;ns&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    SystemClock = <span class="number">0</span>;</span><br><span class="line">    forever begin</span><br><span class="line">      #(simulation_cycle/<span class="number">2</span>)</span><br><span class="line">        SystemClock = ~SystemClock;</span><br><span class="line">    end</span><br><span class="line">  end</span><br></pre></td></tr></table></figure><p>给出接口部分代码</p><p>文件<strong>router_io.sv</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`timescale 1ns/100ps</span><br><span class="line">interface router_io(input bit clock);</span><br><span class="line">  logicreset_n;</span><br><span class="line">  logic [15:0]din;</span><br><span class="line">  logic [15:0]frame_n;</span><br><span class="line">  logic [15:0]valid_n;</span><br><span class="line">  logic [15:0]dout;</span><br><span class="line">  logic [15:0]valido_n;</span><br><span class="line">  logic [15:0]busy_n;</span><br><span class="line">  logic [15:0]frameo_n;</span><br><span class="line">  clocking cb @(posedge clock);</span><br><span class="line">default input #1ns output #1ns;</span><br><span class="line">    output reset_n;</span><br><span class="line">output din;</span><br><span class="line">output frame_n;</span><br><span class="line">output valid_n;</span><br><span class="line">input  dout;</span><br><span class="line">input  valido_n;</span><br><span class="line">input  frameo_n;</span><br><span class="line">input  busy_n;</span><br><span class="line">  endclocking: cb</span><br><span class="line">  modport TB(clocking cb, output reset_n);</span><br><span class="line">endinterface: router_io</span><br></pre></td></tr></table></figure><p><strong>test.sv</strong>文件测试代码test.sv</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/`timescale <span class="number">1</span>ns/<span class="number">100</span>ps</span><br><span class="line">program automatic <span class="title function_">test</span><span class="params">(router_io.TB rtr_io)</span>;</span><br><span class="line">  initial begin</span><br><span class="line">    <span class="comment">//$vcdpluson; //don&#x27;t need in questasim enviroment</span></span><br><span class="line">reset();</span><br><span class="line">  end</span><br><span class="line">task <span class="title function_">reset</span><span class="params">()</span>;</span><br><span class="line">  repeat(<span class="number">5</span>) @(rtr_io.cb);</span><br><span class="line">  rtr_io.reset_n = <span class="number">1&#x27;b</span>0;</span><br><span class="line">  rtr_io.cb.frame_n &amp;lt;= <span class="string">&#x27;1;</span></span><br><span class="line"><span class="string">  rtr_io.cb.valid_n &amp;lt;= &#x27;</span><span class="number">1</span>;</span><br><span class="line">  #<span class="number">95</span> rtr_io.cb.reset_n &amp;lt;= <span class="number">1&#x27;b</span>1;</span><br><span class="line">  repeat(<span class="number">5</span>) @(rtr_io.cb);<span class="comment">//将仿真时间向前推进一个时钟上升沿。这里重复十次</span></span><br><span class="line">endtask: reset</span><br><span class="line">endprogram: test</span><br></pre></td></tr></table></figure><h2 id="编译仿真注意事项"><a href="#编译仿真注意事项" class="headerlink" title="编译仿真注意事项"></a>编译仿真注意事项</h2><h3 id="do文件的书写"><a href="#do文件的书写" class="headerlink" title=".do文件的书写"></a>.do文件的书写</h3><p>使用.do文件可以批量执行命令。使得我们在修改了代码之后，不需要再使用鼠标点击的方式重新编译，仿真，添加信号等操作。 使用是将需要仿真的文件.v，.sv放在当前工程目录下即可。将其保存为<code>sim.do</code>，执行是使用命令<code>do sim.do</code> 即可省去繁琐的鼠标点击</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> rtl *.v </span><br><span class="line"><span class="built_in">set</span> svtb *.sv</span><br><span class="line"><span class="built_in">set</span> testbench_name router_test_top</span><br><span class="line"><span class="built_in">set</span> sim_time <span class="number">2000</span>ns</span><br><span class="line"><span class="meta">#quietly set m_width 1920</span></span><br><span class="line"><span class="meta">#quietly set m_height 1080</span></span><br><span class="line"><span class="meta">#quietly set m_width 2560</span></span><br><span class="line"><span class="meta">#quietly set m_height 1660</span></span><br><span class="line"></span><br><span class="line">vlib work</span><br><span class="line">vmap work work</span><br><span class="line">vlog $rtl</span><br><span class="line">vlog $svtb</span><br><span class="line">vsim -t ns -novopt +notimingchecks work.$testbench_name</span><br><span class="line">add wave sim:/router_test_top/top_io<span class="comment">/*</span></span><br><span class="line"><span class="comment">run $sim_time</span></span><br><span class="line"><span class="comment">#view -undock wave -x 0 -y 0 -width $m_width -height $m_height</span></span><br></pre></td></tr></table></figure><h3 id="添加时间精度"><a href="#添加时间精度" class="headerlink" title="添加时间精度"></a>添加时间精度</h3><p>需要加上时间精度，在test.sv以及router_io.sv文件内。否则questasim会报出如下的问题。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># ** Error (suppressible): (vsim<span class="number">-3009</span>) [TSCALE] - Module <span class="string">&#x27;test&#x27;</span> does not have a timeunit/timeprecision specification in effect, but other modules <span class="keyword">do</span>.</span><br><span class="line">#Time: <span class="number">0</span> ns  Iteration: <span class="number">0</span>  Instance: /router_test_top/t File: test.sv</span><br><span class="line"># ** Error (suppressible): (vsim<span class="number">-3009</span>) [TSCALE] - Module <span class="string">&#x27;router_io&#x27;</span> does not have a timeunit/timeprecision specification in effect, but other modules <span class="keyword">do</span>.</span><br><span class="line">#Time: <span class="number">0</span> ns  Iteration: <span class="number">0</span>  Instance: /router_test_top/top_io File: router_io.sv</span><br></pre></td></tr></table></figure><h3 id="dve编译的时候遇见的问题"><a href="#dve编译的时候遇见的问题" class="headerlink" title="dve编译的时候遇见的问题"></a>dve编译的时候遇见的问题</h3><p>在直接<code>make test</code>时候，dve报错如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Error-[VCS_COM_UNE] Cannot find VCS compiler</span><br><span class="line">  VCS compiler not found. Environment variable <span class="title function_">VCS_HOME</span> </span><br><span class="line">  <span class="params">(/opt/Synopsys/VCS2018/vcs/O<span class="number">-2018.09</span>-SP2/linux)</span> is selecting a directory in </span><br><span class="line">  which there isn&#x27;t a compiler </span><br><span class="line">  &#x27;/opt/Synopsys/VCS2018/vcs/O-2018.09-SP2/linux/bin/vcs1&#x27; <span class="keyword">for</span> a machine of </span><br><span class="line">  this type &#x27;linux&#x27;.</span><br><span class="line">  Please check whether &#x27;VCS_HOME&#x27; is incorrect; <span class="keyword">if</span> not, see below.</span><br><span class="line"> Perhaps vcs hasn<span class="number">&#x27;</span>t been installed <span class="keyword">for</span> machine of type <span class="string">&quot;linux&quot;</span>.</span><br><span class="line"> Or the installation has been damaged.</span><br></pre></td></tr></table></figure><p>使用安装的时候是64位，需要在命令行加上<code>-full64</code>才可以</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">compile: </span><br><span class="line">vcs -l vcs.<span class="built_in">log</span> -sverilog -full64 -debug_all $(SVTB) $(RTL)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;首先明确实验的DUT(Design Under Test)的大致功能，然后我们再进一步进行下面的实验内容。如下图是DUT的一个基本的示意图。</summary>
      
    
    
    
    <category term="数字IC设计" scheme="http://example.com/categories/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="System Verilog labs学习笔记" scheme="http://example.com/categories/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1/System-Verilog-labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="sv_labs" scheme="http://example.com/tags/sv-labs/"/>
    
  </entry>
  
</feed>
